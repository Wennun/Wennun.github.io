[{"id":"53f3e274c7bda3bde7e9b295614179bc","title":"关于常引用的问题","content":"前言\n\n\n\n\n\n\n\n\n引用在c++中的使用非常常见，可以说是很重要的，引用的常引用相关的问题让很多人稍不留神就出错了，这里我们就来谈谈常引用的问题。\n关于权限\n\n\n\n\n\n\n\n\n\n关于权限有权限缩小和权限放大的问题，比如一个文件，当初它只有读的权限，而现在你给它再加个写的权限，这就是权限放大；又或当初它读，写的权限都有，但你把他某个权限或所有权限都限制了，这就是权限缩小。\n在指针和引用赋值中，权限可以缩小，但不可以放大：这里通常指的是变量的值可不可以改的问题，如果说是从改到不能改，这就是将权限缩小了，这是可行的；如果说是从不能改到能改，这就是权限放大了，此时是不行的。 \n而引用相当于起别名，对于这个别名的权限相对于本名变量有什么变化，这需要自己来决定。当自己决定别名的权限之后（不能与第二点表达的起冲突），对它的使用就要留个心眼。\n\n关于引用与const\n\n\n\n\n\n\n\n\nconst通常就是用来限制变量可以改，也就是这个变量的值不能被修改，结合上面的权限问题，我们来看以下例子：\n1.\nint a &#x3D; 10;\nconst int&amp; ra &#x3D; a;  &#x2F;&#x2F; ??\nint&amp; raa &#x3D; ra;  &#x2F;&#x2F; ??\n\n2.\nconst int b &#x3D; 20;\nint&amp; rb &#x3D; b;  &#x2F;&#x2F; ??\nconst int&amp; rrb &#x3D; b;  &#x2F;&#x2F; ??\n\n\n\n对于上述代码的第一种情况：  \n\n关于ra，ra是a的别名，并且被const修饰，此时ra的值是不能被修改的（要注意，这里单指ra，只是说不能使用ra对a的值进行修改，使用a修改值还是可以的，注意是单指ra这个别名），由a到ra，很明显改的权限没了，属于权限变小，是可行的。\n关于rra，rra是ra的别名，也就是a的别名的别名，本质还是一样的，只不过说，rra是相对于ra起的别名，ra的权限不能改，而rra前面没有const（能读能改），所以由ra到rra属于权限放大，是不可行的。\n\n\n对于上述代码的第二种情况：\n\n关于\trb\t，rb是b的别名，b前面使用了const修饰，说明它不能被修改，而rb前面没有const，说明可读可改，属于权限放大，是不可行的。\n关于rrb，rrb也是b的别名，b前面使用了const修饰，rrb前面也使用了const修饰，权限没有变，当然可行。\n\n\n\n\n\n\n\n\n\n\n\n\n当我们在使用引用的时候，若是有const出现，那一定要注意权限的问题，不然程序写完一运行全是问题。\n关于那秘密的一步\n\n\n\n\n\n\n\n\n这秘密的一步还是与权限有关，居然是与权限有关，那么指向的对象就只有指针和引用了。\n对于这秘密的一步，我们先来看以下例子：\n\tdouble b &#x3D; 13.14;\n\n&#x2F;&#x2F;1.\n\tint a &#x3D; b;  &#x2F;&#x2F; 隐式类型转换\n\tint c &#x3D; (int)b;  &#x2F;&#x2F; 强制类型转换\n\n&#x2F;&#x2F;2.\n\t&#x2F;&#x2F; 2.1. &#x2F;&#x2F; 隐式类型转换\n\tint&amp; rb &#x3D; b;   &#x2F;&#x2F; 出错   \n\tconst int&amp; rrb &#x3D; b;\n\t&#x2F;&#x2F; 2.2.  &#x2F;&#x2F; 强制类型转换\n\tint&amp; rrrb &#x3D; (int)b;   &#x2F;&#x2F; 出错\n\tconst int&amp; rrrrb &#x3D; (int)b;\n\n\n情况1：对于情况1，据前面的概念，变量a和c既不是指针也不是引用，所以这里当然是可行的。\n情况2：   2.1：   rb是b的别名，只不过rb的类型是（int）,b的类型是（double），所以b发生了隐式类型转换，那么这里为什么会出错呢？就是因为那秘密的一步：b的隐式类型转换，转换后的值会先交给一个临时变量tmp（此时tmp变为13），而语法规定，这个tmp是一个常量，当tmp的值再交给rb时，rb是一个别名，前面没有const修饰，具有改的权限，所以这里权限是放大了的，是不可行的。也因此这里会出错。而下一条语句，rrb前面有const修饰，所以没有出错。2.2：有了2.1的铺垫，实际上强转不强转的无所谓，最终还是归咎到有关const的权限问题，所以要理解那个tmp，也因此这里的rrrb会出错。\n\n当然，对于函数调用，也有相关问题：\n1.\nvoid fun(int&amp; rb)  &#x2F;&#x2F; 权限放大，不行\n&#123;\n\tcout &lt;&lt; rb &lt;&lt; endl;\n&#125;\n\ndouble b &#x3D; 13.14;\nfun(b); &#x2F;&#x2F; 隐式类型转换交给一个临时变量，这个临时变量是常量\n\n2.\nvoid fun(const int&amp; rb)  &#x2F;&#x2F; 权限不变，可行\n&#123;\n\tcout &lt;&lt; rb &lt;&lt; endl;\n&#125;\n\ndouble b &#x3D; 13.14;\nfun(b); &#x2F;&#x2F; 隐式类型转换交给一个临时变量，这个临时变量是常量\n\n\n无论是函数的传参还是返回，都存在那个临时变量的问题，规定了临时变量是一个常量，那就要小心这个点带来的问题。\n\n对于1，2，关注的点还是一样的，都是围绕一个权限的问题，所以当我们在对函数传参或者是接收函数返回值的时候，要注意要不要加const，这样才能在小的细节上不会出错。\n\n\n写在最后\n\n\n\n\n\n\n\n\n最后还是要强调，关于本章内容，一定要清楚，不能搞混，谁知道在以后写代码的时候会不会出类似错误呢？而一旦出现此类的问题，那就很难受了。可能一时半会都想不清楚到底是哪出了问题。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"关于常引用的问题-什么是权限放大？权限放小？隐式或强制转换居然还有这一步？","date":"2023-02-18T06:45:14.000Z","categories_index":"C++阶段相关知识点与问题的深度解析","tags_index":"C++","author_index":"坏 幸 运"},{"id":"a34c5dd4aef1e7a0fbf034a166eaf417","title":"关于C语言非常重要的动态内存管理函数的解析和使用","content":"前言\n\n\n\n\n\n\n\n\n\n动态内存管理函数可以说很好用，但是有些小危险。\n所谓动态内存分配，就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。 动态内存分配不像 数组 等 静态内存 分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。\n动态内存函数的头文件都是：&lt;stdlib.h&gt;\n\n为什么存在动态内存分配？我们已经掌握的内存开辟方式有：\nint val &#x3D; 20; &#x2F;&#x2F;在栈空间上开辟四个字节\nchar arr[10] &#x3D; &#123;0&#125;; &#x2F;&#x2F;在栈空间上开辟10个字节的连续空间\n\n\n但是上述的开辟空间的方式有两个特点：\n\n空间开辟大小是固定的。\n数组在声明的时候，必须指定数组的长度，它所需要的内存在编译时分配。但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态存开辟了。\n\n此外：在后面的通讯录的完整实现，以及数据结构的完整实现大都是需要动态内存来实现的。\nmalloc 和 free1.mallocmalloc是C语言提供的一个内存开辟函数，该函数的参数如下：\n\n\n返回值：\n\n\n这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。\n如果开辟成功，则返回一个指向开辟好空间的指针。\n如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。\n返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。\n如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。\n\n malloc开辟的内存空间都是每有初始化的，观察内存如下：\n\n2.freeC语言提供了另外一个函数free，专门是用来做动态内存的释放和回收的，函数参数如下：\n\n\n free函数用来释放动态开辟的内存。\n如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。\n如果参数 ptr 是NULL指针，则函数什么事都不做。\n\n注意：任何只要是开辟的动态内存空间（堆上的），都要free释放返还给操作系统。\n3.使用\n\n\n\n\n\n\n\n\nmalloc与free是要共同使用的，有malloc开辟空间就一定要有free释放空间，通过上面的函数介绍，接下来结合使用。\n例如，这里动态开辟一个能够存放10个整型的数组：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; &#x2F;&#x2F; 对应头文件\n\nint main()\n&#123;\n    &#x2F;&#x2F; 因为返回的是void*，最好强转以下\n\tint* tmp &#x3D; (int*)malloc(sizeof(int) * 10); &#x2F;&#x2F; 也可以直接放一个40（要40字节）\n\n\t&#x2F;&#x2F; 一定要检查开辟成功没有\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;malloc fail&quot;);  &#x2F;&#x2F; 这里打印错误“开辟失败”\n\t\texit(-1);  &#x2F;&#x2F; 这里可以理解为直接退出程序\n\t&#125;\n\n\t&#x2F;&#x2F; 开辟没问题，进行以下操作\n\t&#x2F;&#x2F; 给开辟的数组赋值\n\tfor (int i &#x3D; 0; i &lt; 10; ++i)\n\t&#123;\n\t\ttmp[i] &#x3D; i + 1;\n\t&#125;\n\n\t&#x2F;&#x2F; 打印\n\tfor (int i &#x3D; 0; i &lt; 10; ++i)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, tmp[i]);\n\t&#125;\n\n\t&#x2F;&#x2F; 操作完后一定要释放空间\n\t&#x2F;&#x2F; 传递指向那段空间起始位置的指针\n\tfree(tmp);\n\t&#x2F;&#x2F; 释放后要把该指针置为空，不然后面一不小心又使用该指针找到那块空间，属于非法访问了\n\ttmp &#x3D; NULL;  \n\n\treturn 0;\n&#125;\n如果后面不释放，虽然现在的机器大都会自动返还给操作系统，但是出于严谨和安全，一定要记得free,不然会造成内存泄露问题，这是很严重的。\ncalloc\n\n\n\n\n\n\n\n\ncalloc也是动态内存分配函数\n&#x2F;&#x2F; 例如这里开辟一个有十个整型元素的数组\nint* arr &#x3D; (int*)calloc(10, sizeof(int));\n\n\n\n\n通过上面的介绍，可以发现，calloc的功能与malloc几乎相同，其有两点不同之处：\n\ncalloc与malloc的函数参数不同；\ncalloc开辟的空间会将全部元素初始化0，而malloc则是随机值。\n\n如：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; &#x2F;&#x2F; 对应头文件\n\nint main()\n&#123;\n\t&#x2F;&#x2F;               个数     一个元素的大小\n\tint* tmp &#x3D; calloc(10, sizeof(int)); \n\n\t&#x2F;&#x2F; 一定要检查开辟成功没有\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;calloc fail&quot;);  &#x2F;&#x2F; 这里打印错误“开辟失败”\n\t\texit(-1);  &#x2F;&#x2F; 这里可以理解为直接退出程序\n\t&#125;\n\n\t&#x2F;&#x2F; 开辟没问题，进行以下操作\n\t&#x2F;&#x2F; 给开辟的数组赋值\n\tfor (int i &#x3D; 0; i &lt; 10; ++i)\n\t&#123;\n\t\ttmp[i] &#x3D; i + 1;\n\t&#125;\n\n\t&#x2F;&#x2F; 打印\n\tfor (int i &#x3D; 0; i &lt; 10; ++i)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, tmp[i]);\n\t&#125;\n\n\t&#x2F;&#x2F; 操作完后一定要释放空间\n\t&#x2F;&#x2F; 传递指向那段空间起始位置的指针\n\tfree(tmp);\n\t&#x2F;&#x2F; 释放后要把该指针置为空，不然后面一不小心又使用该指针找到那块空间，属于非法访问了\n\ttmp &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n所以如何我们对申请的内存空间的内容要求初始化，那么可以很方便的使用calloc函数来完成任务。\nrealloc\n\n\n\n\n\n\n\n\nrealloc函数的出现让动态内存管理更加灵活。\n\n有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候管理内存，我们一定会对内存的大小做灵活的调整。那 realloc 函数就可以做到对动态开辟内存大小的灵活调整。\n\n\n\n\n基础点：\n\nptr 是要调整的内存地址。\nsize 调整之后新大小。\n返回值为调整之后的内存起始位置。\n这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到 新 的空间。\n\n\nrealloc在调整内存空间的是存在两种情况：\n\n情况1： 内存中原有的空间之后有足够的空间来存放重新开辟的新大小的空间，这时直接在原有的空间之后追加空间。情况2： 内存中原有的空间之后没有足够的空间来存放重新开辟的新大小的空间，这时在堆上另找一个合适大小的连续空间来使用。\n\n那么我们如何来写代码呢？\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\tint* tmp &#x3D; (int*)malloc(100);\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;malloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F;扩展容量\n\t&#x2F;&#x2F;代码1\n\ttmp &#x3D; (int*)realloc(tmp, 1000);&#x2F;&#x2F;这样可以吗？(如果申请失败会如何？)\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\t\n\t&#x2F;&#x2F;代码2\n\tint* p &#x3D; realloc(tmp, 1000);\n\tif (p &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;realloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\ttmp &#x3D; p;\n\t\n\t&#x2F;&#x2F; 释放\n\tfree(tmp);\n\ttmp &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n上面有两种写法，代码1跟代码2。\n\n\n分析代码1：如果重新开辟的空间开辟成功，并且是在原空间上做修改，那么这是可行的；如果原空间后面没有足够空间来开辟，另寻找到一份空间来存放，此时的地址空间的起始地址发生了改变，如果空间申请失败，而此时又将该空间的起始地址给了原有的指针变量tmp，这时原有空间就找不到了，并且会出现错误，所以还是不严谨的；\n分析代码2：代码2是先将重新开辟的空间的起始地址交给一个临时变量，在判断这份空间的有效性，最后才赋值给原有的指针变量，这样做才是最安全且不会亏损原有空间的，所以，根据代码2的严谨性强的特点，以后realloc一定要写代码2这种样式。\n\n\n\n\n\n\n\n\n\n\n有了reallocbuff的加持，我们想让数组变他就嘚变，哈哈哈\n常见的动态内存错误1.对NULL指针的解引用操作void test()\n&#123;\n\t int *p &#x3D; (int *)malloc(INT_MAX&#x2F;4);\n\t &#x2F;&#x2F; 这里没有判断是否开辟成功\n\t *p &#x3D; 20;  &#x2F;&#x2F;如果p的值是NULL，就会有问题\n\t free(p);\n\t p &#x3D; NULL;\n&#125;\n\n2.对动态开辟空间的越界访问void test()\n&#123;\n\t int i &#x3D; 0;\n\t int *p &#x3D; (int *)malloc(10*sizeof(int));\n\t if(NULL &#x3D;&#x3D; p)\n\t &#123;\n\t     exit(-1);\n\t &#125;\n\t \n\t for(i &#x3D; 0; i &lt;&#x3D; 10; i++)\n\t &#123;\n\t     *(p+i) &#x3D; i;&#x2F;&#x2F;当i是10的时候越界访问\n\t &#125;\n\t \n\t free(p);\n\t p &#x3D; NULL;\n&#125;\n当i为10就越界访问了，越界访问的后果就不用多说了把（哈哈哈哈哈，非法闯入）。\n3.对非动态开辟内存使用free释放void test()\n&#123;\n\t int a &#x3D; 10;\n\t int *p &#x3D; &amp;a;\n\t free(p);  &#x2F;&#x2F;ok?\n\t p &#x3D; NULL;\n&#125;\nfree是不能释放除动态开辟的内存以外的内存的，只适用于堆上。\n4.使用free释放一块动态开辟内存的一部分void test()\n&#123;\n\t int *p &#x3D; (int *)malloc(100);\n\t p++;\n\t free(p);&#x2F;&#x2F;p不再指向动态内存的起始位置\n\t p &#x3D; NULL;\n&#125;\nfree这样子释放相当于拦腰截断，会存在内存泄漏的问题。\n5.对同一块动态内存多次释放void test()\n&#123;\n\t int *p &#x3D; (int *)malloc(100);\n\t free(p);\n\t free(p);&#x2F;&#x2F;重复释放\n\t p &#x3D; NULL;\n&#125;\n\n对同一块空间多次释放，这当然是不行的。\n6.动态开辟内存忘记释放（内存泄漏）这样是绝对不行的，内存泄漏迟早会吃光你的内存。\n例如：\nvoid test()\n&#123;\n\t int *p &#x3D; (int *)malloc(100);\n\t if(NULL !&#x3D; p)\n\t &#123;\n\t \t*p &#x3D; 20;\n\t &#125;\n&#125;\nint main()\n&#123;\n\t test();\n\t &#x2F;&#x2F; p指向的动态内存空间没有释放，虽然p变量销毁了，但申请的空间还在\n\t return 0；\n&#125;\n\n写在最后\n\n\n\n\n\n\n\n\n动态内存分配是不是很容易就学会了，接下来就可以 ”肆无忌惮“ 的玩弄 ”数组“ 了，不过要小心内存泄漏噢！\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"关于C语言非常重要的动态内存管理函数的解析和使用","date":"2023-02-18T06:14:44.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"f270be882af30c8038e39539db2e9228","title":"C语言常用内存函数的深度解析与自我实现","content":"前言\n\n\n\n\n\n\n\n\n\n内存函数的使用广泛度大于常用字符串函数的使用广泛度，因为字符串函数只适用于与字符相关的，而内存函数适用于各个类型，因为他是从内存出发，对内存进行修改，因此，学会内存函数，可谓收获满满呀。\n这些内存函数的头文件是&lt;string.h&gt;\n\nmemcpy\n\n\n\n\n\n\n\n\n\n该函数的功能是内存拷贝，相当于字符串函数strncpy的功能，只不过memcpy的运用范围更宽。\n该函数是在内存中一对字节一对字节的拷贝。\n\n该函数的函数参数：\n\n\n\n\n\n\n\n\n\n\n\n可以看到，对于重叠的拷贝，memcpy是做不到的（也就是一个数组arr[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;,1,2,3,4,5要拷贝到3,4,5,6,7上去，这样是不行的），此时应该用memmove，但是vs的memcpy超额完成了任务，也可以进行重叠拷贝。\n\nmemcpy函数的使用#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tint arr1[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\n\tint arr2[] &#x3D; &#123; 9,9,9,9,9 &#125;;\n\n\tmemcpy(arr1, arr2, sizeof(int) * (sizeof(arr2) &#x2F; sizeof(arr2[0])));\n\t&#x2F;&#x2F; sizeof(int) * (sizeof(arr2) &#x2F; sizeof(arr2[0])) arr2的总字节个数；\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(arr1) &#x2F; sizeof(arr1[0]); i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr1[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n运行结果：9 9 9 9 9 6 7 8 9 10\nmemcpy对字符串也是一样：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;xxxxxxxxxx&quot;;\n\tchar arr2[] &#x3D; &quot;abcdef&quot;;\n\n\t&#x2F;&#x2F; 这里拷贝6个字节，注意最好拷贝的时候不要把\\0弄没了，不然打印会出错\n\tprintf(&quot;%s\\n&quot;, (char*)memcpy(arr1, arr2, 6));\n\t&#x2F;&#x2F; 因为返回的是 void* 所以最好强转一下 \n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果：abcdefxxxx\nmemcpy函数的自我实现\n\n\n\n\n\n\n\n\n代码实现的核心在于，如何一个字节一个字节的拷贝，如何拷贝完一个字节找到后一个字节。\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nvoid* my_memcpy(void* dest, const void* src, size_t num)\n&#123;\n\tassert(dest &amp;&amp; src);\n\n\t&#x2F;&#x2F; 先保存目的地的开头地址，以便于返回\n\tvoid* ret &#x3D; dest;\n\n\twhile (num--) &#x2F;&#x2F; 当num为0拷贝字节数已够，拷贝结束\n\t&#123;\n\t\t&#x2F;&#x2F; 强转成char*的指针，因为这样，才是一个字节一个字节的拷贝\n\t\t*(char*)dest &#x3D; *(char*)src;\n\n\t\t&#x2F;&#x2F; 强转成char*指针++向后走跳过一个字节，为下一次的字节拷贝做准备；\n\t\t++(char*)dest;\n\t\t++(char*)src;\n\t&#125;\n\n\treturn ret;\n&#125;\n\nint main()\n&#123;\n\tint a1[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\n\tint a2[] &#x3D; &#123; 9,9,9,9,9 &#125;;\n\n\tmy_memcpy(a1, a2, 20);\n\t&#x2F;&#x2F; 20:a2的总字节数\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(a1) &#x2F; sizeof(a1[0]); ++i)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, a1[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n运行结果为：9 9 9 9 9 6 7 8 9 10\n如果我们用自我实现得功能来进行重叠拷贝：\n\n运行结果为：\n\n\n为什么会这样呢？\n\n\n\n\n\n\n\n\n\n1和2拷贝过去，此时arr原有的第三个和第四个元素（3和4所在位置）也被改为了1和2，当拷贝第三个元素时，是将1拷贝过去而不是原先的3了。\n但如果是memmove就不会有这样的情况.\n\n\n\nmemmove\n\n\n\n\n\n\n\n\n该函数的功能也相当于是“内存拷贝”，它包含了memcpy的功能，同时比memcpy函数更为的强大，它可以对重叠的内容进行拷贝，也就是一个数组arr[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;,1,2,3,4,5要拷贝到3,4,5,6,7上去，最终数组内容变为1,2,1,2,3,4,5,8,9,10。\n\n\n\nmemmove函数的使用#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tint a1[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9 &#125;;\n\tint a2[] &#x3D; &#123; 6,6,6,6,6 &#125;;\n\n\tmemmove(a1, a2, 20);\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(a1) &#x2F; sizeof(a1[0]); ++i)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, a1[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n运行结果为：\n\n\n可以看到，这种拷贝的功能与memcpy是一样的，接下来进行不一样的重叠拷贝：#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\n\n\tmemmove(arr + 2, arr, 20);\n\t&#x2F;&#x2F; 将 1 2 3 4 5 拷贝到 3 4 5 6 7 上面去\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(arr) &#x2F; sizeof(arr[0]); ++i)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n把arr + 2 当作dest，arr当作src，也就是说此时src要小于dest，即得出当src &lt; dest时由后往前拷贝；\n\n这里是memmove(arr + 2, arr, 20),如果是memmove(arr, arr + 2, 20)（将3,4,5,6,7拷贝到1,2,3,4,5上面去）呢？此时arr + 2为src，arr为dest，这时候就需要从前向后拷贝了，也就是src &gt; dest的情况，即得出当src &gt; dest时由前向后拷贝。\n\n还有一种情况：memmove(arr, arr + 5, 20)是把6,7,8,9,10拷贝到1,2,3,4,5上去，这时虽然src大于dest，但是src与dest的字节差值大于等于了num，也就是说无论是从前向后拷贝还是从后向前拷贝都是一样的,此时的功能就可以理解为是memcpy的功能了。\n\n\nmemmove函数的自我实现\n\n\n\n\n\n\n\n\n\n通过上面的使用和分析，有三种情况都是要考虑到：1.从前向后拷贝src &gt; dest；2.从后向前拷贝src &lt; dest；3.从后向前还是从前向后都是可以的sizeof(type) * |(src - dest)| &gt;= num。\n\n\n代码实现：\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nvoid* my_memmove(void* dest, const void* src, size_t num)\n&#123;\n\tassert(dest &amp;&amp; src);\n\n\tvoid* ret &#x3D; dest;\n\n\t&#x2F;&#x2F; 落在第三区间总会进一种拷贝方式\n\tif (src &lt; dest)\n\t&#123;\n\t\t&#x2F;&#x2F; 从后往前\n\t\twhile (num--) &#x2F;&#x2F; 因为判断后 num-- 一次，第一次进来如果num开始为20，\n\t\t&#123;             &#x2F;&#x2F; 进来后等于19找到最后一个字节拷贝\n\n\t\t\t&#x2F;&#x2F; 随着num--，拷贝的字节从后往前依次跳一个字节\n\t\t\t*((char*)dest + num) &#x3D; *((char*)src + num);\n\t\t&#125;\n\t&#125;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F; 从前往后\n\t\twhile (num--)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 这里跟上面的memcpy的自我实现差不多，但是memcpy也可以以从后往前的方式实现\n\t\t\t*(char*)dest &#x3D; *(char*)src;\n\t\t\t++(char*)dest;\n\t\t\t++(char*)src;\n\t\t&#125;\n\t&#125;\n\t\n\treturn ret;\n&#125;\n\nint main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\n\n\tmy_memmove(arr + 2, arr, 20);\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(arr) &#x2F; sizeof(arr[0]); ++i)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n运行结果为：1 2 1 2 3 4 5 8 9 10 \n\n\n\n\n\n\n\n\n\n实现了重叠拷贝，当然其它案例也行，这里大家自行测试了。\nmemcmp\n\n\n\n\n\n\n\n\n\n该函数是比较函数，与strncmp的功能相同，只不过memcmp的对比类型不单只是字符类型了。\nmemcmp是一个字节一个字节的对比。\n\n函数参数如下：\n函数的返回值：如果前num个字节ptr1与ptr2都相等，则返回0，如果找到第一个不相等的字节，返回ptr1的这个字节减去ptr2的这个字节的差值。\nmemcmp函数的使用1.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tint a1[] &#x3D; &#123; 1,2,3,4,5,6,7,8 &#125;;\n\tint a2[] &#x3D; &#123; 1,2 &#125;;\n\n\tprintf(&quot;%d\\n&quot;, memcmp(a1, a2, 8));\n\t&#x2F;&#x2F; 8个字节，比较前两个元素\n\n\treturn 0;\n&#125;\n\n2.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tint a1[] &#x3D; &#123; 1,2,3,4,5,6,7,8 &#125;;\n\tint a2[] &#x3D; &#123; 1,2,5 &#125;;\n\n\tprintf(&quot;%d\\n&quot;, memcmp(a1, a2, 12));\n\t&#x2F;&#x2F; 12个字节，比较前三个元素\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n由于vs的memcmp标准是小于就返回-1，大于就返回1，所以这里的结果为-1。\nmemcmp函数的自我实现\n\n\n\n\n\n\n\n\n经过上面的介绍，我们大概知道了这个函数的功能，接下来自我实现这个函数。\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nint my_memcmp(const void* ptr1, const void* ptr2, size_t num)\n&#123;\n\tassert(ptr1 &amp;&amp; ptr2);\n    \n    &#x2F;&#x2F; 比对次数--\n\twhile (num--)\n\t&#123;\n\t    &#x2F;&#x2F; 如果有不相同的字节，这里为真，进去返回差值\n\t\tif (*(char*)ptr1 - *(char*)ptr2)\n\t\t\treturn *(char*)ptr1 - *(char*)ptr2;\n\n\t\t++(char*)ptr1;\n\t\t++(char*)ptr2;\n\t&#125;\n    \n    &#x2F;&#x2F; 比对完了没有找到不相同的字节说明都相同，返回0；\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\tint a1[] &#x3D; &#123; 1,2,3,4,5,6,7,8 &#125;;\n\tint a2[] &#x3D; &#123; 1,2,5 &#125;;\n\n\tprintf(&quot;%d\\n&quot;, my_memcmp(a1, a2, 8));\n\t&#x2F;&#x2F; 12个字节，比较前三个元素\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n运行结果为：-2\nmemset\n\n\n\n\n\n\n\n\n该函数的功能是填充内存块，也就是将一个数组里面你指定的内容以修改字节的形式修改成你想要的数据。\n\n这里的value虽然是int，但是字符也可以修改，因为字符类型本身就是整型家族，字符可以通过ASCLL码值来进行转换。\nmemset函数的使用\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr[] &#x3D; &quot;xxxxxxxxxx&quot;;\n\n\tprintf(&quot;%s\\n&quot;, (char*)memset(arr, &#39;y&#39;, 5));\n\n\treturn 0;\n&#125;\n\n2.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\n\n\tprintf(&quot;%s\\n&quot;, (char*)memset(arr, 1, 40));\n\t&#x2F;&#x2F; 40表示整个arr的字节个数\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n运行结果为：16843009 16843009 16843009 16843009 16843009 16843009 16843009 16843009 16843009 16843009\n为什么运行结果会是这样子呢？\n\n\n\n\n\n\n\n\n\n\n我们将数组arr40个字节都改为1，一个整型有4个字节，如果每一个字节上面都是1，在内存当中每个整型的存放是这样的：01 01 01 01，所以当我们从内存中将这个数据读取出来的时候，那将会是一个很大的数，就如上面的运行结果一样的。\n所以对于整型数组我们一定要避免出现这样的情况，要牢记这是一个字节一个字节的修改。\n\nmemset函数的自我实现\n\n\n\n\n\n\n\n\n通过上面的认识，下面自我实现memset函数：\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nvoid* my_memset(void* ptr, int value, size_t num)\n&#123;\n\tassert(ptr);\n\n\tvoid* ret &#x3D; ptr;\n\n\twhile (num--)\n\t&#123;\n\t\t*(char*)ptr &#x3D; value;\n\t\t++(char*)ptr;\n\t&#125;\n\n\treturn ret;\n&#125;\n\nint main()\n&#123;\n\tchar a[] &#x3D; &quot;abcdefgh&quot;;\n\n\tprintf(&quot;%s\\n&quot;, (char*)my_memset(a, &#39;@&#39;, 5));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：@@@@@fgh\n写在最后\n\n\n\n\n\n\n\n\n在C语言中，熟练的使用内存函数可以说对内存的理解也是很不错的，能够以内存的视角观察代码，说明你的水平已经很不错了。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"C语言常用内存函数的深度解析与自我实现","date":"2023-02-18T04:05:03.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"10386f8dcb44ec1bbe05b4072762a00e","title":"C语言预处理相关知识的介绍和解析","content":"\n前言\n上篇文章介绍了一个程序运行的 编译与链接 ，其中编译阶段有个预处理，他会对一些预处理指令进行处理，本章就对这些预处理相关的指令，操作符等等进行探讨。\n\n预定义符号介绍 这里介绍一些可能会常用到的符号：\n__FILE__      &#x2F;&#x2F;进行编译的源文件\n__LINE__     &#x2F;&#x2F;文件当前的行号\n__DATE__    &#x2F;&#x2F;文件被编译的日期\n__TIME__    &#x2F;&#x2F;文件被编译的时间\n__STDC__    &#x2F;&#x2F;如果编译器遵循ANSI C，其值为1，否则未定义\n\n这些预定义符号都是语言内置的，都已经为其设定了特有的值，下面来看看个别的值是啥呢：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tprintf(&quot;%s\\n&quot;, __FILE__);\n\tprintf(&quot;%d\\n&quot;, __LINE__);\n\tprintf(&quot;%s\\n&quot;, __DATE__);\n\tprintf(&quot;%s\\n&quot;, __TIME__);\n\n\t&#x2F;&#x2F; 下面的_STDC_在vs上是未定义的，编译就会报错\n\t&#x2F;&#x2F;printf(&quot;%d\\n&quot;, __STDC__); \n\n\treturn 0;\n&#125;\n\n有了这些预定义符号，我们可以随时随地的知道此时的时间和文件所在位置啦。\n预处理指令#define\n\n\n\n\n\n\n\n\n在Ｃ或C++语言源程序中允许用一个标识符来表示一个字符串，称为“宏”。被定义为“宏”的标识符称为“宏名”。在编译预处理时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换，这称为“宏代换”或“宏展开”。宏定义是由源程序中的宏定义命令完成的。宏代换是由预处理程序自动完成的。\n\n&#x3D;&#x3D;#define&#x3D;&#x3D; 和 &#x3D;&#x3D;#include&#x3D;&#x3D; 一样，也是以“&#x3D;&#x3D;#&#x3D;&#x3D;”开头的。凡是以“#”开头的均为预处理指令，&#x3D;&#x3D;#define&#x3D;&#x3D;也不例外。\n\n&#x3D;&#x3D;#define&#x3D;&#x3D;又称宏定义，标识符为所定义的宏名，简称宏。标识符的命名规则与前面讲的变量的命名规则是一样的。&#x3D;&#x3D;#define&#x3D;&#x3D; 的功能是将标识符定义为其后的常量。一经定义，程序中就可以直接用标识符来表示这个常量。是不是与定义变量类似？但是要区分开！变量名表示的是一个变量，但宏名表示的是一个常量。可以给变量赋值，但绝不能给常量赋值。\n\n宏定义 &#x3D;&#x3D;#define&#x3D;&#x3D; 一般都写在函数外面，与 &#x3D;&#x3D;#include&#x3D;&#x3D; 写在一起。当然，写在函数里面也没有语法错误，但通常不那么写。&#x3D;&#x3D;#define&#x3D;&#x3D; 的作用域为自 &#x3D;&#x3D;#define&#x3D;&#x3D; 那一行起到源程序结束。如果要终止其作用域可以使用 &#x3D;&#x3D;#undef&#x3D;&#x3D; 命令，下面会介绍。\n\n\n\n还需详细了解 &#x3D;&#x3D;#define&#x3D;&#x3D;， 可以点此链接观摩大佬解析。\n\n语法：\n#define name stuff\n\n举些个栗子：\n#define MAX 100\n#define FOREVER for(;;)\n#define reg register\n\n\n可以看到宏的命名习惯都是大写，这样更能区别。\n\n标识符的定义与常量是以空格隔开的。\n\n第一个定义了一个标识符 &#x3D;&#x3D;MAX&#x3D;&#x3D; ,它是常量 100,当我们在用这个标识符时，在预处理阶段，&#x3D;&#x3D;MAX&#x3D;&#x3D; 将会被替换成100。\n\n第二个是用更形象的符号来替换一种实现， &#x3D;&#x3D;for( ; ; )&#x3D;&#x3D; 相当于死循环，这里用 &#x3D;&#x3D;FOREVER&#x3D;&#x3D; 来形象的表示它。\n\n第三个是为 &#x3D;&#x3D;register&#x3D;&#x3D;这个关键字，创建一个简短的名字。\n\n\n那么我们在define 定义标识符的时候，要不要在最后加上 ; ？\n比如：\n#define MAX 100;\n建议不要加上，因为当我们写C语言程序时，都会习惯在后面加上分号，如果是一个变量等于这个&#x3D;&#x3D;MAX&#x3D;&#x3D;（int max &#x3D; MAX；），这时预处理阶段，会把这个 &#x3D;&#x3D;MAX&#x3D;&#x3D; 替换，变成 int max &#x3D; 100;; ，此时有两个分号，这就出现了语法问题。\n\n#define 定义宏：#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。\n下面是宏的申明方式：\n#define name( parament-list ) stuff\n其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中。\n注意：\n\n参数列表的左括号必须与name紧邻。\n如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分。\n\n如：\n#define SQUARE(x)  x * x\n这个宏接收一个参数 x ，如果在上述声明后，有以下写法：\nSQUARE(5);\nSQUARE(2 + 3);\n\n第一种预处理阶段被替换后表达式变为：&#x3D;&#x3D;5 * 5&#x3D;&#x3D;；（计算结果为25）第二种预处理阶段被替换后表达式变为：&#x3D;&#x3D;2 + 3 * 2 + 3&#x3D;&#x3D;；（计算结果为11）\n可以看出，第二种并不是我们想要的结果，所以这种定义宏的方式有问题\n那如果这样子使用呢：\nSQUARE((2 + 3));\n替换后表达式变为：&#x3D;&#x3D;(2 + 3) * (2 + 3)&#x3D;&#x3D;；这样子是可以的，但是这样治标不治本，而且写的代码还不好看，所以我们直接在定义宏处加上括号，这样就更好了。\n更新之后：\n#define SQUARE(x)  (x) * (x)\n那么这样子是否还会有问题呢？实际上还是有的。\n如果是一下定义的宏：\n#define SQUARE(x)  (x) + (x)\n\n有了上面的声明后，进行一下操作：\nint a &#x3D; 5 * SQUARE(5);\n\n替换后表达式为：\nint a &#x3D; 5 * 5 + 5;\n计算结果为：30，这也与我们想要的值不符。\n所以我们在定义时要给整体也加上一个括号，这样才不会出错\n正确规范定义：\n#define SQUARE(x)  ((x) + (x))\n\n所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间产生的不可预料的相互作用。\n\n#define替换规则在程序中扩展 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义符号和宏时，需要涉及几个步骤。\n\n在调用宏时，首先对参数进行检查，看看是否包含任何由 &#x3D;&#x3D;#define&#x3D;&#x3D;定义的符号。如果是，它们首先被替换。\n替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。\n最后，再次对结果文件进行扫描，看看它是否包含任何由 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义的符号。如果是，就重复上述处理过程。\n\n注意：4. 宏参数和 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义中可以出现其他 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义的符号。但是对于宏，不能出现递归。5. 当预处理器搜索 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义的符号的时候，字符串常量的内容并不被搜索。\n\n预处理指令 #undef\n\n\n\n\n\n\n\n\n这条指令用于移除一个宏定义。\n在一个程序块中用完宏定义后，为防止后面标识符冲突需要取消其宏定义。\n例如：\n#define MAX 100\nint a &#x3D; 100;\n#undef MAX\n这里第三行就取消了MAX的红定义，在下面还可以继续定义以MAX为标识符的宏。\n\n宏和函数的对比宏通常被应用于执行简单的运算，比如在两个数中找出较大的一个：\n#define MAX(a, b) ((a)&gt;(b)?(a):(b))\n\n\n那为什么不用函数来完成这个任务呢？\n原因有两点：\n\n用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多（也就是函数调用和函数返回的栈帧的创建和销毁可能比实际的代码功能运行时间还要长）。所以宏比函数在程序的规模和速度方面更胜一筹。\n更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏可以适用于整形、长整型、浮点型等可以用&gt;来比较的类型。宏是类型无关的。\n\n当然宏跟函数比较，也有其缺点：\n\n每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。\n宏是没法调试的（不可以调试可能程序怎么出错的都不知道）。\n宏由于类型无关，也就不够严谨。\n宏可能会带来运算符优先级的问题，导致程容易出现错。\n\n 根据宏的优点举个栗子（宏的参数可以出现类型，但是函数做不到）：\n#define MALLOC(num, type) (type *)malloc(num * sizeof(type))\n...\n&#x2F;&#x2F;使用\nMALLOC(10, int);  &#x2F;&#x2F;类型作为参数\n\n&#x2F;&#x2F;预处理器替换之后：\n(int *)malloc(10 * sizeof(int));\n\n\n宏和函数的对比图\n\n命名约定\n\n\n\n\n\n\n\n\n一般来讲函数和宏的语法很相似。所以语法本身没法帮我们区分二者。\n那我们平时的一个习惯是：\n\n把宏名全部大写\n函数名不要全部大写\n\n\n命令行定义\n\n\n\n\n\n\n\n\n许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。\n例如：\n\n当我们根据同一个源文件要编译出一个程序的不同版本的时候，这个特性有点用处（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大些，我们需要一个数组能够大些）。\n\n如有下面的代码（在linux中）：\n#include &lt;stdio.h&gt;\nint main()\n&#123;\n    int array [ARRAY_SIZE];\n    int i &#x3D; 0;\n    \n    for(i &#x3D; 0; i &lt; ARRAY_SIZE; i++)\n    &#123;\n        array[i] &#x3D; i;\n    &#125;\n    \n    for(i &#x3D; 0; i &lt; ARRAY_SIZE; i++)\n    &#123;\n        printf(&quot;%d &quot; ,array[i]);\n    &#125;\n    printf(&quot;\\n&quot; );\n    \n    return 0;\n&#125;\n可以看到，上面的 &#x3D;&#x3D;ARRAY_SIZE&#x3D;&#x3D;是未定义的，但是我们可以通过以下指令对其赋值：\n\n\n\n\n\n\n\n\n\nlinux 环境演示指令： &#x3D;&#x3D;gcc -D ARRAY_SIZE&#x3D;10 programe.c&#x3D;&#x3D;\n这样也可以灵活的控制数组大小啦。\n\n条件编译在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。\n比如说：\n调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译。\n#include &lt;stdio.h&gt;\n\n#define __DEBUG__\n\nint main()\n&#123;\n\t int i &#x3D; 0;\n\t int arr[10] &#x3D; &#123;0&#125;;\n\t \n\t for(i&#x3D;0; i&lt;10; i++)\n\t &#123;\n\t     arr[i] &#x3D; i;\n\t     \n\t     #ifdef __DEBUG__\n\t     printf(&quot;%d\\n&quot;, arr[i]);    &#x2F;&#x2F;为了观察数组是否赋值成功。 \n\t     #endif     &#x2F;&#x2F;__DEBUG__\n     &#125;\n \n return 0;\n&#125;\n&#x3D;&#x3D;#ifdef&#x3D;&#x3D; 是如果定义了就干嘛干嘛，&#x3D;&#x3D;#endif&#x3D;&#x3D; 是截断 &#x3D;&#x3D;#ifdef&#x3D;&#x3D;的作用继续往下延伸。\n可以看到，前面定义了_DEBUG_,所以后面的 printf(&quot;%d\\n&quot;, arr[i]); 这条语句将会被编译执行。\n\n常见的条件编译指令：\n\n1.\n#if 常量表达式\n &#x2F;&#x2F;...\n#endif\n&#x2F;&#x2F;常量表达式由预处理器求值。\n如：\n#define __DEBUG__ 1\n#if __DEBUG__\n &#x2F;&#x2F;..\n#endif\n\n2.多个分支的条件编译\n#if 常量表达式\n &#x2F;&#x2F;...\n#elif 常量表达式\n &#x2F;&#x2F;...\n#else\n &#x2F;&#x2F;...\n#endif\n\n3.判断是否被定义\n#if defined(symbol)\n#ifdef symbol\n#if !defined(symbol)\n#ifndef symbol\n\n4.嵌套指令\n#if defined(OS_UNIX)\n   #ifdef OPTION1\n      unix_version_option1();\n   #endif\n   #ifdef OPTION2\n      unix_version_option2();\n   #endif\n#elif defined(OS_MSDOS)\n   #ifdef OPTION2\n      msdos_version_option2();\n   #endif\n#endif\n\n\n\n\n\n\n\n\n\n\n预处理指令 #include#include 可以说是再熟悉不过了，我们已经知道， #include 指令可以使另外一个文件被编译。就像它实际出现于 #include 指令的地方一样。\n这种替换的方式很简单：\n\n预处理器先删除这条指令，并用包含文件的内容替换。\n这样一个源文件被包含10次，那就实际被编译10次。\n\n而头文件的包含方式有两种：\n\n一种是本地文件包含：\n\n#include &quot;filename&quot;\n\n查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。如果找不到就提示编译错误。\n\n&#x3D;&#x3D;Linux环境的标准头文件的路径：&#x3D;&#x3D;\n&#x2F;usr&#x2F;include\n&#x3D;&#x3D;VS环境的标准头文件的路径：&#x3D;&#x3D;\n注意： 不同编译器可能放在不同地方，要按照自己的安装路径去找。\nC:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\n\n\n\n一种是库文件包含\n\n#include &lt;filename.h&gt;\n\n\n查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。这样是不是可以说，对于库文件也可以使用 “ ” 的形式包含？答案是肯定的，可以。   但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了。\n嵌套文件包含如果出现这样的场景：\n\ncomm.h和comm.c是公共模块。\ntest1.h和test1.c使用了公共模块。\ntest2.h和test2.c使用了公共模块。\ntest.h和test.c使用了test1模块和test2模块。\n这样最终程序中就会出现两份comm.h的内容。这样就造成了文件内容的重复。\n\n\n那么如何解决这样的问题呢？ 答案是：条件编译。\n每个头文件的开头写：\n#ifndef __TEST_H__\n#define __TEST_H__\n&#x2F;&#x2F;头文件的内容\n#endif  &#x2F;&#x2F; __TEST_H__\n或者：\n#pragma once\n\n\n就可以避免头文件的重复引入。\n注：\n推荐 &#x3D;&#x3D;《高质量C&#x2F;C++编程指南》&#x3D;&#x3D; 中附录的考试试卷（很重要）。\n笔试题：\n1. 头文件中的 ifndef&#x2F;define&#x2F;endif是干什么用的?\n2. #include &lt;filename.h&gt; 和 #include &quot;filename.h&quot;有什么区别?\n\n\n\n\n其他预处理指令#error\n#pragma\n#line\n...\n\n这里就不一一做介绍，可以自己去了解。 &#x3D;&#x3D;#pragma pack()&#x3D;&#x3D; 在 结构体一章 介绍了，可以去看噢。\n写在最后\n\n\n\n\n\n\n\n\nC语言阶段的知识学到这里，差不多就结束了呢，一路过来还是学到了非常多的知识，这也让我更加认清了自己的路还长着呢，接下来我会继续更新 &#x3D;&#x3D;基本数据结构&#x3D;&#x3D; 阶段的相关知识。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"C语言预处理相关知识的介绍和解析","date":"2023-02-18T06:43:28.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"9644227715b55b99af65739565b00100","title":"程序的编译与链接","content":"\n前言\n\n\n\n\n\n\n\n\n每当我们运行一段代码时，编译器都会自动的帮我们编译代码并将代码转换为一个二进制可执行文件（.exe）， 有了这个可执行文件，便可以执行我们写的程序了。那么编译器对代码的编译以及生成可执行程序的过程是怎样的呢？这个问题便是本文章将要探讨的。\n\n程序的环境在ANSI C的任何一种实现中，存在两个不同的环境，一种是&#x3D;&#x3D;翻译环境&#x3D;&#x3D;，一种是&#x3D;&#x3D;执行环境&#x3D;&#x3D;：\n\n翻译环境：在这个环境中源代码被转换为可执行的机器指令；\n执行环境：这个环境用于实际执行代码。\n\n补充：\n\n程序的编译与链接首先看看 &#x3D;&#x3D;翻译环境&#x3D;&#x3D; 的简图：\n\n组成一个程序的每个源文件通过编译过程分别转换成目标代码（object code）。\n每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序。\n链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索序员个人的程序库，将其需要的函数也链接到程序中。\n\n\n编译本身也分为几个阶段：&#x3D;&#x3D;预编译  —&gt;  编译 —&gt; 汇编&#x3D;&#x3D;\n\n\n预编译（预处理）预编译又叫预处理。预编译不是编译，而是编译前的处理，编译器正式开始编译程序之前，会执行一段预处理程序（又称预处理器）专门对程序执行预处理操作。\n\n预处理阶段要做的事情主要是这些：\n\n对#include 头文件的包含；\n对#define定义符号的替换和删除；\n注释的删除。\n\n接下来在linux中用&#x3D;&#x3D;gcc&#x3D;&#x3D;编译器对一段代码进行预处理，如下：\n预处理过后，我们观察test.i这个预编译后的文件：\n\n\n\n\n\n\n\n\n\n指令：gcc -E test.c -o test.i\n&gt;可以看到，代码一下子膨胀了许多，这正是因为头文件被包含进来了，当来原先的#define与注释也不见了。\n编译\n\n编译阶段是将C语言代码翻译成&#x3D;&#x3D;汇编代码&#x3D;&#x3D;， 其过程有：\n\n语法分析；\n词法分析；\n语义分析；\n&#x3D;&#x3D;符号汇总&#x3D;&#x3D;。\n\n符号汇总就是将相关的函数，以及全局变量汇总：\n例如以下代码汇总后客观图：\n将上述代码编译后：\n\n\n\n\n\n\n\n\n\n指令：gcc -S test.c -o test.s\n\n\n\n\n\n\n\n\n\n\n可以看到，C语言被翻译成了汇编代码。\n\n\n汇编\n\n\n汇编是将汇编代码翻译成了&#x3D;&#x3D;二进制指令&#x3D;&#x3D;（存放目标文件），也就是生成目标文件的一步（test.o）；\n汇编使汇总的符号&#x3D;&#x3D;形成符号表&#x3D;&#x3D;，也就是每个符号对应一个地址。\n\n如下：\n就将上述代码汇编，我们来看看test.o是不是二进制文件呢？\n\n\n\n\n\n\n\n\n\n指令：gcc -c test.c -o test.o\n\n\n\n\n\n\n\n\n\n\n可以看到，的确是一些二进制乱码。\n\n通过编译的一系列过程后，接下来就是链接了\n链接的相关过程有：       1. 合并段表（这里不解释，需了解细读《程序员的自我修养》这本书，里面对整个编译链接部分都有很详细的讲解）     2. 符号表的合并和重定位。\n这里只讲解符号表的合并：\n\n在上面所探讨的编译过程，每一个文件都会形成自己的目标文件，在汇编这一步，又会形成自己的符号表；\n如果一个程序有两个文件，就会有两个符号表，所以，符号表的合并，就是链接的一步。\n\n例如test1.c文件和test2.c文件的符号表合并过程：\n\n\n\n\n\n\n\n\n\n\n最终，通过链接器和链接库将各个目标文件链接后形成可执行文件。\n\n程序执行的过程：\n\n程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。\n程序的执行便开始。接着便调用main函数。\n开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。\n终止程序。正常终止main函数；也有可能是意外终止。\n\n\n写在最后\n\n\n\n\n\n\n\n\n如果说，你对这一块特别感兴趣，想继续深入，你可以读《程序员的自我修养》这本书,这本书里对这一块的知识有很详细的解析。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"程序的编译与链接","date":"2023-02-18T06:41:16.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"c2996624a24a0b1686f1aaf8ff1ca6e4","title":"关于C语言对文件的操作","content":"前言\n\n\n\n\n\n\n\n\n\n相信大家对文件都不陌生，我们在计算机的一系列操作都离不开文件，如果Linux没有了文件，那他就不叫Linux了，有了文件，我们的计算机才能够正常运行，有了文件我们才能够在计算机上写东西并能够帮我们保存下来。\nC语言也提供了一系列的函数来操控文件，本篇文章只介绍那些常见和常用的函数。\n\n1. 为什么使用文件我们有可能会写通讯录，写过通讯录的都知道，如果没有文件操作，程序运行后输入的数据在程序结束就没有了，联系人信息也就没有了，如果不能存放联系人的信息，那通讯录还有什么用？所以必然的我们需要文件操作来将输入的联系人的信息存放到文件当中，下一次运行时再将之前已经保存在文件中的联系人的信息拿出来，这一系列的操作就是C语言的文件操作，对应的就需要使用一些相关操作函数。简单来说，文件操作能够将输入的通讯录的数据存放在硬盘文件中，这样就做到了数据的持久化。\n\n\n\n\n\n\n\n\n\n所以使用文件，只有好处没有坏处。\n2. 什么是文件\n硬盘上的文件就是文件。\n而文件又分为程序文件和数据文件\n\n程序文件程序文件就是一段程序，包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。\n数据文件\n数据文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。\n本章讨论的是数据文件。\n在前面我们所学习所处理的数据的输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果显示到显示器上。\n其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使用，这里处理的就是磁盘上文件\n\n3. 文件的打开和关闭在理解前面的文件介绍后，这里我们开始学习C语言是如何进行文件操作的？\n要进行文件操作，当然要知道文件的打开和关闭，在这之前，我们要学习文件指针。\n\n缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。\n\n每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名FILE。\n 例如，VS2013编译环境提供的 stdio.h 头文件中有以下的文件类型申明：\n\n\nstruct _iobuf &#123;  &#x2F;&#x2F; 是一个结构体\n        &#x2F;&#x2F; 文件的各类信息\n        char *_ptr;\n        int   _cnt;\n        char *_base;\n        int   _flag;\n        int   _file;\n        int   _charbuf;\n        int   _bufsiz;\n        char *_tmpfname;\n       &#125;;\ntypedef struct _iobuf FILE; &#x2F;&#x2F; 取名FILE\n\n\n\n不同的C编译器的FILE类型包含的内容不完全相同，但是大同小异。\n\n每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息，我们使用者不必关心细节。\n\n一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。例如，这里创建一个FILE*的指针变量：\n\n\nFILE* pf;&#x2F;&#x2F;文件指针变量\n\n\n定义pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能够访问该文件。也就是说通过文件指针变量能够找到与它关联的文件。\n如下图：\n\n有了上面的文件指针相关概念的认知后，接下来就可以进行文件的打开和关闭了\n\n文件的打开和关闭\n\n文件在读写之前应该先打开文件，在使用结束之后应该关闭文件。\n在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。\nANSIC 规定使用fopen函数来打开文件，fclose来关闭文件。\n\n\nfopen：\n\n\n如果打开文件失败，返回一个NULL；\n\nfclose：\n\nint fclose ( FILE * stream );\n&#x2F;&#x2F; 可以直接这样关闭\nfclose(pf);  &#x2F;&#x2F; pf 是一个 FILE* 的指针变量，他此时指向一个文件，这里将他关闭\n&#x2F;&#x2F; 最后这里最好将这个pf指针置空\npf &#x3D; NULL;\n这两个函数的头文件都是&lt;stdio.h&gt;。\n文件的打开方式有很多，如下图：\n\n当然，这么多方式，我们只要着重熟练使用前5个就Ok了。\n说了这么多，下面实例操作一下：\n假设不自己创建文件以读的方式打开文件：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 这里读文件，如果此时当前目录下没有这个文件，fopen返回一个空指针\n\t&#x2F;&#x2F; 假设此时没有这个文件\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;r&quot;);\t\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\t&#x2F;&#x2F; 没有打开成功\n\t\t&#x2F;&#x2F; 打印错误信息\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F; 打开成功后\n\t\t&#x2F;&#x2F; ......\n\t\t&#x2F;&#x2F; 一系列文件操作\n\n\t\t&#x2F;&#x2F; 关闭文件\n\t\tfclose(pf);  &#x2F;&#x2F; 传递指向文件的指针\n\t\tpf &#x3D; NULL;\n\t&#125;\n\n\treturn 0;\n&#125;\n可以看到，报错信息很明显：没有这个文件，说明读需要文件已经存在，这也就对应了上面文件打开方式图的内容，如果此时以写（w）的方式打开？根据上面的内容，他会自动创建一个文件。\n打开文件代码改为：\nFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;w&quot;);\n此时程序运行，终端什么都没有，但是在当前文件多出了一个文件，正是fopen里的那个test.txt文件：\n\n所以，以何种形式打开文件，其效果是不一样的，这也给了我们更多的选择。\n4. 文件的顺序读写文件的顺序读写当然需要一批函数来帮助我们操作，下面是一系列这样有这样功能的函数，接下来一一介绍和使用：\n\nfgetc\n\n\n\n\n\n\n\n\nfgetc是从文件中读取一个字符的函数\n下面是函数参数原型：\n\n话不多说，先在当前文件创建一个test.txt,并在里面输入abcdef，然后进行fgetc的文件操作：\n#include &lt;stdio.h&gt;  &#x2F;&#x2F; 对应函数头文件\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; fgetc 相当于从文件中读取字符，所以这里要以r的形式打开文件\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;r&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开成功\n\t&#x2F;&#x2F; 开始读取字符\n\tint ch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到字符的ASCLL码值\n\tprintf(&quot;%c\\n&quot;, ch);\n\tch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到下一个字符的ASCLL码值，函数会自动往下找\n\tprintf(&quot;%c\\n&quot;, ch);\n\tch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到下一个字符的ASCLL码值，函数会自动往下找\n\tprintf(&quot;%c\\n&quot;, ch);\n\tch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到下一个字符的ASCLL码值，函数会自动往下找\n\tprintf(&quot;%c\\n&quot;, ch);\n\tch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到下一个字符的ASCLL码值，函数会自动往下找\n\tprintf(&quot;%c\\n&quot;, ch);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n当然我们也可以不必这么麻烦，直接写个循环瞬间将文件里的字符弄出来打印。\nfputc\n\n\n\n\n\n\n\n\nfputc是将字符写入文件当中，既然是写入，回顾写（w）的特点，如果文件不存在，自动创建一个文件，如果文件存在，则覆盖那个已经存在的文件。\n这里不创建文件，直接使用（当前文件里没有test.txt文件）：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; fputc 将字符写入文件，所以这里用w\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;w&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 开始写入\n\tfor (char ch &#x3D; &#39;a&#39;; ch &lt;&#x3D; &#39;z&#39;; ++ch)\n\t&#123;\n\t\t&#x2F;&#x2F; 循环写入a-z 26 个字母\n\t\tfputc(ch, pf);\n\t&#125;\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n我们打开test.txt文件观察是否写入：\n\n可以看到，的确将26个字母写入文件。\nfgets\n\n\n\n\n\n\n\n\nfgets与fgetc很相似，只有s和c的差别，但fgets是从文件里得到一行字符(一读就读一行)，也就是一行字符串，而fgetc只是得到一个字符，这功能上的差别还是很大的。\n下面就以在上面由fputc写好的文件test.txt来作为fgets使用的文件对象来展示fgets的使用效果：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t                &#x2F;&#x2F; 得字符串 用 &#39;r&#39;\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;r&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 开始从文件读字符串\n\tchar buf[100];\n\t&#x2F;&#x2F; 从pf中读取十个，用buf指向这一字符串\n\tfgets(buf, 10, pf);\n\tprintf(&quot;%s\\n&quot;, buf);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n\nfputs\n\n\n\n\n\n\n\n\n理解了fgets函数后，该函数得功能也就很清楚了：将字符串输入到文件中\n该函数的使用：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 输入字符串到文件中 用        &#39;w&#39;\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;w&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 输入字符串到文件中\n\tchar s[] &#x3D; &quot;I love you!&quot;;\n\tfputs(s, pf);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n\nfprintf\n\n\n\n\n\n\n\n\n该函数是以格式化的形式向文件输入数据。\nfprintf纯概念有些难理解，使用起来其实没那么难：\n#include &lt;stdio.h&gt; &#x2F;&#x2F; 对应头文件\n#include &lt;stdlib.h&gt;\n\nstruct S\n&#123;\n\tchar s[20];\n\tint a;\n\tfloat b;\n&#125;;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 结构体成员数据\n\tstruct S s &#x3D; &#123; &quot;zhangsan&quot;, 520, 13.14 &#125;;\n\n\t&#x2F;&#x2F; 输入数据到文件中 用          &#39;w&#39;\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;w&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 输入数据到文件中\n\tfprintf(pf, &quot;%s %d %f&quot;, s.s, s.a, s.b);\n\t&#x2F;&#x2F; printf(&quot;%s %d %f&quot;, s.s, s.a, s.b);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n\nfscanf\n\n\n\n\n\n\n\n\n有了fprintf的理解，fscanf也很容易明白了，scanf是从键盘输入到内存当中，而fscanf则是从文件当中读取数据输入到内存当中。\n我们将上面fprintf输入到文件test.txt的数据在读取出来放入一个结构体当中：\n#include &lt;stdio.h&gt; &#x2F;&#x2F; 对应头文件\n#include &lt;stdlib.h&gt;\n\nstruct S\n&#123;\n\tchar s[20];\n\tint a;\n\tfloat b;\n&#125;;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 结构体成员数据\n\tstruct S s &#x3D; &#123; 0 &#125;;\n\n\t&#x2F;&#x2F; 输入数据到文件中 用          &#39;r&#39;\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;r&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 从文件中读取数据\n\tfscanf(pf, &quot;%s %d %f&quot;, s.s, &amp;s.a, &amp;s.b);\n\t&#x2F;&#x2F; 打印结果\n\tprintf(&quot;%s %d %f\\n&quot;, s.s, s.a, s.b);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n\n可以看到，fscanf的确把文件中的数据放到了结构体变量s中。\n流的介绍任何一个C语言程序运行的时候，默认打开三个流：\n\nstdin - 标准输入流（键盘）类型：FILE*\nstdout - 标准输出流（屏幕）类型：FILE*\nstderr - 标准错误流（屏幕）类型：FILE*\n\n以上的函数不但适用于文件，还是用于这三个流，上面的函数图后面一条就表示了，这些函数适用于所有流。\n例如：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint ch &#x3D; fgetc(stdin);  &#x2F;&#x2F; 从键盘输入\n\tfputc(ch, stdout); &#x2F;&#x2F; 在屏幕上输出\n\n\treturn 0;\n&#125;\n\n\n当然，以上的函数都可以进行相关的操作，流就是用来输入输出的。\nfwrite\n\n\n\n\n\n\n\n\n该函数与上面的函数不同，他是以二进制的方式将数据写入文件，也就是当我们打开写入数据的文件时会发现里面都是一些二进制乱码，完全看不懂。\n既然是二进制写入，那fopen哪里就要写成wb（表示以二进制写入）。\n使用如下：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; fwrite写，二进制形式的写“wb”     \n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;wb&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开成功\n\tint arr[] &#x3D; &#123; 1,2,3,4,5,6 &#125;;\n\n\t&#x2F;&#x2F; 从arr处写入   写入的大小为整个数组的大小   写入1个   写到pf指向的文件当中\n\tfor (int i &#x3D; 0; i &lt; 6; i++)\n\t&#123;\n\t    &#x2F;&#x2F; 循环将arr中的每一个元素写入文件\n\t\tfwrite(arr + i, sizeof(int), 1, pf);\n\t&#125;\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n\n可以看到，文件test.txt里面是一些乱东西。\nfread\n\n\n\n\n\n\n\n\n该函数是进行二进制数据文件的读取的，跟fwrite函数一个读一个写，下面是其函数原型：\n就将fwrite写进test.txt的二进制乱码读取出来看是不是开始的arr数组数据：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; fread写，二进制形式的读取“wb”     \n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;rb&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开成功\n\tint arr[20];\n\n\t&#x2F;&#x2F; 将文件的数据写入arr   一个整型一个整型的写入   写入1个   从pf指向的文件中读取\n\tfor (int i &#x3D; 0; i &lt; 6; i++)\n\t&#123;\n\t\tfread(arr + i, sizeof(int), 1, pf);\n\t&#125;\n\n\t&#x2F;&#x2F;  打印\n\tfor (int i &#x3D; 0; i &lt; 6; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n\n\n5. 文本文件和二进制文件\n根据数据的组织形式，数据文件被称为文本文件或者二进制文件。\n\n数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。\n\n如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。\n\n一个数据在内存中是怎么存储的呢？字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。 \n\n当以二进制形式存储，文件里是一系列的二进制乱码；\n当以ASCLL形式储存，则是以字符形式表达其面值。\n\n\n\n6. 文件读取结束的判定\n有两个函数可以用作文件读取结束的判定\nfeof\nferror \n\n\n\n被错误使用的feof\n牢记：在文件读取过程中，不能用feof函数的返回值直接用来判断文件的是否结束。而是应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束。\n\n\n文本文件读取是否结束，判断返回值是否为 EOF （ fgetc ），或者 NULL （ fgets ）例如：fgetc 判断是否为EOF.fgets 判断返回值是否为 NULL .\n二进制文件的读取结束判断，判断返回值是否小于实际要读的个数。例如：fread判断返回值是否小于实际要读的个数。\n\n7. 文件缓冲区\nANSIC 标准采用“缓冲文件系统”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。\n\n\n写在最后\n\n\n\n\n\n\n\n\n文件操作实际上是不常用的，大部分公司都有其内部的文件管理系统，所以，对文件操作的困惑不要停留太久。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"关于C语言对文件的操作","date":"2023-02-18T06:38:53.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"c624797c7b313fdd30471a2503f8d11d","title":"C语言一个特殊的数组【柔性数组】","content":"前言\n\n\n\n\n\n\n\n\n\n也许你从来就没有听过柔性数组（flexible array）这个概念，但他是真的存在；\n柔性数组的概念存在于C99标准当中，C99标准表示：结构体的最后一个成员可以是一个大小不确定的数组，这个数组就叫做柔性数组;\n既然搭配了柔性这一修饰词，那么这个数组就不会是”耿直“的了。\n\n柔性数组的特点\n柔性数组的大小是不确定的；\n他是存在于结构体当中，并且只能放在结构体的最后一个成员位置；\n柔性数组所在位置的前面至少要有一个成员；\n当柔性数组存在于一个结构体当中时，计算结构体的大小，不将柔性数组算在内；\n柔性数组是未知大小的数组，要使用他，必须要用malloc来为他开辟空间，并且这个空间的大小一定要大于所在结构体的大小，简单来说，这个开辟的空间的大小减去所在的结构体大小剩下的空间就是这个柔性数组可以使用的了。\n\n柔性数组的定义：\n1.\nstruct s\n&#123;\n\tchar a;\n\tint a[];  &#x2F;&#x2F; [] 里不放数据\n&#125;;\n&#x2F;&#x2F; 当然也可以\n2.\nstruct s\n&#123;\n\tint a;\n\tchar b[0]; &#x2F;&#x2F; 上面的定义在有些编译器上可能会报错，这样也是可以的\n&#125;;\n\n上述1中的int a[],2中的char b[0],就是所谓的柔性数组。\n柔性数组的大小是不确定，下面来测试一下结构体的大小：\n#include &lt;stdio.h&gt;\n&#x2F;&#x2F;1.\nstruct s1\n&#123;\n\tchar a;\n\tchar b;\n\tint c;\n\tint d[];  &#x2F;&#x2F; [] 里不放数据\n&#125;;\n&#x2F;&#x2F; 当然也可以\n&#x2F;&#x2F;2.\nstruct s2\n&#123;\n\tint a;\n\tint b;\n\tint c;\n\tchar d[0]; &#x2F;&#x2F; 上面的定义在有些编译器上可能会报错，这样也是可以的\n&#125;;\n\nint main()\n&#123;\n\tprintf(&quot;%d\\n&quot;, (int)sizeof(struct s1));\n\tprintf(&quot;%d\\n&quot;, (int)sizeof(struct s2));\n\n\treturn 0;\n&#125;\n运行结果：\n如果我们不看最后一个柔性数组成员，计算出来的结构体大小恰好是上面的结果，所以，当结构体里面含有柔性数组成员的时候，计算结构体大小时，是不会将柔性数组的大小计算在内的。\n柔性数组的使用有了上面对柔性数组的认识，那么柔性数组是如何使用的呢？\n 上面说了要用malloc来为此开辟空间，并且开辟的空间的大小要大于所在结构体的大小。\n例子：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct s\n&#123;\n\tchar a;\n\tint b[]; &#x2F;&#x2F; 柔性数组\n&#125;* s; &#x2F;&#x2F; 创建结构体指针变量\n\nint main()\n&#123;                                 &#x2F;&#x2F; 这里是结构体的空间 &#x2F;&#x2F;这是柔性数组的空间：十个整型\n\tstruct s* tmp &#x3D; (struct s*)malloc(sizeof(struct s) + 40);\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;malloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\ts &#x3D; tmp;\n\t\n\t&#x2F;&#x2F; 给柔性数组赋值\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\ts-&gt;b[i] &#x3D; i + 1;\n\t&#125;\n\n\t&#x2F;&#x2F; 打印柔性数组的内容\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, s-&gt;b[i]);\n\t&#125;\n\n\t&#x2F;&#x2F; 记得释放空间\n\tfree(s);\n\n\treturn 0;\n&#125;\n\n运行结果：\n\n当然，如果需要给柔性数组扩容，可以用realloc进行以下操作(核心代码)：\n                                          &#x2F;&#x2F; 将柔性数组的空间增大到可以存储15个整型\nstruct s* cur &#x3D; (struct s*)realloc(s, sizeof(struct s) + 60);\nif (cur &#x3D;&#x3D; NULL)\n&#123;\n\tperror(&quot;realloc fail&quot;);\n\texit(-1);\n&#125;\ns &#x3D; cur;\n\n&#x2F;&#x2F; 给扩容的空间赋值\nfor (int i &#x3D; 10; i &lt; 15; ++i)\n&#123;\n\ts-&gt;b[i] &#x3D; i + 1;\n&#125;\n\n&#x2F;&#x2F; 打印柔性数组扩容后的内容\nfor (int i &#x3D; 0; i &lt; 15; i++)\n&#123;\n\tprintf(&quot;%d &quot;, s-&gt;b[i]);\n&#125;\n\n运行结果：\n\n据此，柔性数组的使用掌握这些已经够用了，可以看到，柔性数组是可以随意更改数组大小的，“柔性”体现的淋漓尽致，不过一定要注意内存泄漏的问题。\n柔性数组的优势学会了柔性数组的使用，实际上，上面实现的柔性数组的功能还可以这样设计：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct s\n&#123;\n\tchar b;\n\tint* a;\n&#125;s; &#x2F;&#x2F; typedef 重命名\n\nint main()\n&#123;\n\ts* stru;  &#x2F;&#x2F; 指向类型为s的结构体指针\n\ts* tmp1 &#x3D; (s*)malloc(sizeof(s));\n\tif (tmp1 &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;malloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\tstru &#x3D; tmp1;  &#x2F;&#x2F; 将开辟的结构体空间给给stru\n\tstru-&gt;b &#x3D; &#39;a&#39;;\n\t                &#x2F;&#x2F; 开辟可以存放十个整型的空间\n\tint* tmp2 &#x3D; (int*)malloc(sizeof(int) * 10);\n\tif (tmp2 &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;malloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\tstru-&gt;a &#x3D; tmp2; &#x2F;&#x2F; 将开辟的可以存放十个整型的空间给给stru指向的结构体里的整型指针\n\n\t&#x2F;&#x2F; 给a指向的空间赋值\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tstru-&gt;a[i] &#x3D; i + 1;\n\t&#125;\n\n\t&#x2F;&#x2F; 打印a指向的空间里的内容\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, stru-&gt;a[i]);\n\t&#125;\n\n\t&#x2F;&#x2F; 别忘记释放噢,这里开辟了两次就要释放两次，并且要有里到外依次释放\n\tfree(stru-&gt;a);\n\tstru-&gt;a &#x3D; NULL;\n\tfree(stru);\n\tstru &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n柔性数组的使用那个设计放法与这个设计方法实现的效果是一样的，但是柔性数组的那个设计有两个好处：\n\n方便内存释放：可以看到第二个设计释放了两次，如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。\n这样有利于访问速度：连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，也没有高多少，反正你跑不了要用做偏移量的加法来寻址）\n\n写在最后\n\n\n\n\n\n\n\n\n多学一些知识，在以后能用来解决问题的方法就更多，看完本篇文章，希望你能够理解柔性数组并且可以很好的使用。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"C语言一个特殊的数组【柔性数组】","date":"2023-02-18T06:29:28.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"81fc7805ca264e2858b2ea302671831d","title":"关于C语言atoi函数的解析使用与自我实现","content":"前言\n\n\n\n\n\n\n\n\n\n对于atoi函数大家可能会有些陌生，不过当你选择并阅读到这里时，请往下阅读，我相信你能对atoi函数熟悉\n该函数的头文件为 &lt;stdlib.h&gt; 或      &lt;cstdlib&gt;\n\natoi函数的介绍此函数的功能是将数字字符的字符串转化为字面上的整型返回，例如：\nchar arr[] &#x3D; &quot;1234&quot;;\n将”1234“ -&gt; 1234(int)\n\n以下是函数原型：\n\n要注意的点：\n\n如果字符串从开头就有连续的空格字符，则跳过这些连续的空格字符，找到不是空格的字符。  \n如果跳过这些空格字符后的第一个字符不是数字字符，则直接返回0；\n如果跳过这些空格字符后的第一个字符是数字字符，则从这个数字字符开始转换，并向后找连续的数字字符转换 ,如果连续中断，找到不是数字字符的字符，则在此截断寻找，返回前面已经转换好的连续的数字字符字面整型值。(这里截断向后寻找后，不管后面有没有数字字符函数都不管)\n\n\n\n\n\n如果字符串首元素不是空格字符\n如果第一个字符不是数字字符，直接返回0。\n如果第一个字符是数字字符， 则从这个数字字符开始转换，并向后找连续的数字字符转换 ,如果连续中断，找到不是数字字符的字符，则在此截断寻找，返回前面已经转换好的连续的数字字符字面整型值。\n\n\n\n\n\n如果字符串全部为空格字符，返回0；如果为空字符串，返回0；\n\natoi函数的使用\n有了上面的介绍，使用的意图变得明显，使用起来也就随手就来了。\n\n例如：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\tchar a[] &#x3D; &quot;&quot;;\n\tchar b[] &#x3D; &quot;     &quot;;\n\tchar c[] &#x3D; &quot;66666&quot;;\n\tchar d[] &#x3D; &quot;    @. 66ab&quot;;\n\tchar e[] &#x3D; &quot;    6666@qq.com&quot;;\n\tchar f[] &#x3D; &quot;520hehe&quot;;\n\tchar g[] &#x3D; &quot;i love you 555&quot;;\n\n\tprintf(&quot;%d\\n&quot;, atoi(a));\n\tprintf(&quot;%d\\n&quot;, atoi(b));\n\tprintf(&quot;%d\\n&quot;, atoi(c));\n\tprintf(&quot;%d\\n&quot;, atoi(d));\n\tprintf(&quot;%d\\n&quot;, atoi(e));\n\tprintf(&quot;%d\\n&quot;, atoi(f));\n\tprintf(&quot;%d\\n&quot;, atoi(g));\n\n\treturn 0;\n&#125;\n\n\n\n看上的结果，是不是就与介绍当中的点都对应起来了呢？\natoi函数的自我实现有了上面的铺垫，我们已经了解了该函数的特性，所以接下来的实现也就变的简单了\n\n跳过空格字符（也可能没有，就不跳直接开始判断转换）；\n跳过后开始判断转换；\n无论何种方式开始判断第一个字符，如果不是数字字符，直接返回0。\n\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\n&#x2F;&#x2F; 数字ASCLL码值范围为 48—57\n\nint my_atoi(const char* str)\n&#123;\n\tassert(str);\n\n\tconst char* tmp &#x3D; str;\n\twhile (*tmp &#x3D;&#x3D; &#39; &#39;)  &#x2F;&#x2F; 跳过空格字符\n\t\ttmp++;\n\t\n\tint num &#x3D; 0; &#x2F;&#x2F; 转换数字字符值的接收变量\n\n\t&#x2F;&#x2F; 如果是数字字符，就进来，到不连续处就停止\n\twhile (*tmp &lt;&#x3D; 57 &amp;&amp; *tmp &gt;&#x3D; 48)  \n\t&#123;\n\t\tnum &#x3D; num * 10 + (*tmp - &#39;0&#39;);\n\n\t\tif (*(tmp + 1) &lt; 48 || *(tmp + 1) &gt; 57)\n\t\t&#123;\n\t\t\treturn num;\n\t\t&#125;\n\n\t\ttmp++;\n\t&#125;\n\n\t&#x2F;&#x2F; 如果开始判断的字符不是数字字符，前面的循环不进去，这里直接返回0\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\tchar a[] &#x3D; &quot;&quot;;\n\tchar b[] &#x3D; &quot;     &quot;;\n\tchar c[] &#x3D; &quot;66666&quot;;\n\tchar d[] &#x3D; &quot;    @. 66ab&quot;;\n\tchar e[] &#x3D; &quot;    6666@qq.com&quot;;\n\tchar f[] &#x3D; &quot;520hehe&quot;;\n\tchar g[] &#x3D; &quot;i love you 555&quot;;\n\n\tprintf(&quot;%d\\n&quot;, my_atoi(a)); &#x2F;&#x2F; 0\n\tprintf(&quot;%d\\n&quot;, my_atoi(b)); &#x2F;&#x2F; 0\n\tprintf(&quot;%d\\n&quot;, my_atoi(c)); &#x2F;&#x2F; 66666\n\tprintf(&quot;%d\\n&quot;, my_atoi(d)); &#x2F;&#x2F; 0\n\tprintf(&quot;%d\\n&quot;, my_atoi(e)); &#x2F;&#x2F; 6666\n\tprintf(&quot;%d\\n&quot;, my_atoi(f)); &#x2F;&#x2F; 520\n\tprintf(&quot;%d\\n&quot;, my_atoi(g)); &#x2F;&#x2F; 0\n\n\treturn 0;\n&#125;\n\n\n写在最后\n\n\n\n\n\n\n\n\n相信你已经对这个函数了如指掌了，认识掌握的函数越多，当然是没有坏处只有好处的。经过对atoi函数的学习，我相信你也会感觉到这个函数有好处也有缺陷，不过得用且用吧，在用的时候一定要脑子清醒，不要到头来骂这个函数，哈哈哈哈。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"关于C语言atoi函数的解析使用与自我实现","date":"2023-02-18T06:24:52.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"77f0175d7a55a3daaea7f2a65478b692","title":"关于C语言自定义类型的解析【联合体(共用体)】","content":"前言\n\n\n\n\n\n\n\n\n联合体（union）在C语言中是不常用的，不过存在就必然有其有用之处，这里不深入探讨联合体用在何处有什么用，本文章只介绍关于union的基本知识。\n联合体(UNION)类型的定义\n\n\n\n\n\n\n\n\n联合体也是一种特殊的自定义类型, 这种类型定义的变量也包含一系列的成员，特征是这些成员共用同一块空间（所以联合体也叫共用体）。\n例如：\n&#x2F;&#x2F;联合体类型的声明\nunion Un   &#x2F;&#x2F; union Un 为联合体类型\n&#123;\n     &#x2F;&#x2F; 公用空间的成员\n\t char c;    \n\t int i;\n&#125;;\n\nunion Un\n&#123;\n\tchar a[5];\n\tint b;\n&#125;;  &#x2F;&#x2F; 注意要有分号\n\n\n\n\n联合体的特点\n\n\n\n\n\n\n\n\n联合体的成员是共用同一块内存空间的，这样一个联合体变量的大小，至少是最大成员的大小（因为联合体至少得有能力保存最大的那个成员）。\n例如这里分别打印i和c的地址，会发现他们的地址相同，这是因为他们公用同一块空间的地址：\n#include &lt;stdio.h&gt;\n\nunion Un\n&#123;\n\tint i;\n\tchar c;\n&#125;;\n\nunion Un un;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 下面输出的结果是一样的吗？\n\n\tprintf(&quot;%p\\n&quot;, &amp;(un.i));\n\tprintf(&quot;%p\\n&quot;, &amp;(un.c));\n\n\treturn 0;\n&#125;\n运行结果：\n可以看到，他们两个的地址是相同的。\n这是因为：\n\n联合体大小的计算\n\n\n\n\n\n\n\n\n\n联合的大小至少是最大成员的大小。\n当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。\n假设这里默认对齐数为8。\n\n例如：\n#include &lt;stdio.h&gt;\n\nunion Un1\n&#123;\n\tchar c[5];\n\tint i;\n&#125;;\nunion Un2\n&#123;\n\tshort c[7];\n\tint i;\n&#125;;\n\nint main()\n&#123;\n\t&#x2F;&#x2F;下面输出的结果是什么？\n\tprintf(&quot;%d\\n&quot;, (int)sizeof(union Un1));\n\tprintf(&quot;%d\\n&quot;, (int)sizeof(union Un2));\n\n\treturn 0;\n&#125;\n\n\n联合体使用的典型例题 — 判断机器的大小端\n\n\n\n\n\n\n\n\n在我之前的这篇http://t.csdn.cn/AKnbz博客中,已经介绍了大小端是什么，这里着重写联合体是怎么判断大小端的。\n直接看代码实现：\n#include &lt;stdio.h&gt;\n\nunion Un\n&#123;\n\tchar a;\n\tint b;\n&#125;;\n\n&#x2F;&#x2F;int sys_check();\n\nint main()\n&#123;\n\tunion Un u;\n\tu.b &#x3D; 1;\n\n\tif (u.a &#x3D;&#x3D; 1)\n\t&#123;\n\t\tprintf(&quot;小端\\n&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;大端\\n&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n运行结果：\n\n可以看到，运用联合体判断出来vs是小端存储模式\n调试后观察内存：\n可以看到，的确为小端存储模式。\n写在最后\n\n\n\n\n\n\n\n\n\n能够熟练掌握联合体，说不定，在以后的某个时间就用上了呢。\n到这里，C语言自定义类型的介绍结束了，一共有三大块：结构体类型，枚举类型，联合体类型。\n以下是我写的结构体和枚举的博客链接，欢迎阅读噢：结构体：http://t.csdn.cn/IRpyh枚举：http://t.csdn.cn/aeh10\n\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"关于C语言自定义类型的解析【联合体-共用体-】","date":"2023-02-18T06:10:00.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"2a6f3763c677ea77f93b81ce5ed42b63","title":"关于C语言自定义类型的解析【枚举】","content":"前言\n\n\n\n\n\n\n\n\n枚举在我们平时练习或学习的时候可能不是很常用，但是其在工程项目里，还是比较常见的，因为他能起到优化用。并且，有时我们在写题的时候，也会运用到枚举的思想。\n枚举的介绍\n\n\n\n\n\n\n\n\n枚举顾名思义就是 一 一 列举。把可能的取值 一 一 列举。\n比如我们现实生活中：1.一个星期从星期一到星期天的有限的7天可以 一 一 列举。2.月份从1月到12月也可以 一 一 列举出来。3.颜色分红黄蓝绿蓝靛紫几种颜色，也可以 一 一 列举出来。\n枚举类型的定义直接上代码（注意观察语法形式）：\n&#x2F;&#x2F; enum var_name  这个就是枚举类型\nenum Sex  &#x2F;&#x2F; 枚举性别\n&#123;\n\tMAN, &#x2F;&#x2F; 男人   \n\tWOMAN  &#x2F;&#x2F; 女人\n\t&#x2F;&#x2F; 当然也有可能是人妖\n&#125;;\n\nenum Day  &#x2F;&#x2F; 枚举星期\n&#123;\t\n\tMon,  &#x2F;&#x2F; 注意这里是逗号\n\tTues,\n\tWed,\n\tThur,\n\tFri,\n\tSat,\n\tSun  &#x2F;&#x2F; 最后一个后面什么符号也不用打\n&#125;;  &#x2F;&#x2F; 这里必须要有分号\n\nenum Color\n&#123;\n\tRED,\n\tGREEN,\n\tBLUE\n&#125;;\n\n当然，既然是类型，那么也可以使用typedef起别名：\ntypedef enum Color\n&#123;\n\tRED,\n\tGREEN,\n\tBLUE\n&#125;Clr;  &#x2F;&#x2F; 将 enum Color 类型名 简化成 Clr\n\n\n1.以上定义的enum Day，enum Sex，enum Color都是枚举类型。\n2.&#123;&#125;中的内容是枚举类型的可能取值，也叫枚举常量。\n3.这些可能取值都是有值的，默认从0开始，依次递增1,例如：上面的RED可以看作0，GREEN可以看作1，BLUE可以看作2。\n4.当然在定义的时候也可以赋初值。例如：\nenum Color&#x2F;&#x2F;颜色\n&#123;\n\tRED &#x3D; 1,\n\tGREEN &#x3D; 2,\n\tBLUE &#x3D; 4\n&#125;;\n而如果是这样赋值：\nenum Day  &#x2F;&#x2F; 枚举星期\n&#123;\t\n\tMon, \n\tTues,\n\tWed,\n\tThur &#x3D; 10,\n\tFri,\n\tSat,\n\tSun  \n&#125;;\n\n那也就意味着从Mon到Wed是由0开始依次递增（Mon = 0， Tuse = 1， Wed = 2），从Thur到Sun是由10开始依次递增（Thur = 10， Fri = 11， Sat = 12， Sun = 13）。\n\n枚举的优点\n为什么使用枚举? \n我们可以使用 #define 定义常量，为什么非要使用枚举？\n\n原因：\n\n增加代码的可读性和可维护性。\n和#define定义的标识符比较枚举有类型检查，更加严谨。\n防止了命名污染（封装）。\n便于调试。\n使用方便，一次可以定义多个常量。\n\n\n我们可以去看很多项目的源码，会发现，里面很多用枚举来定义常量。\n\n枚举的使用enum Color&#x2F;&#x2F;颜色\n&#123;\n\t RED &#x3D; 1,\n\t GREEN &#x3D; 2,\n\t BLUE &#x3D; 4\n&#125;;\n\n&#x2F;&#x2F; 只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。\nenum Color clr &#x3D; GREEN;\n\nclr &#x3D; 5;\n\n写在最后\n\n\n\n\n\n\n\n\n虽然在现在阶段我们很难体会到枚举的好处，但是我们可以多去看看别人的代码，多去领悟一下枚举到底有什么用？这样我们使用起来也才会得心应手。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"关于C语言自定义类型的解析【枚举】","date":"2023-02-18T06:03:06.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"4134eec542bd62238a7d449186ff9c26","title":"关于C语言自定义类型的解析【结构体】","content":"前言\n\n\n\n\n\n\n\n\nC语言中结构体是一种用户自定义的数据类型，它相当于一个小型的数据结构，当我们在学数据结构阶段的时候，结构体的运用很常见，所以，基本的结构体的定义和使用，以及结构体大小的计算务必掌握。\n结构体类型的声明\n结构体的基础知识：\n\n\n\n\n\n\n\n\n\n结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。\n\n声明的语法结构：\n\n\nstruct tag &#x2F;&#x2F; 结构体类型名\n&#123;\n member-list; &#x2F;&#x2F; 结构体成员\n&#125;variable-list; &#x2F;&#x2F; 这里是可以直接在这里输入变量名，相当于创建了一个全局的结构体变量\n例如定义一个学生变量（名字，年龄，学号）：\nstruct stu \n&#123;\n\tchar Name[20];  &#x2F;&#x2F; 名字以字符串的形式存储\n\tint Age;\n\tchar StuNum[20];  &#x2F;&#x2F; 学号也以字符串的形式存储，因为可能学号很长，整型存储不下\n&#125;;  &#x2F;&#x2F; 分号必不可少\n\n特殊的声明(结构体不完全声明):匿名结构体声明：\n\nstruct    &#x2F;&#x2F; 省略了tag\n&#123;\n    int a;\n    char b;\n&#125;x; &#x2F;&#x2F; 匿名结构体全局变量x\n\nstruct    &#x2F;&#x2F; 省略了tag\n&#123;\n    int a;\n    char b;\n&#125;y;  &#x2F;&#x2F; 匿名结构体全局变量y\n\n如果有这样一种操作：\ny &#x3D; &amp;x;\n\n\n这样合法么？当然是不行的，编译器会将这两个结构体变量当作是两个完全不同的两个类型，所以是非法的。\n\n结构的自引用\n\n\n\n\n\n\n\n\n如果在一个结构体成员当中包含本身，这样是否可行呢？\n\n假如这样写：\nstruct node\n&#123;\n\tint a;\n\tstruct node next;   &#x2F;&#x2F; 这样是否可行能？？？？？\n&#125;;\n上面这种写法，很容易看出问题，会形成一个死循环。\n\n另外一种写法：\n\n\nstruct node\n&#123;\n\tint a;\n\tstruct node* next;  &#x2F;&#x2F; 一个结构体指针\n&#125;;\n\n\n\n\n\n\n\n\n\n如果是这样写，next是一个指针，因此不会死循环，并且，next还是一个结构体指针，也就是说，next可以指向下一个自身类型的结构体（指向本身类型的结构体变量）。\n例如：\nstruct node s1, s2;\ns1.next &#x3D; &amp;s2;\n\n\n所以这种写法是可以的。\n\n我们再来看这一种写法：\n\ntypedef struct node\n&#123;\n    int a;\n    node* next;   \n&#125;node; \n这样的写法是不行的，因为遵循从上到下的原则，typedef结构体为node，其名在定义next之后，所以不行。\n修正后：\ntypedef struct node\n&#123;\n    int a;\n    struct node* next;   \n&#125;node;\n\nnode s1; \n\n结构体变量的定义和初始化定义#include &lt;stdio.h&gt;\n\nstruct rand\n&#123;\n\tint x;\n\tint y;\n&#125;p1;  &#x2F;&#x2F;声明类型的同时定义全局结构体变量p1\n\nstruct rand p2;  &#x2F;&#x2F;定义全局结构体变量p2\n\nint main()\n&#123;\n\tstruct rand p3;  &#x2F;&#x2F; 定义局部结构体变量p3\n\n\treturn 0;\n&#125;\n\n\n结构体嵌套：\n\nstruct tmp\n&#123;\n\tchar a;\n\tint b;\n&#125;;\n\nstruct rand\n&#123;\n\tint x;\n\tint y;\n\tstruct tmp z;  &#x2F;&#x2F; z为struct tmp类型，该类型有两个成员\n&#125;p1;  &#x2F;&#x2F;声明类型的同时定义全局结构体变量p1\n\nstruct rand p2;  &#x2F;&#x2F;定义全局结构体变量p2\n\nint main()\n&#123;\n\tstruct rand p3;  &#x2F;&#x2F; 定义局部结构体变量p3\n\n\treturn 0;\n&#125;\n\n初始化1.在main函数里初始化：\n#include &lt;stdio.h&gt;\n\nstruct rand\n&#123;\n\tint x;\n\tint y;\n&#125;p1;\n\nstruct rand p2;\n\nint main()\n&#123;\n\tp1.x &#x3D; 5, p1.y &#x3D; 2;\n\tp2.x &#x3D; 5, p2.y &#x3D; 2;\n\tstruct rand p3 &#x3D; &#123; 5,2 &#125;;\n\n\treturn 0;\n&#125;\n\n2.创建变量时初始化：\n#include &lt;stdio.h&gt;\n\nstruct rand\n&#123;\n\tint x;\n\tint y;\n&#125;p1 &#x3D; &#123; 5,2 &#125;; &#x2F;&#x2F; 在定义结构体的同时定义结构体变量p1，同时初始化p1\n\nstruct rand p2 &#x3D; &#123; 5,2 &#125;; &#x2F;&#x2F; main函数外\n\nint main()\n&#123;\n\tstruct rand p3 &#x3D; &#123; 5,2 &#125;;\n\n\treturn 0;\n&#125;\n\n3.结构体嵌套的初始化：\n\n\n\n\n\n\n#include &lt;stdio.h&gt;\n\nstruct tmp\n&#123;\n\tchar a;\n\tint b;\n&#125;;\n\nstruct rand\n&#123;\n\tint x;\n\tint y;\n\tstruct tmp z;\n&#125;p1;\n\nstruct rand p2;\n\nint main()\n&#123;\n\tp1.x &#x3D; 5;\n\tp1.y &#x3D; 2;\n\tp1.z.a &#x3D; &#39;i&#39;;\n\tp1.z.b &#x3D; 0;\n\n\tp2.x &#x3D; 5;\n\tp2.y &#x3D; 2;\n\tp2.z.a &#x3D; &#39;i&#39;;\n\tp2.z.b &#x3D; 0;\n\n\tstruct rand p3 &#x3D; &#123; 5,2,&#123;&#39;i&#39;, 0&#125; &#125;;\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n#include &lt;stdio.h&gt;\n\nstruct tmp\n&#123;\n\tchar a;\n\tint b;\n&#125;;\n\nstruct rand\n&#123;\n\tint x;\n\tint y;\n\tstruct tmp z;\n&#125;p1 &#x3D; &#123; 5,2,&#123;&#39;i&#39;, 0&#125; &#125;;\n\nstruct rand p2 &#x3D; &#123;5, 2,&#123;&#39;i&#39;, 0&#125; &#125;;\n\nint main()\n&#123;\n\tstruct rand p3 &#x3D; &#123; 5,2,&#123;&#39;i&#39;, 0&#125; &#125;;\n\n\treturn 0;\n&#125;\n\n结构体内存对齐\n\n\n\n\n\n\n\n\n\n我们已经掌握了结构体的基本使用了。\n现在我们深入讨论一个问题：计算结构体的大小。\n这也是一个特别热门的考点： 结构体内存对齐。\n\n我们先看下面一个例子：\n#include &lt;stdio.h&gt;\n\nstruct n1\n&#123;\n\tchar a1;\n\tint x1;\n\tchar b1;\n&#125;;\n\nstruct n2\n&#123;\n\tchar a2;\n\tchar b2;\n\tint x2;\n&#125;;\n\nint main()\n&#123;\n\tprintf(&quot;%d %d\\n&quot;, (int)sizeof(struct n1), (int)sizeof(struct n2));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：12  8\n为什么运行结果会不一样呢？？？？？？\n这就与结构体在内存中的存储形式有关，而结构体在内存中的存储结构方式又与结构体的内存对齐有关。\n那么什么是内存对齐呢？\n\n\n\n\n\n\n\n\n\n\n第一个成员在与结构体变量偏移量为0的地址处。\n其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。VS中默认的对齐数值为8\n结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。\n如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。\n\n以上面的例子分析一波：\n\n据此因为单个不同类型的成员的摆放位置不同，造成相同成员的两个结构体的大小不同，这是不是很奇妙呢？\n\n那么为什么要有内存对齐呢？？？\n\n大部分的参考资料都是如是说的：\n\n平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。\n性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。\n\n总体来说：结构体的内存对齐是拿空间来换取时间的做法。\n\n那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：\n\n\n\n\n\n\n\n\n\n\n就拿上面的那个例子来说，n1 和 n2，两个相同成员的结构体，一个大小为12，一个大小为8，那当然要选小的那个了，也就是n2。\n\n实际上我们可以在自己的编译器上修改默认对齐数\n\n\n\n\n\n\n\n\n\n\n我们可以通过 #pragma 来修改默认对齐数\n例如\n#include &lt;stdio.h&gt;\n\n#pragma pack(8)&#x2F;&#x2F;设置默认对齐数为8\nstruct n1\n&#123;\n    char c1;\n    int x;\n    char c2;\n&#125;;\n#pragma pack()&#x2F;&#x2F;取消设置的默认对齐数，还原为默认\n\n#pragma pack(1)&#x2F;&#x2F;设置默认对齐数为1\nstruct n2\n&#123;\n    char c1;\n    int x;\n    char c2;\n&#125;;\n#pragma pack()&#x2F;&#x2F;取消设置的默认对齐数，还原为默认\n\nint main()\n&#123;\n    &#x2F;&#x2F;输出的结果是什么？\n    printf(&quot;%d\\n&quot;, sizeof(struct n1));\n    printf(&quot;%d\\n&quot;, sizeof(struct n2));\n&#125;\n\n\n\n\n\n\n\n\n\n\n\nn1的默认对齐数修改为8，那也就跟之前一样，也就是12；\nn2的默认对齐数修改为1，也就相当于没有内存对齐一样，直接在下一个位置就存放，因此大小为6；\n\n\n\n\n\n\n\n\n\n\n如果结构体在对齐方式不合适的时候，那么我们可以自己更改默认对齐数。\n结构体传参对于下面的代码：\n#include &lt;stdio.h&gt;\n\nstruct S\n&#123;\n\tdouble data[10000];\n\tint num\n&#125;;\n\nstruct S s &#x3D; &#123; &#123;1.0,2.0,3.0,4.0&#125;, 1000 &#125;;\n\nvoid print1(struct S s) &#x2F;&#x2F; 结构体传参\n&#123;\n\tprintf(&quot;%d\\n&quot;, s.num);\n&#125;\n\nvoid print2(struct S* ps) &#x2F;&#x2F; 地址传递\n&#123;\n\tprintf(&quot;%d\\n&quot;, ps-&gt;num);\n&#125;\n\nint main()\n&#123;\n\tprint1(s); &#x2F;&#x2F; 传结构体\n\tprint2(&amp;s); &#x2F;&#x2F; 传结构体指针\n\n\treturn 0;\n&#125;\n是 print1 好还是 print2 好？\n答案是：首选print2函数。\n因为：     1.函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。      2.如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，       所以会导致性能的下降。\n所以：当结构体传参的时候，要传递结构体的地址；\n结构体实现位段什么是位段？\n\n\n\n\n\n\n\n\n位段的声明和结构是类似的，有两个不同：1.位段的成员必须是 int、unsigned int 或signed int 。2.位段的成员名后边有一个冒号和一个数字。\n例如：\nstruct rand\n&#123;\n    char _a:2; \n    char _b:5;\n    char _c:4;\n    char _d:6;\n &#x2F;&#x2F; 这里的  _  和  :  是位段定义的基本语法\n &#x2F;&#x2F; 这里的  2,5,4,6  是所占比特位的个数\n&#125;;\n\nrand就是一个位段类型，那位段rand的大小是多少？\n\n\n\n\n\n\n\n\n\nprintf(&quot;%d\\n&quot;, sizeof(struct rand));   vs运行结果为4\n位段的内存分配\n\n\n\n\n\n\n\n\n\n位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型\n位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。\n位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。\n\n#include &lt;stdio.h&gt;\n\ntypedef struct rand\n&#123;\n\tchar _a : 2;\n\tchar _b : 5;\n\tchar _c : 4;\n\tchar _d : 6;\n&#125;a;\n\nint main()\n&#123;\n\ta a &#x3D; &#123; 4,4,10,5 &#125;;\n\n\tprintf(&quot;%d\\n&quot;, (int)sizeof(a));  &#x2F;&#x2F; 3\n\n\treturn 0;\n&#125;\n\n\n当然int是以4字节开辟，存储方式与char差不多，按照上面方式去弄也是很容易自己弄出来的噢。\n位段的跨平台问题\nint 位段被当成有符号数还是无符号数是不确定的。\n位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。）\n位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。\n当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。\n\n所以：\n跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。\n位段的应用\n写在最后\n\n\n\n\n\n\n\n\n结构体的知识虽然较为简单，但其在数据结构当中的作用还是很重要的，因为一个数据它里面要有什么内容还是要结构体来整合。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"关于C语言自定义类型的解析【结构体】","date":"2023-02-18T04:17:55.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"19cad4ee9072e8ab86cabc2b83a8e850","title":"C语言常见字符串函数的解析和部分字符串函数的实现","content":"前言\n\n\n\n\n\n\n\n\n\n常见的字符串函数在一定程度上可以让我们在写代码，或者是在刷某些有关字符串的题目时事半功倍，并且常见字符串函数的功能非常常用，因此我们应该熟练使用这些字符串函数，以及部分函数要能自我实现。\n字符串函数都要引入一个库函数：string(#include &lt;string.h&gt;)\n\n1.长度不受限制的常见字符串函数strlen\n\n\n\n\n\n\n\n\nstrlen函数是求字符串长度的，遇到 \\0 停止（计算\\0之前有多少个字符），如果有多个\\0，则只计算第一个\\0前面的字符个数。\n\nstrlen的使用：#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%d\\n&quot;, strlen(arr));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n运行结果：6\narr有6个字符，所以所得为6，值得注意的是，strlen函数的返回值是 size_t(unsigned int),size_t表示无符号整型，但是这里我们用%d形式打印也是没有问题的。\n为什么strlen函数的返回值要弄size_t 呢？因为长度是没有负数之说的，所以size_t符合实际，但是size_t又难免会出现一些问题，例如：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar a1[] &#x3D; &quot;abc&quot;; &#x2F;&#x2F; 3\n\tchar a2[] &#x3D; &quot;abcdef&quot;;  &#x2F;&#x2F; 6\n\n\tif (strlen(a1) - strlen(a2) &lt; 0)\n\t&#123;\n\t\tprintf(&quot;a1 &lt; a2\\n&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;a1 &gt; a2\\n&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n猜这里输出的结果是什么呢？\n正常来说应该输出a1 &lt; a2才对，可是这里的输出是a1 &gt; a2,那么就说明strlen(a1) - strlen(a2) &gt; 0,这是为什么呢？\nstrlen(a1)返回一个size_t的数3，strlen(a2)返回一个size_t的数6，3 - 6 = -3，此时-3也是一个size_t类型，所以当-3作为一个无符号数来看待的话，那将是一个很大的整数，自然也就大于零输出第一个printf了。\n所以库函数中strlen返回值为size_t可以说有利也有弊，需细心使用，接下来我对字符串函数的实现，如果是返回整型的话，我都会采用返回int的。\nstrlen的自我实现\n\n\n\n\n\n\n\n\n这里我的strlen实现有三种方式：计数，指针减指针，递归，他们分别对应my_strlen1, my_strlen2, my_strlen3。\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nint my_strlen1(const char* s)\n&#123;\n\tassert(s);\n\n\tint count &#x3D; 0;\n\n\twhile (*s)\n\t&#123;\n\t\t++count;   &#x2F;&#x2F; *s 不是 \\0 就加一\n\t\t++s;\n\t&#125;\n\n\treturn count;\n&#125;\n\nint my_strlen2(const char* s)\n&#123;\n\tassert(s);\n\n\tconst char* cur &#x3D; s;\n\twhile (*cur)\n\t&#123;\n\t\tcur++;\n\t&#125;\n\n\treturn (int)(cur - s); &#x2F;&#x2F; 用 cur 指针找到 \\0 ,再用 cur 减去 s 得到之间字符的个数 6\n&#125;\n\nint my_strlen3(const char* s)\n&#123;\n\tassert(s);\n\n\tif (*s !&#x3D; &#39;\\0&#39;)\n\t\treturn 1 + my_strlen3(s + 1);\n\telse\n\t\treturn 0;\n&#125;\n\nint main()\n&#123;\n\tchar a[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%d\\n&quot;, my_strlen1(a));  &#x2F;&#x2F; 6\n\tprintf(&quot;%d\\n&quot;, my_strlen2(a));  &#x2F;&#x2F; 6\n\tprintf(&quot;%d\\n&quot;, my_strlen3(a));  &#x2F;&#x2F; 6\n\n\treturn 0;\n&#125;\n\n\n\n\nstrcpy\n\n\n\n\n\n\n\n\nstrcpy的功能是字符串拷贝，将源头（src）字符串拷贝到目的地（dest）字符串当中，并且是从头开始拷贝，src中的\\0也要拷贝过去。注意：dest 的字符串长度要大于等于 src ，不然 src 拷贝过去会出现非法访问的错误。\n\nstrcpy函数返回目的地字符串（被拷贝后）首元素地址。\nstrcpy的使用#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;xxxxxxxxxx&quot;;\n\tchar arr2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strcpy(arr1, arr2));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：abcdef\n\nstrcpy的自我实现\n\n\n\n\n\n\n\n\n上图实际上就是整个拷贝的过程，*dest++ = *src++是整个代码实现核心。\n实现代码如下：\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nchar* my_strcpy(char* dest, const char* src)\n&#123;\n\tassert(dest &amp;&amp; src);\n\n\tchar* ret &#x3D; dest;  &#x2F;&#x2F; 先要记住dest的起始位置\n\n\twhile (*dest++ &#x3D; *src++)  &#x2F;&#x2F; 先运算*dest &#x3D; *src，再判断*dest，再分别++\n\t&#123;\n\t\t;\n\t&#125;\n\n\treturn ret; &#x2F;&#x2F; 返回dest起始位置\n&#125;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;xxxxxxxxxx&quot;;\n\tchar arr2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, my_strcpy(arr1, arr2));\n\n\treturn 0;\n&#125;\n\n\n\nstrcat\n\n\n\n\n\n\n\n\n该函数的功能是在目的地字符串末尾追加源字符串（连接），目的地字符串的末尾不包括\\0,也就是说\\0将会被追加的字符串覆盖。\n\n注意：源字符串必须以 \\0 结束。目标空间必须足够的大，能容纳下追加后目的地字符串的所有内容。目标空间必须可修改。\n\n\nstrcat的使用1.正常的追加\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[20] &#x3D; &quot;xxxxx&quot;;\n\tchar arr2[] &#x3D; &quot;abc&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strcat(arr1, arr2));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：xxxxxabc\n2.目的地字符串中存在\\0\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[20] &#x3D; &quot;xxx\\0xxxxxxxx&quot;;\n\tchar arr2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strcat(arr1, arr2));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：xxxabcdef\n要注意：\nstrcat不能追加自己，因为再追加自己的同时，末尾的\\0在追加的时候被修改了，这时就会死循环，因为要追加的字符串也找不到\\0了，此时程序会崩溃。如果要追加自己，可以用下面要讲解的strnpy函数。\nstrcat的自我实现\n\n\n\n\n\n\n\n\n通过上面的解析可以知道，我们首先要让一个指针找到dest（目的地字符串）的\\0，再进行追加（连接），而追加的功能类似于拷贝（*dest++ = *src++）。\n代码实现：\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nchar* my_strcat(char* dest, const char* src)\n&#123;\n\tassert(dest &amp;&amp; src);\n\n\tchar* ret &#x3D; dest; \n\t\n\t&#x2F;&#x2F; 先找到 dest 的第一个 \\0\n\twhile (*dest)\n\t&#123;\n\t\tdest++;\n\t&#125;\n\n\twhile (*dest++ &#x3D; *src++) &#x2F;&#x2F; 追加\n\t&#123;\n\t\t;\n\t&#125;\n\n\treturn ret;\n&#125;\n\nint main()\n&#123;\n\tchar arr1[20] &#x3D; &quot;xxxxx&quot;;  &#x2F;&#x2F; 大小为 20 ，为了能够承受住 arr2 的追加\n\tchar arr2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, my_strcat(arr1, arr2));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n运行结果为：xxxxxabcdef\nstrcmp\n\n\n\n\n\n\n\n\n该函数的功能是比较两个字符串，看相等，小于，还是大于，是小于还是大于是根据字符的ASCLL码值来比较的。而字符的比较是两个字符串一对一对字符的比。\n\n\n\n如果str1 &lt; str2 返回一个小于0的数，如果str1 == str2返回0，如果str1 &gt; str2返回一个大于0的数。\n例如”abc“与“ac”比较，a == a ，b != c，又b的ASCLL码值``小于``c的ASCLL码值，所以返回一个小于零的数。\n\nstrcmp的使用#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;abcdef&quot;;\n\tchar arr2[] &#x3D; &quot;abcdq&quot;;\n\tchar arr3[] &#x3D; &quot;abcd&quot;;\n\n\tprintf(&quot;%d\\n&quot;, strcmp(arr1, arr2));\n\tprintf(&quot;%d\\n&quot;, strcmp(arr1, arr3));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：-1    1这是因为vs的strcmp如果小返回-1，大返回1，相等返回0，而标准就是上面所说。\nstrcmp的自我实现\n\n\n\n\n\n\n\n\n这里按标准的返回值来实现\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nint my_strcmp(const char* str1, const char* str2)\n&#123;\n\tassert(str1 &amp;&amp; str2);\n\n\twhile (*str1 !&#x3D; &#39;\\0&#39; || *str2 !&#x3D; &#39;\\0&#39;)\n\t&#123;\n\t\tif (*str1 - *str2)\n\t\t&#123;\n\t\t\treturn *str1 - *str2;\n\t\t&#125;\n\t\tstr1++;\n\t\tstr2++;\n\t&#125;\n\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;abcdef&quot;;\n\tchar arr2[] &#x3D; &quot;abcdq&quot;;\n\n\tprintf(&quot;%d\\n&quot;, my_strcmp(arr1, arr2));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：-12\n2.长度受限制的常见字符串函数strncpy\n\n\n\n\n\n\n\n\n该函数的功能是指定拷贝几个字符，与strcpy不同的是，strncpy多了一个确定拷贝字符个数的参数，这也就限制了长度，让使用者更能精确的拷贝自己想要的字符。\n\n同样要注意的是：1.源字符串拷贝到目的地字符串时不能超出目的地字符串的空间大小；2.如果拷贝个数小于源字符串的长度，这时不会拷贝\\0，也就是“abcdef”，如果拷贝4个，则只拷贝“abcd”过去;3.如果拷贝个数大于源字符串的长度 + 1（因为后面还有一个\\0）,则多出来的拷贝放\\0。\n\n该函数的函数参数：\nstrncpy的使用1.正常拷贝：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;xxxxxxxxxxxxxxxx&quot;;\n\tchar arr2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strncpy(arr1, arr2, 5));  &#x2F;&#x2F; 拷贝5个\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n运行结果为：abcdexxxxxxxxxxx\n2.拷贝个数等于源字符串的长度 + 1：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;xxxxxxxxxxxxxxxx&quot;;\n\tchar arr2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strncpy(arr1, arr2, 7)); &#x2F;&#x2F; 拷贝7个，该字符串的长度为6\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：abcdef\n3.拷贝个数大于源字符串的长度 + 1:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;xxxxxxxxxxxxxxxx&quot;;\n\tchar arr2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strncpy(arr1, arr2, 10)); &#x2F;&#x2F; 拷贝10个，arr2不够，后面拷贝\\0\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n运行结果为：abcdef\nstrncpy的自我实现#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;string.h&gt;\n\nchar* my_strncpy(char* dest, const char* src, int n)\n&#123;\n\tassert(dest &amp;&amp; src);\n\n\tchar* ret &#x3D; dest;\n\t&#x2F;&#x2F; 这里求src的长度是为了解决拷贝个数大于源字符串的长度 + 1的情况\n\t&#x2F;&#x2F; 每拷贝一个lenSrc--，当 lenSrc &#x3D;&#x3D; 0，而 n !&#x3D; 0,此时应该在后面拷贝\\0直至n &#x3D;&#x3D; 0；\n\t&#x2F;&#x2F; 因为字符串后面还有一个\\0,要把他算在内，所以lenSrc要等于长度 + 1；\n\tint lenSrc &#x3D; (int)strlen(src) + 1;\n\n\twhile (n--)\n\t&#123;\n\t\tif (!lenSrc) &#x2F;&#x2F; 当lenSrc为0时，!lenSrc为真，后面拷贝\\0直至 n &#x3D;&#x3D; 0；\n\t\t&#123;\n\t\t\t*dest++ &#x3D; &#39;\\0&#39;;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\t*dest++ &#x3D; *src++;\n\t\t\tlenSrc--;  &#x2F;&#x2F; 每拷贝一次源字符串的内容，lenSrc--；\n\t\t&#125;\n\t&#125;\n\n\treturn ret;\n&#125;\n\nint main()\n&#123;\n\tchar arr1[20] &#x3D; &quot;xxxxxxxxxxxxxxxx&quot;;\n\tchar arr2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, my_strncpy(arr1, arr2, 5));\n\n\treturn 0;\n&#125;\n\n\n\n\n\nstrncat\n\n\n\n\n\n\n\n\n该函数的功能就是指定在目的地字符串后面追加（连接）源字符串的几个字符，其注意事项与strcat差不多，由于长度受限制，所以追加的形式与strcat也会不同。\n\nstrncat的使用1.目的地字符串只有末尾有\\0：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar a1[20] &#x3D; &quot;xxxxxxxxxxx&quot;;\n\tchar a2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strncat(a1, a2, 4));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：xxxxxxxxxxxabcd\n2.目的地字符串中间也有\\0：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar a1[20] &#x3D; &quot;xxx\\0xxxxxxx&quot;;\n\tchar a2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strncat(a1, a2, 5));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n运行结果为：xxxabcde\n可以发现，当追加完所定个数的字符后，会在此的后面自动追加一个\\0（打印的时候遇到\\0停止可确定）。\n3.当追加的个数大于源字符串的长度时，将源字符串追加过去后便停止追加：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar a1[20] &#x3D; &quot;xxxx&quot;;\n\tchar a2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strncat(a1, a2, 8));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n运行结果为：xxxxabcdef\nstrncat的自我实现\n\n\n\n\n\n\n\n\n了解到上面函数的功能后，接下来就将这些功能实现成strncat函数\n\n核心功能：1.追加完后自动再追加一个\\0;2.目的地字符串先找\\0;3.源字符串整个追加完后停止追加；4.追加的代码；\n\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;string.h&gt;\n\nchar* my_strncat(char* dest, const char* src, int n)\n&#123;\n\tassert(dest &amp;&amp; src);\n\n\tchar* ret &#x3D; dest;\n\tint lenSrc &#x3D; (int)strlen(src);\n\n\t&#x2F;&#x2F; 目的地字符串先找\\0\n\twhile (*dest)\n\t&#123;\n\t\tdest++;\n\t&#125;\n\n\twhile (n)\n\t&#123;\n\t\t&#x2F;&#x2F; 如果整个源字符串追加完了此时 n !&#x3D; 0，在后面追加一个\\0,停止追加\n\t\tif (!lenSrc)\n\t\t&#123;\n\t\t\t*dest++ &#x3D; &#39;\\0&#39;;\n\t\t\tbreak;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\t*dest++ &#x3D; *src++;\n\t\t\tlenSrc--;\n\t\t&#125;\n\t\tn--;\n\t&#125;\n\n\t&#x2F;&#x2F; 如果n &#x3D;&#x3D; 0也就是说要追加的追加完了，在后面再追加一个\\0\n\tif (n &#x3D;&#x3D; 0)\n\t\t*dest &#x3D; &#39;\\0&#39;;\n\n\treturn ret;\n&#125;\n\nint main()\n&#123;\n\tchar a1[20] &#x3D; &quot;xxxxxxx&quot;;\n\tchar a2[] &#x3D; &quot;abcdef&quot;;\n\n\tprintf(&quot;%s\\n&quot;, my_strncat(a1, a2, 8));\n\n\treturn 0;\n&#125;\n\n\n\nstrncmp\n\n\n\n\n\n\n\n\n该函数功能是指定两个字符串多少对字符进行对比，对比的方式与strcmp函数相同。\n\nstrncmp的使用#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar a1[] &#x3D; &quot;abcdef&quot;;\n\tchar a2[] &#x3D; &quot;abcdq&quot;;\n\n\tprintf(&quot;%d\\n&quot;, strncmp(a1, a2, 5));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n当比对到e和q时 e的ASCLL码值小于q的ASCLL码值，所以打印小于零的数，如果第三个参数为4，则返回0，也就要打印0。\nstrncmp的自我实现\n\n\n\n\n\n\n\n\n这里是按照vs的标准来实现的，也就是比对小于返回-1，比对大于返回1，等于返回0；\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nint my_strncmp(const char* str1, const char* str2, int n)\n&#123;\n\tassert(str1 &amp;&amp; str2);\n\n\twhile (n--)\n\t&#123;\n\t\tif (*str1 - *str2)\n\t\t&#123;\n\t\t\tif (*str1 &lt; *str2)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t&#125;\n\t\tstr1++;\n\t\tstr2++;\n\t&#125;\n\n    &#x2F;&#x2F; n个都比对完了，而前面没有返回（比对都相同），说明这n个相等\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\tchar a1[20] &#x3D; &quot;abc&quot;;\n\tchar a2[] &#x3D; &quot;abcgdef&quot;;\n\n\tprintf(&quot;%d\\n&quot;, my_strncmp(a1, a2, 3));\n\t&#x2F;&#x2F; 1:a1 &gt; a2\n\t&#x2F;&#x2F; 0:a1 &#x3D;&#x3D; a2\n\t&#x2F;&#x2F; -1:a1 &lt; a2\n\n\treturn 0;\n&#125;\n\n\n\n3.字符串查找strstr\n\n\n\n\n\n\n\n\n该函数功能实际上是判断一个字符串是否是另一个字符串的子串，例如字符串s1 = “iou”，字符串s2 = “youioume?”,s2中间出现了iou这样的子串，所以该函数返回i的地址，打印出来也就是ioume?。\n\n\n\n\n\n\n\n\n\n\n\n返回指向 str2 中指定的整个字符序列在 str1 中首次出现的指针，如果字符序列str2在 str1 中不存在，则返回 null 指针。\nstrstr的使用#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;abcdef&quot;;\n\tchar arr2[] &#x3D; &quot;bcde&quot;;\n\tchar arr3[] &#x3D; &quot;bcb&quot;;\n\n\tprintf(&quot;%s\\n&quot;, strstr(arr1, arr2));\n\tprintf(&quot;%s\\n&quot;, strstr(arr1, arr3));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为： bcdef   （null）\n\nstrstr的自我实现\n\n\n\n\n\n\n\n\nstrstr的自我实现相对较难，这里我用暴力解法。\n\n定义三个指针cur ，s1，s2，cur为开始匹配的位置（匹配成功好返回），s1与s2是比对指针。\n什么时候停止匹配返回NULL呢？1.当*cur为\\0时停止2.当从cur位置开始后面的字符个数小于str2的字符个数时停止（strlen（cur）&lt; strlen（str2））；\n\n代码实现：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;assert.h&gt;\n\nchar* my_strstr(const char* str1, const char* str2)\n&#123;\n\tassert(str1 &amp;&amp; str2);\n\n\tif (*str2 &#x3D;&#x3D; &#39;\\0&#39;)\n\t\treturn (char*)str1;\n\n\tconst char* s1 &#x3D; NULL;\n\tconst char* s2 &#x3D; NULL;\n\tconst char* cur &#x3D; str1;\n\n\twhile (*cur)\n\t&#123;\n\t\ts1 &#x3D; cur;\n\t\ts2 &#x3D; str2;\n\n\t\twhile (!(*s1 - *s2) &amp;&amp; *s1 &amp;&amp; *s2)\n\t\t&#123;\n\t\t\ts1++;\n\t\t\ts2++;\n\t\t&#125;\n\n\t\tif (!*s2)  &#x2F;&#x2F; 如果上面的循环停止是因为*s2 &#x3D;&#x3D; \\0,那么匹配成功\n\t\t\treturn (char*)cur;\n\t\tif ((int)strlen(cur) &lt; (int)strlen(str2))\n\t\t\treturn NULL;\n\n\t\tcur++;\n\t&#125;\n\n\treturn NULL;\n&#125;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;abbbce&quot;;\n\tchar arr2[] &#x3D; &quot;bbc&quot;;\n\n\tprintf(&quot;%s\\n&quot;, my_strstr(arr1, arr2));\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n运行结果为：bbce\nstrtok\n\n\n\n\n\n\n\n\n这个函数的功能通俗来说是分割字符串，在一个字符串内输入需要在此字符分割的字符，例如“@.”,也就是说在另一个字符串里，要找到@和.并在此字符的位置对该字符串进行分割。\n函数参数介绍：\n\n\nstrtok的使用\n\n\n\n\n\n\n\n\n\n当我们第一次传参时，将要分割的字符串和确定分割的字符的字符串传过去，第一次分割好后，strtok函数会自动记住分割的位置，下一次我们要继续调用这个函数，不过函数第一个参数要传NULL（因为strtok自动记住了第一次分割的位置），直到要分割的字符串中没有要分割的字符，此时返回一个\tNULL，停止分割。\n这里我们可以用一个fou循环来进行分割，当最后返回一个NULL的时候表示分割结束，循环结束。\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar a1[] &#x3D; &quot;I@love.you&quot;;\n\tchar a2[] &#x3D; &quot;@.&quot;;\n\n\tchar* ret &#x3D; NULL;\n\tfor (ret &#x3D; strtok(a1, a2); ret !&#x3D; NULL; ret &#x3D; strtok(NULL, a2))\n\t&#123;\n\t\tprintf(&quot;%s\\n&quot;, ret);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n4.错误信息报告strerror\n\n\n\n\n\n\n\n\n\n该函数的功能相当于是报错误，如果我们在实现某个功能的时候，怕这个程序出现问题，这时我们可以if（如果怎么怎么样），就报一个错误（用strerror），当然学习这个函数还要认识另一个函数，那就是errno（对应头文件为（errno.h））\nerrno：C语言的库函数在运行的时候，如果发生错误，就会将错误码存在一个变量中，这个变量&gt;  是：errno，这时我们用strerror将其输出，就可以得到错误信息。\n当然有一些错误码是一些数字：1 2 3 4 5 我们也可以将这些数字作为strerror函数的参数输出，这时需要将错误码翻译成错误信息然后再输出。\n\nstrerror的使用1.数字错误码：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tprintf(&quot;%s\\n&quot;, strerror(0));\n\tprintf(&quot;%s\\n&quot;, strerror(1));\n\tprintf(&quot;%s\\n&quot;, strerror(2));\n\tprintf(&quot;%s\\n&quot;, strerror(3));\n\tprintf(&quot;%s\\n&quot;, strerror(4));\n\tprintf(&quot;%s\\n&quot;, strerror(5));\n\n\treturn 0;\n&#125;\n\n\n2.errno对应的使用：\n\n\n\n\n\n\n\n\n\n这里开开辟一个巨大的空间，如果开辟失败，就会返回NULL，然后就会输出对应的错误信息（为什么开辟失败）。\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;errno.h&gt; &#x2F;&#x2F; 使用errno所需头文件\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\tint* tmp &#x3D; (int*)malloc(sizeof(int) * 12345678910);\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;开辟成功！\\n&quot;);\n\t&#125;\n\n\tfree(tmp);\n\ttmp &#x3D; NULL;\n\n\treturn 0;\n&#125;\n\n\n写在最后\n\n\n\n\n\n\n\n\n常用字符串函数的熟练使用可以在某些地方大大提升写代码效率，因此一定要好好掌握，最好能够自我实现，吃透这些函数的运行逻辑，以便更精确更融洽的使用。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"C语言常见字符串函数的解析和部分字符串函数的实现","date":"2023-02-18T04:01:12.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"43e2ee3df951b9743f1edd51428d3b1f","title":"GO语言基本数据类型","content":"1.整数类型\n\n\n\n\n\n\n\n\n整数类型就是存放整数的，如18 ，-18，123534等，在GO语言中，几乎不同于其它语言，以字节的视角来看其int类型还分为不同的int表达，首先int还要分为两大类。\n1.1.有符号整数类型\n\n\n\n\n\n\n\n\n有符号就是整数有正负之分\n我们来看下图：可以看到，这4个int后面都带了数字，这其实就是这个int类型占用内存最大的比特位，比如int8，就是这个int类型最大只能占用8个比特位，也就是一个字节（1个字节 &#x3D;&#x3D; 8个比特位），其他的int也是这样来看的，这中分类也就确定了各个int的表数范围，所以我们在定义一个整型值使，要估摸这个整型值的范围，再来确定使用哪个int的类型。 \n\n\n\n\n\n\n\n\n\n\n我们可以看看这些表示int的类型其大小是不是如此呢？\n\npackage main\nimport (\n\t&quot;fmt&quot;\n\t&quot;unsafe&quot;\n)\n\nfunc main()&#123;\n\tvar num1 int8\n\tfmt.Println(unsafe.Sizeof(num1))\n\tvar num2 int16\n\tfmt.Println(unsafe.Sizeof(num2))\n\tvar num3 int32\n\tfmt.Println(unsafe.Sizeof(num3))\n\tvar num4 int64 \n\tfmt.Println(unsafe.Sizeof(num4))\n&#125;\n\n\n\n可以看到，不同的int类型其字节大小的确不同。\n\n\n\n\n\n\n\n\n\n\n如果说int类型赋值不当就会出现如下的错误：\n\npackage main\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\tvar num1 int8 &#x3D; 666 &#x2F;&#x2F; int8 不能承受666这个值\n\tfmt.Println(num1)\n&#125;\n也就是说666不能作为值赋给int8，不然编译就会出问题，应该使用更高存储字节空间的int类型来存放。\n1.2.无符号整数类型\n\n\n\n\n\n\n\n\n无符号整数类型就是没有负数之说只有整正数（没有符号位）\n我们来看下图：\n\n可以看到，无符号整数类型在有符号整数类型int的前面多了一个u，这就是表示无符号的意思，值得注意的是，其占用储存空间的字节大小没有变化，但表数范围变了，变得没有负数了，最大值更大了，这就是无符号整型的优势，如果你想表达的数据咬定没有负数，那么选无符号整型类型会更好些（如表示身高，年龄）。\n\n\n\n\n\n\n\n\n\n\n当然，如果用无符号整型取存放负数，这也是会严格的报错的\n\n\n1.3.其他整数类型我们来看下图：\n可以看到，int和uint他们的字节大小是由计算机系统的位数来决定的，rune就相当于int32，byte相当于uint8（在后面byte可以用作字符的类型）。\n定义如下：\npackage main\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\tvar a int &#x3D; 3\n\tvar b uint &#x3D; 5\n\tvar c rune &#x3D; 10\n\tvar d byte &#x3D; 20\n\tvar e byte &#x3D; &#39;a&#39;\n&#125;\n1.4.额外知识\nGolang的整数类型，默认声明为int类型\n\n变量占用的字节数\n\n\n\n\n\n\n\n\n\n首先要求变量所占用的字节数，需要引入unsafe这个包，然后使用这个包里面的Sizeof来求\n\n\npackage main\nimport (\n\t&quot;fmt&quot;\n\t&quot;unsafe&quot; &#x2F;&#x2F; 引入包\n)\n\nfunc main()&#123;\n\t&#x2F;&#x2F; 直接使用\n\tvar num1 int8\n\tfmt.Println(unsafe.Sizeof(num1)) &#x2F;&#x2F; 1 \n\tvar num2 int16\n\tfmt.Println(unsafe.Sizeof(num2)) &#x2F;&#x2F; 2\n\tvar num3 int32\n\tfmt.Println(unsafe.Sizeof(num3)) &#x2F;&#x2F; 4\n\tvar num4 int64 \n\tfmt.Println(unsafe.Sizeof(num4)) &#x2F;&#x2F; 8\n&#125;\n\n\n这么多整数类型，使用的时候该如何选择呢？Golang程序中整型变量在使用时,遵守保小不保大的原则,  即: 在保证程序正确运行下,尽量使用占用空间小的数据类型\n\n&#x2F;&#x2F; 表示学生年龄\nvar age byte &#x3D; 8 &#x2F;&#x2F; 小的数据尽量用byte存放\n\n\n\n\n2.浮点类型\n\n\n\n\n\n\n\n\n简单来说，浮点类型就是用来存放小树值的， 如3.14，5.20，-13.14。\n看下图：\n\n在GO语言中，要创建浮点类型的变量，必须在float后面加上32或者64，因为单纯的一个float不会被当作浮点类型。\n\n当我们在赋值给一个浮点类型的变量时，我们可以直接赋值小数，也可以用E（或者e）（科学计数法）表示，如下：\n\npackage main\nimport (\n\t&quot;fmt&quot;\n)\n\nfunc main()&#123;\n\tvar fa float32 &#x3D; 314E-2 &#x2F;&#x2F; E-2表示乘以10^-2\n\tvar fb float32 &#x3D; 314E+2 &#x2F;&#x2F; E+2表示乘以10^2\n\tvar fc float32 &#x3D; 314e-2 &#x2F;&#x2F; 小写e与大写E没有区别\n\tvar fd float32 &#x3D; 3.14 &#x2F;&#x2F; 直接赋值3.14\n\tfmt.Println(fa)  &#x2F;&#x2F; 3.14\n\tfmt.Println(fb)  &#x2F;&#x2F; 31400\n\tfmt.Println(fc)  &#x2F;&#x2F; 3.14\n\tfmt.Println(fd)  &#x2F;&#x2F; 3.14\n&#125;\n\n我们在给float赋值的时候，很可能出现精度损失的情况，因此建议创建浮点类型的时候最好用float64。\n\npackage main\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\t&#x2F;&#x2F;浮点数可能会有精度的损失，所以通常情况下，建议你使用：float64 \n\tvar num7 float32 &#x3D; 520.000001314\n\tfmt.Println(num7)\n\tvar num8 float64 &#x3D; 520.000001314\n\tfmt.Println(num8)\n&#125;\n运行结果：\n3.字符类型\n\n\n\n\n\n\n\n\n\nGolang中没有专门的字符类型，如果要存储单个字符(字母)，一般使用byte来保存。\nGolang中字符使用UTF-8编码UTF-8编码链接\n\nUTF-8编码：\n\n当我们用byte类型来定义一个字符变量，将其打印出来的值是其对应的ASCLL码值，各个字符的ASCLL码值对应如下：\n\n示例如下：所以字符类型，本质上就是一个整数，也可以直接参与运算，输出字符的时候，会将对应的码值做一个输出，但如果我们用Printf打印（括号里要用%c），可以打印出字符：\n\n\n\n\n\n\n\n\n\n如果我们想要打印中文字符，比如打印一个中，这时byte类型就存放不下其对应的ASCLL码值了，所以这时我们应该使用int。\npackage main\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\tvar c int &#x3D; &#39;中&#39;\n\tfmt.Println(c)\n\t&#x2F;&#x2F;汉字字符，底层对应的是Unicode码值\n\t&#x2F;&#x2F;对应的码值为20013，byte类型溢出，能存储的范围：可以用int\n\t&#x2F;&#x2F;总结：Golang的字符对应的使用的是UTF-8编码\n\t&#x2F;&#x2F;（Unicode是对应的字符集，UTF-8是Unicode的其中的一种编码方案）\n&#125;\n\n\n转义字符看下图：\n\n通俗来说：\n\n\\b 就是往前挪一格，掩盖挪动的那一格的数据。 \n\n\\n就是换行，这个不用多说（haha）\n\n\\r 就是光标回到本行的开头，将\\r后面的字符依次覆盖前面的字符。 \n\n\\t就是将\\t前面的字符串补够8个位置（不够8个位置），不够的话，则从那够了的8个再往后数。\n\n\n\n\n\\&quot; , \\&#39; , \\\\这三个是为了在字符串中能够将”,&#39;,\\打印出来而不是与旁边的&quot;&quot;,&#39;&#39;,或者是转义匹配。\n\n例如：\n\n4.布尔类型\n\n\n\n\n\n\n\n\n\n布尔类型也叫bool类型，bool类型数据只允许取值true和false。\n布尔类型占1个字节。\n布尔类型适于逻辑运算，一般用于程序流程控制。\n\n基本的使用：\npackage main\nimport &quot;fmt&quot;\nfunc main()&#123;\n        &#x2F;&#x2F;测试布尔类型的数值：\n        var flag1 bool &#x3D; true\n        fmt.Println(flag1) &#x2F;&#x2F; true\n        var flag2 bool &#x3D; false\n        fmt.Println(flag2) &#x2F;&#x2F; false\n        var flag3 bool &#x3D; 5 &lt; 9\n        fmt.Println(flag3) &#x2F;&#x2F; true，因为5的确小于9：为真\n&#125;\n\n\n5.字符串类型\n\n\n\n\n\n\n\n\n\n字符串类型用 string 来定义。\n字符串定义后就不能改变了（单指字符串，变量的值可以变）。\n字符串可以拼接。\n当一个字符串里面有转义的时候最好用 &#96;&#96; （Esc下面的按键）括起来（当然转义字符也可以）。\n当一个字符串过长时，最好换行，而换行的时候最好将运算符放在一行的最后面，因为如果不是符号在最后面，编译器会自动在这一行的后面加上；，我们看不见而已。\n\n示例：\npackage main\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\n\n\t&#x2F;&#x2F; 定义一个字符串\n\tvar str1 string &#x3D; &quot;hello golang&quot;\n\tfmt.Println(str1) &#x2F;&#x2F; hello golang\n\n\n\t&#x2F;&#x2F; 转义字符过多时用&#96;&#96;括起来\n\tvar str2 string &#x3D; &#96;package main\n\timport &quot;fmt&quot;\n\tfunc main()&#123;\n\t\tfmt.Println(&quot;abc\\&quot;d\\&quot;efghijklm\\\\nopqrs\\\\tuvw&quot;)\n\t\t&#x2F;&#x2F; abc&quot;d&quot;efghijklm\\nopqrs\\tuvw\n\t&#125;&#96;\n\n\n\t&#x2F;&#x2F; 字符串拼接\n\tvar str3 string &#x3D; &quot;hahaha&quot; + &quot;hehehe&quot;\n\tstr3 +&#x3D; &quot;iloveyou&quot;\n\tfmt.Println(str3) &#x2F;&#x2F; hahahaheheheiloveyou\n\n\n\t&#x2F;&#x2F;当一个字符串过长的时候：注意：+保留在上一行的最后\n\tvar str4 string &#x3D; &quot;abc&quot; + &quot;def&quot; + &quot;abc&quot; + &quot;def&quot; + &quot;abc&quot; + &quot;def&quot; + &quot;abc&quot; +\n\t     &quot;def&quot;+ &quot;abc&quot; + &quot;def&quot; + &quot;abc&quot; + &quot;def&quot;+ &quot;abc&quot; + &quot;def&quot; + &quot;abc&quot; + &quot;def&quot;+\n\t\t&quot;abc&quot; + &quot;def&quot; + &quot;abc&quot; + &quot;def&quot;+ &quot;abc&quot; + &quot;def&quot; + &quot;abc&quot; + &quot;def&quot;+ &quot;abc&quot; +\n\t\t&quot;def&quot; + &quot;abc&quot; + &quot;def&quot;+ &quot;abc&quot; + &quot;def&quot; + &quot;abc&quot; + &quot;def&quot;+ &quot;abc&quot; + &quot;def&quot; + \n\t\t&quot;abc&quot; + &quot;def&quot;+ &quot;abc&quot; + &quot;def&quot;\n\tfmt.Println(str4)\n&#125;\n\n6.基本数据类型的默认值\n\n\n\n\n\n\n\n\n在Golang中数据类型都有一个默认值，当程序员没有赋值时，就会保留默认值(默认值又叫零值)。\n\n7.基本数据类型之间的转换\n\n\n\n\n\n\n\n\nGo在不同类型的变量之间赋值时需要显式转换，并且只有显式转换(强制转换)。\n\n\n\n\n\n\n\n\n\n语法形式：表达式T(v)将值v转换为类型TT : 就是数据类型v : 就是需要转换的变量\n例如：\npackage main\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\tvar num1 int &#x3D; 1000\n\tvar f1 float32 &#x3D; float32(num1)\n\tfmt.Println(f1) &#x2F;&#x2F; 1000\n\n\tvar f2 float32 &#x3D; 666.66\n\tvar num2 int &#x3D; int(f2)\n\tfmt.Println(num2) &#x2F;&#x2F; 66\n&#125;\n\n\n但如过一个大的值强制转换为一个不能存放这个大数据的值的类型时，编译器不会报错，但运行后会造成数据的溢出（截断）：例如：\npackage main\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\t&#x2F;&#x2F; 将int64转为int8的时候，编译不会出错的，但是会数据的溢出\n\tvar n1 int64 &#x3D; 666666\n\tvar n2 int8 &#x3D; int8(n3)\n\t&#x2F;&#x2F; 这里发生了截断\n\tfmt.Println(n2)&#x2F;&#x2F;56\n&#125;\n\n8.基本数据类型转为string\n\n\n\n\n\n\n\n\n\n在程序开发中，我们经常需要将基本数据类型转成string类型。或者将string类型转成基本数据类型。\n将基本数据类型转化为string有两种方式：1.fmt包中的Sprintf（“%参数”， 要转换的变量（注意：原先的变量值不变，只是将面值赋给一个string类型的变量））— 推荐。2.使用strconv包中的函数。\n\n\n第一种方式转换如下：\n\npackage main\nimport &quot;fmt&quot;\nfunc main()&#123;\n\tvar n1 int &#x3D; 19\n\tvar n2 float32 &#x3D; 4.78\n\tvar n3 bool &#x3D; false\n\tvar n4 byte &#x3D; &#39;a&#39;\n\n\tvar s1 string &#x3D; fmt.Sprintf(&quot;%d&quot;,n1)\n\tfmt.Printf(&quot;s1对应的类型是：%T ，s1 &#x3D; %q \\n&quot;,s1, s1)\n\n\tvar s2 string &#x3D; fmt.Sprintf(&quot;%f&quot;,n2)\n\tfmt.Printf(&quot;s2对应的类型是：%T ，s2 &#x3D; %q \\n&quot;,s2, s2)\n\n\tvar s3 string &#x3D; fmt.Sprintf(&quot;%t&quot;,n3)\n\tfmt.Printf(&quot;s3对应的类型是：%T ，s3 &#x3D; %q \\n&quot;,s3, s3)\n\t\n\tvar s4 string &#x3D; fmt.Sprintf(&quot;%c&quot;,n4)\n\tfmt.Printf(&quot;s4对应的类型是：%T ，s4 &#x3D; %q \\n&quot;,s4, s4)\n&#125;\n\n\n\n\n第二种方式转换我们还需了解strconv包,以及包中我们将要用到的函数。\n\n\n根据函数的功能及使用，如下转换：\npackage main\nimport(\n        &quot;fmt&quot;\n        &quot;strconv&quot;\n)\nfunc main()&#123;\n        var n1 int &#x3D; 18\n        var s1 string &#x3D; strconv.FormatInt(int64(n1),10)  &#x2F;&#x2F;参数：第一个参数必须转为int64类型 ，第二个参数指定字面值的进制形式为十进制\n        fmt.Printf(&quot;s1对应的类型是：%T ，s1 &#x3D; %q \\n&quot;,s1, s1)\n        \n        var n2 float64 &#x3D; 4.29\n        var s2 string &#x3D; strconv.FormatFloat(n2,&#39;f&#39;,9,64)\n        &#x2F;&#x2F;第二个参数：&#39;f&#39;（-ddd.dddd）  第三个参数：9 保留小数点后面9位  第四个参数：表示这个小数是float64类型\n        fmt.Printf(&quot;s2对应的类型是：%T ，s2 &#x3D; %q \\n&quot;,s2, s2)\n        \n        var n3 bool &#x3D; true\n        var s3 string &#x3D; strconv.FormatBool(n3)\n        fmt.Printf(&quot;s3对应的类型是：%T ，s3 &#x3D; %q \\n&quot;,s3, s3)\n&#125;\n\n\n\n\n9.string转为基本数据类型\n\n\n\n\n\n\n\n\n将string转为基本数据类型的方式是使用strconv包中的函数。\n\n下面通过使用函数来代码实现转化：\npackage main\nimport(\n        &quot;fmt&quot;\n        &quot;strconv&quot;\n)\n\nfunc main()&#123;\n&#x2F;&#x2F;1. string 转 bool\n        &#x2F;&#x2F;string--&gt;bool\n        var s1 string &#x3D; &quot;true&quot;\n        var b bool\n        &#x2F;&#x2F;ParseBool这个函数的返回值有两个：(value bool, err error)\n        &#x2F;&#x2F;value就是我们得到的布尔类型的数据，err出现的错误\n        &#x2F;&#x2F;我们只关注得到的布尔类型的数据，err可以用_直接忽略\n        b , _ &#x3D; strconv.ParseBool(s1)\n        fmt.Printf(&quot;b的类型是：%T,b&#x3D;%v \\n&quot;,b,b)\n&#x2F;&#x2F;2.  string 转 int64        \n        &#x2F;&#x2F;string---》int64\n        var s2 string &#x3D; &quot;19&quot;\n        var num1 int64\n        num1,_ &#x3D; strconv.ParseInt(s2,10,64)\n        fmt.Printf(&quot;num1的类型是：%T,num1&#x3D;%v \\n&quot;,num1,num1)\n&#x2F;&#x2F;3.  string 转 float64        \n        &#x2F;&#x2F;string--&gt;float32&#x2F;float64\n        var s3 string &#x3D; &quot;3.14&quot;\n        var f1 float64\n        f1,_ &#x3D; strconv.ParseFloat(s3,64)\n        fmt.Printf(&quot;f1的类型是：%T,f1&#x3D;%v \\n&quot;,f1,f1)\n&#x2F;&#x2F;4.        \n        &#x2F;&#x2F;注意：string向基本数据类型转换的时候，\n        &#x2F;&#x2F;一定要确保string类型能够\n        &#x2F;&#x2F;转成有效的数据类型，\n        &#x2F;&#x2F;否则最后得到的结果就是按照对应类型的默认值输出\n        var s4 string &#x3D; &quot;golang&quot;\n        var b1 bool\n        b1 , _ &#x3D; strconv.ParseBool(s4)\n        fmt.Printf(&quot;b1的类型是：%T,b1&#x3D;%v \\n&quot;,b1,b1)\n&#x2F;&#x2F;5.        \n        var s5 string &#x3D; &quot;golang&quot;\n        var num2 int64\n        num2,_ &#x3D; strconv.ParseInt(s5,10,64)\n        fmt.Printf(&quot;num2的类型是：%T,num2&#x3D;%v \\n&quot;,num2,num2)\n&#125;\n运行结果为：\n\n\n\n\n\n\n\n\n\n\n可以看到，b1与 num2的值都是默认值。\n写在最后\n\n\n\n\n\n\n\n\nGO语言需要求精的地方多，不能放过每一个部分，不然出来的代码就很可能会不够严谨。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"GO语言基本数据类型","date":"2023-02-18T03:54:57.000Z","categories_index":"GO语言相关知识的深度解析","tags_index":"GO语言","author_index":"坏 幸 运"},{"id":"daac20e59d5dd80457865681aac90392","title":"深度解析数据在内存中的存储","content":"1. 数据类型详细介绍\n\n\n\n\n\n\n\n\nchar        // 字符数据类型short       // 短整型int         // 整型 long        // 长整型long long   // 更长的整型float       // 单精度浮点数double      // 双精度浮点数\n1.1.类型的基本归类1.整型家族char unsigned char signed char\nshort unsigned short [int] signed short [int]\nint unsigned int signed int\nlong unsigned long [int] signed long [int]\n2.浮点数家族floatdouble\n3.构造类型数组类型结构体类型：struct枚举类型：enum联合类型：union\n4.指针类型int*char*float*void*\n\n\n\n\n\n\n\n\n\n值得注意的是，void* 类型的指针可以接受任何类型的指针，但其不可以解引用操作。\n例如：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\tchar b &#x3D; &#39;a&#39;;\n\n\tvoid* pa &#x3D; &amp;a;\n\tvoid* pb &#x3D; &amp;b;\n\n\treturn 0;\n&#125;\n\n\n5.空类型void\n\n\n\n\n\n\n\n\n\n空类型通常用于函数的返回类型，函数参数，指针类型。\n2. 整型在内存中的存储：原码、反码、补码\n\n\n\n\n\n\n\n\n\n要理解整型如何在内存中的存储，首先我们得了解原码，反码，补码 的规则.\n\n2.1.原码，反码和补码\n\n\n\n\n\n\n\n\n我们都知道，数据在内存中是以二进制的形式存放的，实际上，在内存中数据的存放存放的是它的补码，那么，什么是补码呢？原码，反码，补码之间是怎样的联系呢？\n\n\n\n\n\n\n\n\n\n\n原码直接将数值按照正负数的形式翻译成二进制就可以得到原码。\n反码将原码的符号位不变，其他位依次按位取反就可以得到反码。\n补码反码+1就得到补码。\n\n\n\n\n\n\n\n\n\n\n值得注意的是：正数的原码，反码和补码相同，负数的原反补则要遵循以上的规则来转换。\n例如：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 3;\n\t&#96;&#x2F;&#x2F; 原码：00000000000000000000000000000011&#96;  3\n\t&#96;&#x2F;&#x2F; 反码：00000000000000000000000000000011&#96;  3\n\t&#96;&#x2F;&#x2F; 补码：00000000000000000000000000000011&#96;  3\n\n\tint b &#x3D; -5;\n\t&#96;&#x2F;&#x2F; 原码：10000000000000000000000000000101&#96;\n\t&#96;&#x2F;&#x2F; 反码：11111111111111111111111111111010&#96;\n\t&#96;&#x2F;&#x2F; 补码：11111111111111111111111111111011&#96; ：&#96;在内存中的存储&#96;\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n对于整形来说：数据存放内存中其实存放的是补码。\n为什么呢？ 在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。\n\n下面我们来看以下整型在内存当中的存储：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 3;\n\t&#x2F;&#x2F; 原码：00000000000000000000000000000011\n\t&#x2F;&#x2F; 反码：00000000000000000000000000000011\n\t&#x2F;&#x2F; 补码：00000000000000000000000000000011\n\t&#x2F;&#x2F; 00 00 00 03  （看这里）\n\n\tint b &#x3D; -5;\n\t&#x2F;&#x2F; 原码：10000000000000000000000000000101\n\t&#x2F;&#x2F; 反码：11111111111111111111111111111010\n\t&#x2F;&#x2F; 补码：11111111111111111111111111111011 ：在内存中的存储\n\t&#x2F;&#x2F; ff ff ff fb  （看这里）\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n这里内存当中实际上是以整型的补码的十六进制形式存储的，将其转化为二进制形式的确与其补码相同。\n3. 大小端字节序介绍及判断\n\n\n\n\n\n\n\n\n\n看上面整型在内存中的存储可以发现，十六进制数据居然是倒着存放的，这其实就与编译器的大小端有关。\n\n那么什么是大小端呢？？？\n3.1.小端\n\n\n\n\n\n\n\n\n在上面的内存观察中，实际上就是小端存储形式，所以 小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。\n用图表示则是：\n\n3.2.大端\n\n\n\n\n\n\n\n\n而大端的存储形式则与小端相反，小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。\n用图表达则是：\n\n那么为什么要有大小端呢？？？\n\n\n\n\n\n\n\n\n\n\n为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。\n例如：一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么 0x11 为高字节， 0x22 为低字节。对于大端模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小端模式，刚好相反。我们常用的 X86 结构是小端模式，而 KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。\n\n那么我们如何来判断编译器是大端还是小端呢？？？\n\n\n\n\n\n\n\n\n\n\n运用大端和小端存储的特性，写一段代码便能知道编译器是大端还是小端。\n用char*来获取整型值1的第一个字节，若是1,则是小端，若是0则是大端。\n\n看代码：\n#include &lt;stdio.h&gt;\n&#x2F;&#x2F; 判断大小端\nint check_sys()\n&#123;\n\tint a &#x3D; 1;\n\treturn *((char*)&amp;a);\n&#125;\n\nint main()\n&#123;\n\tint ret &#x3D; check_sys();\n\tif (1 &#x3D;&#x3D; ret)\n\t    printf(&quot;小端\\n&quot;);\n\telse\n\t    printf(&quot;大端\\n&quot;);\n\t    \n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n可以看到，我的编译器vs2022是小端存储模式。\n4. 浮点型在内存中的存储解析我们先来看一段代码例子：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    int n &#x3D; 9;\n    float *pFloat &#x3D; (float *)&amp;n;\n    \n    printf(&quot;n的值为：%d\\n&quot;,n);\n    printf(&quot;*pFloat的值为：%f\\n&quot;,*pFloat);\n    \n    *pFloat &#x3D; 9.0;\n    \n    printf(&quot;num的值为：%d\\n&quot;,n);\n    printf(&quot;*pFloat的值为：%f\\n&quot;,*pFloat);\n    \n    return 0;\n&#125;\n输出结果是：\n\n奇怪了，为什么结果会是这样呢？第二个打印不应该是9.000000吗？？？第三个打印的结果为什么这么大？？？从这里我们可以确定，浮点型在内存中的存储与整型在内存中的存储是不一样的。\n\n\n\n\n\n\n\n\n\n\n那么浮点型在内存中是如何存储的呢？？？？？根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：1.(-1)^S * M * 2^E2.(-1)^S表示符号位，当S&#x3D;0，V为正数；当S&#x3D;1，V为负数。3.M表示有效数字，大于等于1，小于2。4.2^E表示指数位。\n\n\n\n\n\n\n\n\n\n\n\n举例来说：1.十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2^2 。2.那么，按照上面V的格式，可以得出S&#x3D;0，M&#x3D;1.01，E&#x3D;2。3.十进制的-5.0，写成二进制是 -101.0 ，相当于 -1.01×2^2 。那么，S&#x3D;1，M&#x3D;1.01，E&#x3D;2。\n\n\n\n\n\n\n\n\n\n\n\nIEEE 754规定：对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。\n\n\n\n\n\n\n\n\n\n\n\nIEEE 754对有效数字M和指数E，还有一些特别规定。 前面说过， 1≤M&lt;2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中xxxxxx表示小数部分。\nIEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后等于可以保存24位有效数字。\n至于指数E，情况就比较复杂。首先，E为一个无符号整数（unsigned int）这意味着，如果E为8位，它的取值范围为0 - 255；如果E为11位，它的取值范围为0 - 2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如2^10的E是10，所以保存成32位浮点数时，必须保存成10+127&#x3D;137，即10001001。\n\n然后，指数E从内存中取出还可以再分成三种情况：\n\n\n\n\n\n\n\n\n\n\nE不全为0或不全为1这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。比如：0.5（1&#x2F;2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为1.0*2^(-1)，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制表示形式为:0 01111110 00000000000000000000000\nE全为0这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。\nE全为1这时，如果有效数字M全为0，表示±无穷大``（正负取决于符号位s）；好了，关于浮点数的表示规则，就说到这里。\n\n有了这些知识，我们回到刚开始的题目：\n\n\n\n\n\n\n\n\n\n为什么 0x00000009 还原成浮点数，就成了 0.000000 ？\n\n首先，将 0x00000009 拆分，得到第一位符号位s&#x3D;0，后面8位的指数 E=00000000 ，最后23位的有效数字 M=000 0000 0000 0000 0000 1001。9 -&gt; 0000 0000 0000 0000 0000 0000 0000 1001由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：V=(-1)^0 × 0.00000000000000000001001×2^(-126)=1.001×2^(-146),显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是 0.000000 。\n\n\n\n\n\n\n\n\n\n再看例题的第二部分。请问浮点数9.0，如何用二进制表示？还原成十进制又是多少？\n\n首先，浮点数9.0等于二进制的1001.0，即1.001×2^3。那么，第一位的符号位s=0，有效数字M等于001后面再加20个0，凑满23位，指数E等3+127=130，即10000010。所以，写成二进制形式，应该是s+E+M，即: 0 10000010 001 0000 0000 0000 0000 0000 这个32位的二进制数，还原成十进制，正是   1091567616 。\n\n\n写在最后\n\n\n\n\n\n\n\n\n虽然数据在内存中的存储这一节知识不常用，但是他能让我们更深刻的理解内存和更严谨的写代码，可以说是一个程序员的必不可少基本功。\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"深度解析数据在内存中的存储","date":"2023-02-18T03:46:23.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"2e8c8f6bc22dd0fcb7353812a2e08717","title":"C语言指针练级攻略进阶级","content":"1. 字符指针\n\n\n\n\n\n\n\n\n字符指针顾名思义是指向字符的指针，如 char* p &#x3D; a(字符数组)。\n\n如下：char a[] &#x3D; “abcdef”;char* p1 &#x3D; a;char* p2 &#x3D; “abcdef”;\n\np1是一个字符指针，它指向的是a字符串的首元素的地址。p2是一个字符指针，它指向“abcdef”这样一个常量字符串的首元素地址。\n\n\n\n\n\n\n\n\n\n数组a与常量字符串“abcdef”的内容相同，但在内存中存在于两个不同的地方，数组a再内存中的栈区开辟，而常量字符串“abcdef”存在于内存中置放常量的地方，它只可以读，不可以更改。\n\n我们来看以下代码：\n\n#include &lt;stdio.h&gt;\nint main()\n&#123;\n    char str1[] &#x3D; &quot;hello bit.&quot;;\n    char str2[] &#x3D; &quot;hello bit.&quot;;\n    const char *str3 &#x3D; &quot;hello bit.&quot;;\n    const char *str4 &#x3D; &quot;hello bit.&quot;;\n    if(str1 &#x3D;&#x3D;str2)\n printf(&quot;str1 and str2 are same\\n&quot;);\n    else\n printf(&quot;str1 and str2 are not same\\n&quot;);\n       \n    if(str3 &#x3D;&#x3D;str4)\n printf(&quot;str3 and str4 are same\\n&quot;);\n    else\n printf(&quot;str3 and str4 are not same\\n&quot;);\n       \n    return 0;\n&#125;\n运行结果为:\n\n\n\n\n\n\n\n\n\nstr1 and str2 are not samestr3 and str4 are same\n这是因为str1与str2是两个数组，尽管他们的内容相同，但却开辟了两个不同的内存空间来存放，因此首元素的地址不相同；而str3和str4，他们都是指向一个常量字符串“abcdef”，这个字符串只存在一份，存放于常量区，因此他们两个都指向该常量字符串的首元素地址，所以相同。\n2. 指针数组\n\n\n\n\n\n\n\n\n数组有整型数组，字符数组等等，他们都是存放整型数据或者字符的，那么指针数组，很容易知道，他是一个存放指针的数组。\n\n指针数组的定义(以整型为例)：\n\n\n\n\n\n\n\n\nint* arr[size];\n\n\narr是一个数组，他的大小为size（可以存放size个元素），arr可以存放的元素的类型为 int* ，int* 是整型指针类型。\n\n作用\n\n\n\n\n\n\n\n\n\n指针数组可以存放若干个相同类型的指针，数组每个元素的地址的存放是连续的，但是数组中的每个元素可以指向别处地址的值，这使得指针数组的灵活性显著提高，并且每个指针指向的内容可以更改，宽泛来说也就更改了数组的内容（通过指针可以访问）。\n\n当然还有以下定义：\n\n\nchar *arr2[4]; &#x2F;&#x2F;一级字符指针的数组\nchar **arr3[5];&#x2F;&#x2F;二级字符指针的数组\n\n3. 数组指针\n\n\n\n\n\n\n\n\n字符指针他是一个指向字符的指针，那么数组指针顾名思义是一个指向数组的指针。\n\n数组指针的定义为(以整型数组为例)：\n\nint (*p)[10];\n&#x2F;&#x2F;解释：p先和*结合，说明p是一个指针变量，然后指着指向的是一个大小为10个整型的数组。所以p是一个指针，指向一个数组，叫数组指针。\n&#x2F;&#x2F;这里要注意：[]的优先级要高于*号的，所以必须加上（）来保证p先和*结合。\n\n\n\n&amp;arr 与 arr \n\n\n\n\n\n\n\n\n数组指针指向的是一个数组的地址，所以数组指针加减，其加减的步长是整个数组的字节大小，这里就牵涉到 &amp;arr 与 arr 的区别，**&amp;arr** 与 arr 以地址的形式打印出来可以发现是相同的，可是 &amp;arr+1 与 arr+1 却是不同的，这是因为 &amp;arr+1 他跳过的是整个数组，而 arr+1 则跳过一个元素。\n\n\n如下：\n\n数组指针的使用\n\n看如下代码：\n#include &lt;stdio.h&gt;\n\nvoid print_arr1(int arr[3][5], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot;%d &quot;, arr[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\nvoid print_arr2(int(*arr)[5], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot;%d &quot;, arr[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\nint main()\n&#123;\n\tint arr[3][5] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\n\tprint_arr1(arr, 3, 5);\n\t&#x2F;&#x2F;数组名arr，表示首元素的地址\n\t&#x2F;&#x2F;但是二维数组的首元素是二维数组的第一行\n\t&#x2F;&#x2F;所以这里传递的arr，其实相当于第一行的地址，是一维数组的地址\n\t&#x2F;&#x2F;可以数组指针来接收\n\tprint_arr2(arr, 3, 5);\n\treturn 0;\n&#125;\n运行结果为：\n\n\n\n\n\n\n\n\n\n可以看到，通过数组指针的运用，我们可以更加深刻的理解二维数组和灵活的操控二维数组。\n4. 数组传参和指针传参\n\n\n\n\n\n\n\n\n在写代码的时候难免要把 数组 或者 指针 传给函数，那函数的参数该如何设计呢？\n\n数组传参数组传参这里只考虑一维数组和二维数组传参\n\n\n\n\n\n\n\n\n\n\n一维数组传参(以整型为例)1.void test(int arr[]);2.void test(int* arr);\n二维数组传参(以整型为例)1.void test(int arr[row][col]);2.void test(int arr[][col]);3.void test(int (*arr)[col]);\n\n\n指针传参指针传参这里只考虑一级指针和二级指针传参\n\n\n\n\n\n\n\n\n\n\n一级指针传参(以整型指针为例)void test(int** point);\n二级指针传参(以整型指针为例)void test(int*** point);\n\n\n\n\n\n\n\n\n\n\n\n\n函数参数的设定一定要严谨，不然会导致一些莫名其妙的错误\n5. 函数指针\n\n\n\n\n\n\n\n\n通过前面的铺垫，很明显，函数指针是一个指向函数的指针。\n\n函数指针的定义\n\n\n\n\n\n\n\n\n\n\nint Add(int a, int b);int (*p)(int, int) = &amp;Add;（*p）表示 p 是一个指针，他指向 Add 这样一个参数为 （int， int） 的函数，这个函数的返回类型为 int 。\n\n函数名 和 &amp;函数名\n\n先看以下代码：\n#include &lt;stdio.h&gt;\n\nint Add(int a, int b)\n&#123;\n\treturn a + b;\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\tprintf(&quot;%d\\n&quot;, Add(a, b));\n\n\tint (*p1)(int, int) &#x3D; &amp;Add;\n\tprintf(&quot;%d\\n&quot;, (*p1)(a, b));\n\tprintf(&quot;%d\\n&quot;, p1(a, b));\n\n\tint (*p2)(int, int) &#x3D; &amp;Add;\n\tprintf(&quot;%d\\n&quot;, (*p2)(a, b));\n\tprintf(&quot;%d\\n&quot;, p2(a, b));\n\n\treturn 0;\n&#125;\n\n运行结果为：\n由上述代码可得：Add与&amp;Add性质相同，函数名就是函数的地址，所以上面的 p1，p2 可以解引用也可以不解引用直接来使用函数。\n6. 函数指针数组\n\n\n\n\n\n\n\n\n函数指针数组是一个数组，这个数组的每一个元素是一个函数指针。\n例如：\n\n\n\n\n\n\n\n\n\nint Add(int a, int b);int Sub(int a, int b);int (*p1)(int, int) = &amp;Add;int (*p2)(int, int) = &amp;Sub; ！int (*p[2])(int, int) = &#123; p1, p2 &#125;;！\n\n\n\n\n\n\n\n\n\n以上便是函数指针数组的定义，p 是一个数组，这个数组有两个元素，每个元素都是指针，每个指针都是指向参数为（int， int），返回类型为 int 的函数。\n运用函数指针数组的性质，我们可以将相同类型，类似功能的函数通过指针存放在一个数组里，这样可以更加快速简洁的使用各个函数的功能，如（计算器）。\n7. 指向函数指针数组的指针\n指向函数指针数组的指针是一个 指针\n指针指向一个 数组 ，数组的元素都是 函数指针;\n\n定义：\nvoid test(const char* str)\n&#123;\n printf(&quot;%s\\n&quot;, str);\n&#125;\nint main()\n&#123;\n &#x2F;&#x2F;函数指针pfun\n void (*pfun)(const char*) &#x3D; test;\n &#x2F;&#x2F;函数指针的数组pfunArr\n void (*pfunArr[5])(const char* str);\n pfunArr[0] &#x3D; test;\n &#x2F;&#x2F;指向函数指针数组pfunArr的指针ppfunArr\n void (*(*ppfunArr)[5])(const char*) &#x3D; &amp;pfunArr;\n return 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n由这可以知道，指针与数组和函数可以无限套娃下去，指向函数指针数组的指针其难度已经挺高的了，再套下去，估计就要长脑袋了。\n8. 回调函数\n\n\n\n\n\n\n\n\n回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。\n\n回调函数最显著的例子就是 qsort 函数：\n\n\n    qsort 函数中 compar 参数体现了回调函数的性质，其性质体现在 qsort 的内部函数当中，通过 compar 接受函数参数并且调用函数，表现出 中介（回调）  的功能， qsort 函数底层是运用快排来实现的，这里我运用冒泡来简单实现 qsort 函数。\nvoid Swap(char* buf1, char* buf2, size_t width)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; width; i++)\n\t&#123;\n\t\tchar tmp &#x3D; *buf1;\n\t\t*buf1 &#x3D; *buf2;\n\t\t*buf2 &#x3D; tmp;\n\t\tbuf1++;\n\t\tbuf2++;\n\t&#125;\n&#125;\n\nvoid bubble_sort(void* bese, size_t sz, size_t width, int (*cmp)(const void*, const void*))\n&#123;\n\tfor (size_t i &#x3D; 0; i &lt; sz - 1; ++i)\n\t&#123;\n\t\tfor (size_t j &#x3D; 0; j &lt; sz - 1 - i; j++)\n\t\t&#123;\n\t\t\tif(cmp(((char*)bese) + j * width, ((char*)bese) + (j + 1) * width) &gt; 0)\n\t\t\t&#123;\n\t\t\t\tSwap(((char*)bese) + j * width, ((char*)bese) + (j + 1) * width, width);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\ncmp 比较函数的实现需要自己通过自己的意向来完成。\n写在最后\n\n\n\n\n\n\n\n\n指针的重要性毋庸置疑，在数据结构当中，指针的运用也是相当多的，要想后面学习不那么困难，指针的学习尤为重要！\n感谢阅读本小白的博客，错误的地方请严厉指出噢！\n","slug":"C语言指针练级攻略进阶级","date":"2023-02-17T16:04:46.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"d7ca3649cd79eeb226e0042c9923bb21","title":"程序员最需要的技术-调试（代码均C语言为例）","content":"世界上第一个bug\n\n第一次被发现的导致计算机错误的飞蛾，也是第一个计算机程序错误。\n这只飞蛾就引生出了bug的概念。\nbug是在应用程序投入生产之前发现的错误。 导致程序工作不佳、生产错误结果或崩溃的编程错误。\n\n1.学会调试很重要1.1 调试是什么？\n\n\n\n\n\n\n\n\n调试（英语：Debugging &#x2F; Debug），又称除错，是发现和减少计算机程序或电子仪器设备中程序错误的一个过程。\n\n我们在写完程序后，时常会因为达不到预期效果而苦闷，可以说，代码出现了bug，那么我们如何去寻找程序的错误？\n调试是一个简单但又非常重要的技巧，有人说，程序员写代码只要20%的时间，而调试除错占用了80%的时间。这句话非常的形象。\n可以说调试就是一个尝试破案的过程，它能够找到导致程序运行效果不佳的错误。\n所有发生的事情都一定有迹可循，如果问心无愧，就不需要掩盖也就没有迹象了，如果问心有愧，就必然需要掩盖，那就一定会有迹象，迹象越多就越容易顺藤而上，这就是推理的途径。顺着这条途径顺流而下就是犯罪，逆流而上，就是真相。\n所以说一名优秀的程序员是一名出色的侦探。\n\n1.2 调试的基本步骤\n发现程序错误的存在；\n以隔离、消除等方式对错误进行定位确定错误产生的原因；\n提出纠正错误的解决办法；\n对程序错误予以改正，重新测试。\n\n2.Debug与Release\n\n\n\n\n\n\n\n\n\nDebug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。\nRelease 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。\n\n我们看以下这段代码：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint i &#x3D; 0;\n\tint arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\n\n\tfor (i &#x3D; 0; i &lt;&#x3D; 12; i++)\n\t&#123;\n\t\tarr[i] &#x3D; 0;\n\t\tprintf(&quot;hello!\\n&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n在Debug环境下，该程序运行结果为：\n\n而在Release环境下运行结果为：\n\n\n\n\n\n\n\n\n\n\n\n可以看到Release的优化使得程序运行没有报错而是正常运行，这体现了Release的特性，当然，Release的优化使得程序不能再进行调试，使得我们不能一步步侦察发现程序的错误所在。\n还有一点就是，Release版本文件进行优化后，其文件比Debug版本文件的大小小很多。\n\n3.调试的基本快捷键设置断点我们点击代码语句序号前的灰色部分便可以设置断点\nF5\n启动调试，经常用来直接跳到下一个断点处。\n\nF9\n创建断点和取消断点；\n断点的重要作用，可以在程序的任意位置设置断点；\n这样就可以使得程序在想要的位置随意停止执行，继而一步步执行下去。\n\nF10\n逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。\n\nF11\n逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部（这是最常用的）。\n\nctrl + F5\n开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用。\n\n\n\n\n\n\n\n\n\n\n以上这些基本的快捷键必须要掌握。\n4.调试的时候查看程序当前信息4.1  查看临时变量的值\n\n\n\n\n\n\n\n\n\n在调试开始之后，用于观察变量的值。\n调试开始后点击调试，在窗口处选择监视（1，2，3，4，随便点击一个），当然也可以选择自动窗口（程序自动显示出变化的量）。\n在监视窗口中，我们可以输入想观测量的信息从而进行观测。\n\n\n4.2 查看内存信息\n\n\n\n\n\n\n\n\n\n在调试开始之后，用于观察内存信息。\n用于观察变量在内存中的地址。\n用于观察变量此时的大小。\n\n\n4.3 查看调用堆栈\n\n\n\n\n\n\n\n\n\n通过调用堆栈，可以清晰的反应函数的调用关系以及当前调用所处的位置。\n可以观察函数的进栈和出栈。\n\n\n4.4 查看汇编信息\n\n\n\n\n\n\n\n\n\n在调试开始之后，有两种方式转到汇编： 1.第一种方式：右击鼠标，选择【转到反汇编】; 2.在调试窗口选项里可以进入。\n查看汇编信息可以让我们更加清楚在VS环境下程序是如何运行的（代码运行的顺序）。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n调试的时候查看程序当前的信息可以是我们更加的贴近代码运行的过程，从而使我们的思维更加的细化。\n5.如何写出好的代码\n\n\n\n\n\n\n\n\n* \n\n代码运行正常\nbug很少3. 效率高\n可读性高\n可维护性高6. 注释清晰\n文档齐全\n\n\n常见的coding技巧：\n使用assert\n尽量使用const\n养成良好的编码风格\n添加必要的注释\n避免编码的陷阱。\n\n\n\n\n示范：模拟实现库函数：strcpy\n\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nchar* my_strcpy(char* dest,const char* sor)\n&#123;\n\tassert(dest &amp;&amp; sor);\n\n\tchar* n &#x3D; dest;\n\twhile (*dest++ &#x3D; *sor++)\n\t&#123;\n\t\t;\n\t&#125;\n\n\treturn n;\n&#125;\n\nint main()\n&#123;\n\tchar arr1[1000] &#x3D; &quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&quot;;\n\tchar arr2[1000];\n\tprintf(&quot;开始的arr1：&quot;);\n\tprintf(&quot;%s\\n&quot;, arr1);\n\n\tprintf(&quot;请输入要复制过去的内容：\\n&quot;);\n\tgets(arr2);\n\n\tprintf(&quot;复制后的arr1：&quot;);\n\tprintf(&quot;%s\\n&quot;, my_strcpy(arr1, arr2));\n\n\treturn 0;\n&#125;\n\n\n注意： 1.要分析参数的设计（命名，类型），返回值类型的设计； 2.野指针和空指针的危害。\n\n6.编程常见的错误6.1 编译型错误\n\n\n\n\n\n\n\n\n直接看错误提示信息（双击），解决问题。或者凭借经验就可以搞定。相对来说简单。\n6.2 链接型错误\n\n\n\n\n\n\n\n\n看错误提示信息，主要在代码中找到错误信息中的标识符，然后定位问题所在。一般是标识符名不存在或者拼写错误。\n6.3 运行时错误\n\n\n\n\n\n\n\n\n借助调试，逐步定位问题。最难搞。\n温馨提示：\n\n\n\n\n\n\n\n\n\n做一个有心人，积累排错经验。\n讲解重点：\n\n\n\n\n\n\n\n\n\n介绍每种错误怎么产生，出现之后如何解决。\n总结\n\n\n\n\n\n\n\n\n\n一定要熟练掌握调试技巧。\n初学者可能80%的时间在写代码，20%的时间在调试。但是一个程序员可能20%的时间在写程序，但是80%的时间在调试。\n这里所讲的都是一些简单的调试。\n以后可能会出现很复杂调试场景：多线程程序的调试等。\n多多使用快捷键，提升效率。\n\n\n最重要的一点：当我们在看别人的代码看不懂时，一定要将其代码调试去仔细看看其中程序运行的量的变化过程，然后再思考总结，领悟别人的解题思维，这样才能将知识灌输到自己的大脑中，而不是看到不懂的或者是不会的就去问，当然好问也是一种技巧，但是一定是思考过的去问才能达到获知的效果！\n\n","slug":"程序员最需要的技术-调试（代码均C语言为例）","date":"2023-02-17T15:35:31.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"96e78203404f7982dd071e85a86cfcc4","title":"C语言指针练级攻略初级篇（2）","content":"前言\n\n\n\n\n\n\n\n\n紧跟上一章，这一章的指针相对较难一些，不过经过本章的学习，相信大家能够有所得\n一.二级指针\n上一章说的都是一级指针的应用，那么什么是二级指针呢？\n我们都知道，创建一个变量是需要在内存中开辟一个地址空间来存放的，那么指针（指针就是指针变量）也是如此，他也是一个变量，他也需要一个地址内存空间来存放，只不过这个空间放的是其他变量的地址。\n实际上，二级指针可以理解为就是指针的指针，也就是说，二级指针里放的是一级指针的地址。\n我们创建一个整型变量给个初始值，再将这个变量的地址交给一个指针变量，然后将这个指针的地址再传给另一个指针，那么这个指针就叫做二级指针。\n\n我们看以下代码：\nint a &#x3D; 10; &#x2F;&#x2F; 创建一个变量a，他需要在内存中占有一段空间\nint* pa &#x3D; &amp;a; &#x2F;&#x2F; pa为指针变量，他也需要一段空间来存放，但他里面放的是a的地址\nint** ppa &#x3D; &amp;pa; &#x2F;&#x2F; 同理，它里面放的是pa这个指针的地址\n\n\n》》 那么我们如何使用二级指针呢？\n\n由上述代码，我们都知道，对一级指针解引用操作可以找到a的值，并且能够修改a里面的值，同样的。对ppa解引用就能找到a的地址，因为指针变量pa存放的是a的地址，如下：\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\tint* pa &#x3D; &amp;a;\n\tint** ppa &#x3D; &amp;pa;\n\n\tprintf(&quot;%p\\n&quot;, &amp;a);\n\tprintf(&quot;%p\\n&quot;, pa);\n\tprintf(&quot;%d\\n&quot;, *pa);\n\n\tprintf(&quot;%p\\n&quot;, &amp;pa);\n\tprintf(&quot;%p\\n&quot;, ppa); &#x2F;&#x2F; ppa就是pa的地址\n\tprintf(&quot;%p\\n&quot;, *ppa); &#x2F;&#x2F; 对ppa解引用找到的是a的地址，因为pa里面存放的是a的地址\n\n\treturn 0;\n&#125;\n\n\n\n也就是说通过对ppa两次的解引用，我们可以找到a的值：\n\n\n\nppa的解引用过程：一次解引用找到的是a的地址，因为ppa是指向int 类型的指针，他指向int型的指针变量pa，而pa里面存放的是a的地址。二次解引用便通过a的地址找到a的值。\n\n二.指针数组\n指针数组他是数组还是指针呢？？？\n当然是数组。\n数组里的元素放的是指针，那这个数组就是指针数组。\n\n例如：\nint* arr[3] &#x3D; &#123;0&#125;;\n\n\n\n\n\n\n\n\n\narr是一个指针数组，他里面放了三个指针，每个指针是指向int类型的指针。\n那么我们如何使用二维数组，下面展示一个比较能够体现其作用的代码：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a[4] &#x3D; &#123; 1,2,3,4 &#125;;\n\tint b[4] &#x3D; &#123; 5,6,7,8 &#125;;\n\tint c[4] &#x3D; &#123; 9,10,11,12 &#125;;\n\tint* arr[3] &#x3D; &#123; a,b,c &#125;;\n\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; 3; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; 4; j++)\n\t\t&#123;\n\t\t\tprintf(&quot;%-2d &quot;, *(arr[i] + j)); &#x2F;&#x2F; arr[i][j] &#x3D;&#x3D;  *(arr[i] + j)\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n可以看到，指针数组arr里面有三个指针，他们分别指向数组a的首元素地址，数组b的首元素地址，数组c的首元素地址，后面我们相继打印每个数组的内容，我们利用  *(arr[i] + j) 来寻找到每个数组对应下标的内容，arr[i]表示找到指针数组对应下标的指针指向的首元素地址，+j表示指针偏移找到该数组后面的元素的地址，对整体解引用则为该指针对应的数组的对应下标的值。\n\n总结\n\n\n\n\n\n\n\n\n指针初阶就到这里，想必大家对指针的认识已有不少。我们都知道，灵活的利用指针可以大大提高程序的效率，所以这里我们需要针对性的练习来提高我们对指针的敏感度。\n","slug":"C语言指针练级攻略初级篇（2）","date":"2023-02-17T15:32:59.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"2aa79aad05ade9ad90a236a03dfb831e","title":"C语言指针练级攻略初级篇（1）","content":"前言\n\n\n\n\n\n\n\n\n\nC语言中指针可以说是最接近计算机的一种表达方式了，他是C语言中最难也最重要的一块，这就需要我们细心去学去体会指针的每一步效果，相信大家刚学指针时会有些许困惑，本章我们就来看看指针的初阶把。\n\n1.指针是什么？\n指针是一个值为内存地址的变量；\n指针提供一种以符号的形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。\n通俗来说，指针就是指针变量，他能存放一个地址。也可以说，指针就是地址。\n\n2.指针和指针类型\n首先我们得知道，内存中的地址是连续存放的，每一个内存单元占一个字节。在32位机器中，有32跟地址线，也就是说，cpu的寻址能力为2的32次方个地址，64为机器与32位机器大同小异，只不过64位的寻址能力更强了。\n由于32位机器每一次的寻址为32个比特位，也就是4个字节，所以指针变量的大小为4个字节。也就是说，在32位机器中，无论一个指针变量为何种类型，他的大小都是4个字节。在64位当中我们也很容易就可以推出，指针变量的大小为8个字节，这是基于机器来确定的。\n\n下面基于64位系统看看上述效果：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\tint* a1 &#x3D; &amp;a;\n\tchar* a2 &#x3D; (char*) &amp; a;\n\tshort* a3 &#x3D; (short*) &amp; a;\n\n\tprintf(&quot;%zd\\n&quot;, sizeof(a1));\n\tprintf(&quot;%zd\\n&quot;, sizeof(a2));\n\tprintf(&quot;%zd\\n&quot;, sizeof(a3));\n\n\treturn 0;\n&#125;\n很明显，在64位系统中，何种类型的指针他的大小都是8个字节。\n2.1.声明指针int a &#x3D; 10;\nint* pa &#x3D; &amp;a;\n\na的值为10，&amp;a为a的地址；\nint* pa表示pa是一个指针变量，int*表示pa是一个整型的指针变量；\n经过上述操作，pa里面存放了a的地址；\n这样我们便声明了一个指向a地址的指针变量pa。\n\n我们分别将a的地址和pa打印出来，可以发现两个地址是一样的：\n2.2.指针类型\n指针类型有int等类型，与定义一个变量使用的类型相同，那么指针类型对指针有什么作用呢？\n\n\n\n\n\n\n\n\n\n指针的类型决定了指针向前或者向后走一步有多大；\n比如一个int类型的指针，int的大小为4个字节，当指针加一时，指针在内存中跳过4个字节；\n同样的，一个char类型的指针，char的大小为1个字节，当指针加一时，指针在内存中跳过1个字节；\n总的来说，指针的类型提供了一个指针在内存中移动的视角，理解指针的类型可以使我们更精确的使用指针来改变某个值。\n\n\n\n例如：我们用一个char类型的指针来修改int类型数组里面的值\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[5] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tchar* parr &#x3D; (char*)arr;\n\tint i &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; 8; i++)\n\t&#123;\n\t\t*(parr + i) &#x3D; 0;\n\t&#125;\n\n\tfor (i &#x3D; 0; i &lt; 5; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n运行结果：0 0 3 4 5\n\n我们可以看到，数组arr的前面两个元素被改成了0，这是因为：parr是一个指向arr的char类型的指针，每当parr + 1时，指向arr首元素的地址跳一个字节，也就是说移动一个内存单元，而arr是一个整型的数组，它里面每个元素占四个字节，所以当parr移动7次后他才指向arr第三个元素的地址，当然，arr前面的两个元素被改为0。\n想要更明确的看到类型指针的作用，建议大家运用调试并查看内存的方法，这样效果会更加的明显，更能加深对指针类型的理解。\n\n3.野指针\n\n\n\n\n\n\n\n\n\n野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）\n\n3.1.野指针的成因3.1.1.指针未初始化例如：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint* p; &#x2F;&#x2F; 这里没有给一个初始地址（局部变量指针未初始化，默认为随机值）\n\t*p &#x3D; 20; &#x2F;&#x2F; 不知道修改了那一块内存\n\n\treturn 0;\n&#125;\n3.1.2.指针越界访问\n指针越界访问的问题一般出现在指针与数组的结合运用当中：\n\n#include &lt;stdio.h&gt;\nint main()\n&#123;\n    int arr[10] &#x3D; &#123;0&#125;;\n    int *p &#x3D; arr;\n    int i &#x3D; 0;\n    for(i&#x3D;0; i&lt;&#x3D;11; i++)\n   &#123;\n        *(p++) &#x3D; i;\n   &#125;\n    return 0;\n&#125;\n\n\n当指针指向的范围超出数组arr的范围时，p就是野指针\n\n3.1.3.指针指向的空间释放（不具体展开）\n解释：当你用指针指向一块空间后，这块空间在程序中中途释放了，而你指向这块空间的指针他还是指向这块空间，其地址没变，只不过说指针指向的这块空间它由原有确定的值变成不确定了，指针也变成了一个悬垂指针。\n\n这个现象在函数调用时会发生，例如：\n#include &lt;stdio.h&gt;\n\nint* test()\n&#123;\n\tint a &#x3D; 10;\n\treturn &amp;a;\n&#125;\nint main()\n&#123;\n\tint *p &#x3D; test();\n\n\tprintf(&quot;%d\\n&quot;, *p);\n\n\treturn 0;\n&#125;\n\n这里a的值在函数调用完后就被释放了，也就是说指针变量p最后指向a的那块空间是一个不确定的值。\n3.2.如何规避野指针\n指针初始化\n小心指针越界\n指针指向空间释放，及时置NULL\n避免返回局部变量的地址\n指针使用之前检查有效性\n\n4.指针运算4.1.指针+-整数\n指针加减整数在数组中有很明显的效果，下面以一段代码来说明：\n\n#include &lt;stdio.h&gt;\n\n#define value 5\n\nint main()\n&#123;\n\tint arr[value] &#x3D; &#123; 0 &#125;; &#x2F;&#x2F; arr里有五个元素，全初始化0\n\tint* parr;\n\tint i &#x3D; 0;\n\n\tfor (parr &#x3D; arr; parr &lt; &amp;arr[value]; i++) &#x2F;&#x2F; arr是数组名，为首元素地址，这里先将首元素地址交给指针变量parr\n\t&#123;\n\t\t*parr++ &#x3D; i; &#x2F;&#x2F; 指针从第一个元素开始++找到数组每一个元素的地址并将数组arr里的元素改变；\n\t&#125;\n\n\tfor (i &#x3D; 0; i &lt; value; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]); &#x2F;&#x2F; 打印改变后的arr\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n4.2.指针减指针\n指针减指针的前提是：两个指针要指向同一块空间；\n指针减指针的绝对值得到的是两个指针之间的元素个数。\n\n例如：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[5] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tint* parr1 &#x3D; arr;  &#x2F;&#x2F; parr1指向的是arr首元素的地址\n\tint* parr2 &#x3D; &amp;arr[5];  &#x2F;&#x2F; parr2指向的是(arr[4] &#x3D; 5)后面那一个元素的地址\n\n\tint sum &#x3D; parr2 - parr1; &#x2F;&#x2F; parr2 - parr1 得到的是整个arr数组的元素的个数 也是parr2与parr1 之间的元素个数\n\n\tprintf(&quot;%d&quot;, sum); &#x2F;&#x2F; 5\n\t&#x2F;&#x2F;  如果parr2指向的是 &amp;arr[4] 这个地址，那么结果为 4 \n\n\treturn 0;\n&#125;\n\n\n4.3.指针的关系运算我们看这两段代码：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[5] &#x3D; &#123; 0 &#125;;\n\tint* parr;\n\n\tfor (parr &#x3D; &amp;arr[5]; parr &gt; arr;)\n\t&#123;\n\t\t*--parr &#x3D; 0;\n\t&#125;\n\n\treturn 0;\n&#125;\n将代码简化后：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[5] &#x3D; &#123; 0 &#125;;\n\tint* parr;\n\n\tfor (parr &#x3D; &amp;arr[4]; parr &gt;&#x3D; arr; parr--)\n\t&#123;\n\t\t*parr &#x3D; 0;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n我们想象代码的运行过程和结果，第一段代码是用比数组地址大的地址来进行比较，而第二段代码最后是用比数组地址小的地址来进行比较，实际在绝大部分的编译器上是可以顺利完成任务的，然而我们还是应该避免第二种的写法，因为标准并不保证它可行。\n标准规定：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。\n\n5.指针和数组我们先来看一个例子：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[5] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tint* p &#x3D; &amp;arr[0];\n\tprintf(&quot;%p\\n&quot;, p);\n\tprintf(&quot;%p\\n&quot;, arr);\n\n\treturn 0;\n&#125;\n\n\n\n通过上面的展示，我们不难看出，数组名其实就是数组首元素的地址，那么据此我们结合前面所说知识就可以运用指针对数组进行一系列的访问。\n指针能有效地处理数组，数组表示法其实就是在变相地使用指针。\n\n例（1）：我们用指针来打印一个数组的元素：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[5] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tint* parr &#x3D; arr; &#x2F;&#x2F; arr为数组名是首元素地址，这里将首元素地址交给指针变量parr\n\tint i &#x3D; 0;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, *(parr + i)); &#x2F;&#x2F; 由首元素地址开始访问数组的每个元素地址并解引用操作打印\n\t&#125;\n\n\treturn 0;\n&#125;\n运行结果为：\n\n\n\n\n\n\n\n\n\n输出： 1 2 3 4 5\n例（2）：我们用指针来修改一个数组里的元素：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[5] &#x3D; &#123; 0 &#125;;\n\tint* p &#x3D; arr;\n\tint i &#x3D; 0;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\t*(p + i) &#x3D; (i + 1);\n\t&#125;\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n运行结果：\n\n\n\n\n\n\n\n\n\n输出：1 2 3 4 5\n总结\n\n\n\n\n\n\n\n\n\n指针我们不仅要学会，并且能够灵活的运用，这需要我们的基础知识与编程思维共同作用。\n本章只是指针初阶的一部分知识，但其已经为我们的指针打下了坚实的基础。学无止境，勇往直前！\n\n","slug":"C语言指针练级攻略初级篇（1）","date":"2023-02-17T15:30:00.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"dafd374449017f7aa00611ca0f3662e1","title":"关于C语言常见操作符的解析和使用","content":"前言\n\n\n\n\n\n\n\n\n\n我们在学习C语言时肯定会用到不同的操作符来完成我们的功能，本章便是这些操作符的介绍与具体使用。\n\n1. 算数操作符\n算数操作符有四种，他们分别为：\n\n\n\n\n\n\n\n\n\n加 “**+”，减 “-”，乘 “ * ”，除 “&#x2F;”， 取模 “%**” \n值得注意的是,在C语言中乘号用 “ * “ 表示, 除号用  “ &#x2F; “  表示。\n取模号 “ % “ 求的是余数,比如 5除3余2 ,那么2便是计算的结果。\n通俗易懂,通过我们的数学知识很清楚的知道他们的作用。\n\n\n\nint main()\n&#123;\n\tint a &#x3D; 20;\n\tint b &#x3D; 12;\n\t\n\tprintf(&quot;a + b &#x3D; %d\\n&quot;, a + b);\n\tprintf(&quot;a - b &#x3D; %d\\n&quot;, a - b);\n\tprintf(&quot;a÷b &#x3D; %d\\n&quot;, a &#x2F; b); &#x2F;&#x2F; 这里20除12等于1，他不会显示后面的小数，除非计算式两边至少有一个浮点数\n\tprintf(&quot;a×b &#x3D; %d\\n&quot;, a * b);\n\tprintf(&quot;a % b &#x3D; %d\\n&quot;, a % b); &#x2F;&#x2F; 这里20模12余数是8，结果便是8\n\n\treturn 0;\n&#125;\n\n\n值得注意的是,当计算式两边至少有一个浮点数的时候,相除才会计算出小数.\n\n2.移位操作符首先,我们来补充一个小知识:\n\n\n\n\n\n\n\n\n\n\n我们都知道,一个数在内存中是以二进制数来存放的,存放的是这个数的补码,那么什么是补码呢?\n一个数的二进制有原码,反码和补码,在计算中是用补码来计算的,而打印出来的是原码,这三个码之间有这样的关系,原码符号位不变,其它位按位取反得到反码,反码加一得到补码,而又补码要得到原码,反过来就是了.\n正数的原码反码补码相同,而负数则需要结果上面的计算来得到.\n由上可以得到,移位操作符,移位其实移的是在内存中储存的二进制数的补码.\n\n2.1. 左移操作符\n\n\n\n\n\n\n\n\n(&lt;&lt;) : 补码左移,左边抛弃,右边补0.\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\t&#x2F;&#x2F; a是一个整数所以他的原码，反码，补码相同\n    &#x2F;&#x2F; 原码：00000000000000000000000000001010\n    &#x2F;&#x2F; 反码：00000000000000000000000000001010\n    &#x2F;&#x2F; 补码：00000000000000000000000000001010\n\tint b &#x3D; 15;\n\tint c &#x3D; -5;\n\t&#x2F;&#x2F; c为负数\n\t&#x2F;&#x2F; 原码：10000000000000000000000000000101\n\t&#x2F;&#x2F; 反码：11111111111111111111111111111010\n\t&#x2F;&#x2F; 补码：11111111111111111111111111111011\n\t&#x2F;&#x2F; 左移后：11111111111111111111111111110110 \n\t&#x2F;&#x2F; 减一：11111111111111111111111111110101\n\t&#x2F;&#x2F; 取反得到计算后的原码：10000000000000000000000000001010 - （-10）\n\n\tprintf(&quot;%d\\n&quot;, a &lt;&lt; 1); &#x2F;&#x2F; 左移1 &#x2F;&#x2F; 00000000000000000000000000010100 - 20\n\tprintf(&quot;%d\\n&quot;, b &lt;&lt; 1); &#x2F;&#x2F; 左移1 &#x2F;&#x2F; 00000000000000000000000000010100 - 30\n\tprintf(&quot;%d\\n&quot;, c &lt;&lt; 1); &#x2F;&#x2F; 左移1\n\t&#x2F;&#x2F; 补码左移 右边补 0\n\t&#x2F;&#x2F; 00000000000000000000000000010100 - 20\n\n\treturn 0;\n&#125;\n\n\n\n不难看出,左移操作符具有乘以 2 的效果.\n\n2.2. 右移操作符\n\n\n\n\n\n\n\n\n(&gt;&gt;):右移操作符与左移操作符计算过程几乎相同,有一点不同的是,右移操作符分为算数右移和逻辑右移:\n\n算数右移: 左边补符号位,右边抛弃.\n逻辑右移: 左边补0,右边抛弃.\n通常来说进行右移时是逻辑右移.\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; -5;\n\n\tprintf(&quot;%d\\n&quot;, a &gt;&gt; 1); &#x2F;&#x2F; 5\n\tprintf(&quot;%d\\n&quot;, b &gt;&gt; 1); &#x2F;&#x2F; -3\n\t&#x2F;&#x2F; b计算过程\n\t&#x2F;&#x2F; 原码：10000000000000000000000000000101\n\t&#x2F;&#x2F; 反码：11111111111111111111111111111010\n\t&#x2F;&#x2F; 补码：11111111111111111111111111111011\n\t&#x2F;&#x2F; 右移：11111111111111111111111111111101\n\t&#x2F;&#x2F; 减一：11111111111111111111111111111100\n\t&#x2F;&#x2F; 取反：10000000000000000000000000000011\n\t&#x2F;&#x2F; 右移1后的数为 10000000000000000000000000000011 - （-3）\n\n\treturn 0;\n&#125;\n无论是左移还是右移,我们都不能移动负数为,如: a &gt;&gt; -1.\n3.位操作符同样的,位操作符也是对补码进行计算\n3.1 &amp;\n按位与是 : 如果两个二进制补码相同位数上有一个为零则为0,都为1则为1.\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; -5;\n\t&#x2F;&#x2F; 原：10000000000000000000000000000101\n\t&#x2F;&#x2F; 反：11111111111111111111111111111010\n\t&#x2F;&#x2F; 补：11111111111111111111111111111011\n\tint b &#x3D; 3;\n\t&#x2F;&#x2F; 原：00000000000000000000000000000011\n\t&#x2F;&#x2F; 补：00000000000000000000000000000011\n\n\t&#x2F;&#x2F; a &amp; b\n\t&#x2F;&#x2F; 补：11111111111111111111111111111011\n\t&#x2F;&#x2F; 补：00000000000000000000000000000011\n\t&#x2F;&#x2F; 有一个0则为0，都为1则1\n\t&#x2F;&#x2F; 得：00000000000000000000000000000011\n\t&#x2F;&#x2F; 为整数：3\n\tprintf(&quot;%d&quot;, a &amp; b);\n\n\treturn 0;\n&#125;\n\n3.2 |\n按位或是 : 如果两个二进制补码相同位数上只要有一个为1则为1,全0则0.\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\t&#x2F;&#x2F; 补：00000000000000000000000000001010\n\tint b &#x3D; -2;\n\t&#x2F;&#x2F; 原：10000000000000000000000000000010\n\t&#x2F;&#x2F; 反：11111111111111111111111111111101\n\t&#x2F;&#x2F; 补：11111111111111111111111111111110\n\n\t&#x2F;&#x2F; a | b\n\t&#x2F;&#x2F; 00000000000000000000000000001010 \n\t&#x2F;&#x2F; 11111111111111111111111111111110\n\t&#x2F;&#x2F; 11111111111111111111111111111110 结果\n\t&#x2F;&#x2F; 减一：11111111111111111111111111111101\n\t&#x2F;&#x2F; 取反：10000000000000000000000000000010 （-2）\n\tprintf(&quot;%d&quot;, a | b); &#x2F;&#x2F; -2\n\n\treturn 0;\n&#125;\n\n3.3 ^\n按位异或是：相同为0，相异为1.\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 3;\n\t&#x2F;&#x2F; 补：00000000000000000000000000000011\n\tint b &#x3D; 5;\n\t&#x2F;&#x2F; 补：00000000000000000000000000000101\n\n\t&#x2F;&#x2F; a ^ b\n\t&#x2F;&#x2F; 00000000000000000000000000000011\n\t&#x2F;&#x2F; 00000000000000000000000000000101\n\t&#x2F;&#x2F; 00000000000000000000000000000110 - 6\n\tprintf(&quot;%d\\n&quot;, a ^ b); &#x2F;&#x2F; 6\n\tprintf(&quot;%d\\n&quot;, a ^ 0); &#x2F;&#x2F; a\n\tprintf(&quot;%d\\n&quot;, b ^ 0); &#x2F;&#x2F; b\n\tprintf(&quot;%d\\n&quot;, a ^ a); &#x2F;&#x2F; 0\n\n\treturn 0;\n&#125;\n\n\n值得注意的是：\na ^ 0 &#x3D; a;\nb ^ 0 &#x3D; b;\na ^ a &#x3D; 0;\n那么可以得到：\na ^ a ^ b &#x3D; b;\nb ^ b ^ a &#x3D; a;\n\n\n\n\n\n\n\n\n有一道经典题目：不创建临时变量交换两个变量的值。我们便可以用上述推理来实现\n\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;82c60be1cb6f4fc0b0a5b41971123922.png#pic_center)\n\n\tint a &#x3D; 3;\n\tint b &#x3D; 5;\n\n\tprintf(&quot;交换前：%d %d\\n&quot;, a, b);\n\n\ta &#x3D; a ^ b;\n\tb &#x3D; a ^ b;\n\ta &#x3D; a ^ b;\n\n\tprintf(&quot;交换后：%d %d\\n&quot;, a, b);\n\n\treturn 0;\n&#125;\n\n3.4 ~按位取反是补码二进制位如果是1则变为0，如果是0则变为1。\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 3;\n\t&#x2F;&#x2F; 补：00000000000000000000000000000011\n\t&#x2F;&#x2F; 反：11111111111111111111111111111100  补码变负\n\t&#x2F;&#x2F; -1：11111111111111111111111111111011\n\t&#x2F;&#x2F; 原：10000000000000000000000000000100  -4\n\tprintf(&quot;%d&quot;, ~a);\n\n\treturn 0;\n&#125;\n\n\n4.赋值操作符\n&#x3D;例如：a &#x3D; 5,这里将5赋值给变量a\n\n复合型：\n\n+&#x3D;  \n\n-&#x3D;\n\n&#x2F;&#x3D;\n\n*&#x3D;\n\n%&#x3D;\n\n&amp;&#x3D;\n\n|&#x3D;\n\n^&#x3D;\n\n（&lt;&lt;&#x3D;）\n\n（&gt;&gt;&#x3D;）例如：a+&#x3D;2其实就是a&#x3D;a+2,其他的复合型都是如此\n\n\n5.单目操作符\n\n\n\n\n\n\n\n\n  -            负值\n  +            正值\n  ++           a++：后置加加  ; ++a：前置加加（都是a+=1）\n  --           与++效果相同\n  !            逻辑反操作\n  &amp;            取地址符号\n  ~            二进制数按位取反\n  *            解引用操作\n  sizeof       求类型长度（以字节为单位）\n  (类型)        强制类型转换\n\n这里对++和！作讲解\n++ 首先看代码：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 1;\n\tint b &#x3D; a++; &#x2F;&#x2F; 先把a的值赋给b，a再自增1\n\tint c &#x3D; ++a; &#x2F;&#x2F; a先自增1，再赋值给c\n\n\tprintf(&quot;%d\\n&quot;, a); &#x2F;&#x2F; 3\n\tprintf(&quot;%d\\n&quot;, b); &#x2F;&#x2F; 1\n\tprintf(&quot;%d\\n&quot;, c); &#x2F;&#x2F; 3\n\n\treturn 0;\n&#125;\n前置加加和后置加加其实在上述代码里其实效果很明显了，只要我们用一次++，其对应变量就要自增1。–与++的运用效果是相同的，只不过说是自减1。\n！：!&#x3D; 就是不等于，其相当于非。!0 就是真，!1就是假。\n6.关系操作符\n(&gt;)\n(&gt;&#x3D;)\n(&lt;)\n(&lt;&#x3D;)\n(!&#x3D;)\n(&#x3D;&#x3D;)\n\n上述操作符多用在判断语句中，用来决定程序进程变化。\n7.逻辑操作符&amp;&amp;\n\n\n\n\n\n\n\n\n逻辑与：如 a&amp;&amp;b ，当a,b都为真时，表达式为真，当其中有一个为假时为假\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 1;\n\tint c &#x3D; 2;\n\tint d &#x3D; 3;\n\tint i &#x3D; a++ &amp;&amp; ++b &amp;&amp; c++; &#x2F;&#x2F; a++表达式结果为a的值，此时a&#x3D;0,由&amp;&amp;的性质有一个为假就为假，则后面都不计算了\n    &#x2F;&#x2F;但是a++还是要进行计算的，也就是a要自增1\n\tprintf(&quot;%d %d %d %d\\n&quot;, a, b, c, d);\n    &#x2F;&#x2F; 结果为 1 1 2 3\n\treturn 0;\n&#125;\n\n||\n\n\n\n\n\n\n\n\n逻辑或：如 a || b，当a，b中只要有一个为真，表达式为真，都为假表达式才为假\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 1;\n\tint b &#x3D; 2;\n\tint c &#x3D; 3;\n\tint d &#x3D; 4;\n\tint i &#x3D; a++ || b++ || ++d || c--; &#x2F;&#x2F; a++表达式结果为a，此时a&#x3D;1为真，由||性质，整个表达式结果为真，则后面的不计算了\n\t&#x2F;&#x2F; a++还是要计算的，也就是a要自增1\n\n\tprintf(&quot;%d %d %d %d\\n&quot;, a, b, c, d);\n\t&#x2F;&#x2F; 结果为 2 2 3 4\n\n\treturn 0;\n&#125;\n\n结合我们可以通过判断闰年这个经典的题目来熟悉掌握&amp;&amp; ||。\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tif (((n % 4 &#x3D;&#x3D; 0) &amp;&amp; (n % 100 !&#x3D; 0)) || (n % 400 &#x3D;&#x3D; 0))\n\t&#123;\n\t\tprintf(&quot;%d年是闰年！\\n&quot;, n);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;%d不是闰年！\\n&quot;, n);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n8.条件操作符\n\n\n\n\n\n\n\n\nexp1 ？ exp2：exp3;\n\n如果 exp1 为真，表达式结果为 exp2\n如果 exp1 为假，表达式结果为 exp3\n\n例如求两个变量的最大值：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\n\tprintf(&quot;max &#x3D; %d\\n&quot;, (a &gt; b ? a : b));\n\n\treturn 0;\n&#125;\n\n9.逗号表达式\n\n\n\n\n\n\n\n\n\n优先级最低\n用逗号隔开多个表达式\n整个表达式由左向右依次计算，计算结果为最后一个表达式的结果\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 1;\n\tint b &#x3D; 2;\n\n\tint c &#x3D; (a +&#x3D; 2, b &#x3D; b + 1, a +&#x3D; 1, a &#x2F; 2);\n\n\tprintf(&quot;%d&quot;, c); &#x2F;&#x2F; 2\n\n\treturn 0;\n&#125;\n我们可以看到从左向右依次计算，最后a &#x3D; 4，4 &#x2F; 2 &#x3D; 2，所以最后c的值为2；\n10.表达式求值10.1.隐式类型转换\n\n\n\n\n\n\n\n\nCPU在进行运算的时候一般使用整形int，所以在有些时候，当一个小于整形的类型进行计算时，计算机就会先进行整形提升再进行运算，这就是隐式类型转换。\n（通用CPU是难以直接实现两个非整形的直接相加运算）\n例：\n&#x2F;&#x2F; char short int long ...\n&#x2F;&#x2F;  1     2    4\nint main()\n&#123;\n\t&#x2F;&#x2F;char --&gt; signed char\n\tchar a &#x3D; 3;\n\t&#x2F;&#x2F;截断\n\t&#x2F;&#x2F;00000000000000000000000000000011\n\t&#x2F;&#x2F;00000011 - a\n\t&#x2F;&#x2F;\n\tchar b &#x3D; 127;\n\t&#x2F;&#x2F;00000000000000000000000001111111\n\t&#x2F;&#x2F;01111111 - b\n \n\tchar c &#x3D; a + b;\n\t&#x2F;&#x2F;00000011\n\t&#x2F;&#x2F;01111111\n\t&#x2F;&#x2F;整型提升\n\t&#x2F;&#x2F;00000000000000000000000000000011 - a\n\t&#x2F;&#x2F;00000000000000000000000001111111 - b\n\t&#x2F;&#x2F;00000000000000000000000010000010 - a + b &#x3D;c\n\t&#x2F;&#x2F;截断\n\t&#x2F;&#x2F;10000010 - c\n\tprintf(&quot;%d\\n&quot;, c);\n\t&#x2F;&#x2F;%d 是打印十进制的整数\n\t&#x2F;&#x2F;11111111111111111111111110000010 - 补码\n\t&#x2F;&#x2F;11111111111111111111111110000001 - 反码\n\t&#x2F;&#x2F;10000000000000000000000001111110 - 原码\n\t&#x2F;&#x2F;-126\n\treturn 0;\n\t&#125;\n\n————————————————\n版权声明：本文为CSDN博主「戊子仲秋」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;Locky136&#x2F;article&#x2F;details&#x2F;127812345&#x3D;\n输出结果：\n\n\n\n\n\n\n\n\n\n输出：-126\n注：\nchar：\n有符号的char的取值范围是：-128~127\n无符号的char的取值范围是：0~255\n\n以上是一位大佬的讲解（写的很详细），这里直接引用他的，大家可以多看看他的博客，一定会有很大的帮助的。                                                      ——@戊子仲秋\n\n10.2.算数转换long double：最高↑double↑float unsigned long int↑long int↑unsigned int↑int\n\n当我们再利用两个不同类型的变量来进行计算时，其算数级低的会自动升级到算数级高的类型去进行计算，如果进行一些不正当的算数转换，会导致数据丢失。\n\n如：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tfloat e &#x3D; 2.717f;\n\tint w &#x3D; e;\n\n\tprintf(&quot;%d&quot;, w);\n\n\treturn 0;\n&#125;\n运行结果为：\n\n\n\n\n\n\n\n\n\n输出： 2\n可以看到，e值小数点后面的数丢失了，这是由高级到低级转换的结果（不能用）\n11.操作符的准确使用\n操作符之间有其对应的优先级，当我们进行运算时，优先比较相邻两个操作符的优先级，如果一个表达式很复杂，简易用（）来分明其运算顺序，不然在不同的编译器上可能会有不同的运算结果。\n\n总结\n\n\n\n\n\n\n\n\nC语言中操作符的使用可以说是司空见惯的，如何正确的使用是我们必须掌握的，学到后面，我们可以尝试着巧妙运用操作符去解决一些复杂的问题，这需要我们不断地练习与巩固。在此，感谢大家的阅读！\n","slug":"关于C语言常见操作符的解析和使用","date":"2023-02-17T14:40:44.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"b82bfb4a02f130e6ce0f96366fdc8a1f","title":"一文带你灵活使用C语言的数组","content":"一. 什么是数组？\n\n\n\n\n\n\n\n\n\n数组是由数据类型相同的一系列元素组成的。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确的创建数组。普通变量可以使用的类型，数组元素都可以使用。\n\n二. 一维数组1. 一维数组的创建和初始化1.1. 一维数组的创建int arr[4];\n上面便创建了一个整型数组：\n\nint 是数组的类型，在这里是整型。\narr 是数组名。\n[] 是下标引用操作符也是数组的标志，这里我们在里面给上一个4，代表一个数组名为arr的整型数组里面放了四个元素。\n\n值得注意的是，我们在定义数组时，[] 里的必须是一个常量表达式（const），这是C99标准之前规定的。也就是说，如果我们在前面创建一个整型变量给个初始值10，在创建数组时[]里放的是这个整型变量的变量名，这样编译器会报错，在语法上也是不支持的（C99标准之前）。\n当然，我们还可以用宏定义一个常量来作为数组[]里的表达式从而创建一个数组：\n#include &lt;stdio.h&gt;\n\n#define num 100 \n\nint main()\n&#123;\n\tint arr[num]; &#x2F;&#x2F; 这里是支持这样去创建的\n\n\treturn 0;\n&#125;\n\n\n1.2. 一维数组的初始化\n首先我们要知道什么是数组的初始化？也就是说，在我们创建了一个数组后，给数组一个{0}，或者把这个数组填满，这都可以算作数组初始化。\n我还是建议大家在创建一个数组后能够给数组初始化，这样在后面使用时，就不会出现一些奇奇怪怪的值。这是因为，当你在给一个元素个数为4的整型数组初始化{0}后，你去打印这个数组，他会默认你这数组的四个元素都为0，不然就是一些很奇怪的随机值。\n如果不指定数组大小而给数组某些值，那么这个数组的大小会根据你给的这些值的个数来确定。\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[4] &#x3D; &#123; 0 &#125;;\n\n\treturn 0;\n&#125;\n\n\n\n如果一个整型数组它初始化不完全，那么没初始化的元素他也会默认为零：\n\nint main()\n&#123;\n\tint arr[4] &#x3D; &#123; 1 ,2 &#125;;\n\n\treturn 0;\n&#125;\n\n\n当然，其它类型的初始化也是一样（char等）。\n\n2. 一维数组的使用\n这里首先讲解一下[]操作符，它名为下标引用操作符。在创建一个数组时，它是数组的标志，也起定义数组大小的作用。在使用一个数组时，他的作用便是下标引用了。值得注意的是，数组的下标是这个元素从左往右数的位数减一，也就是说数组的下标是从零开始的，第一个元素的下标为0，第二个元素的下标为1，以此类推。所以我们在使用数组时，一定要注意下标的使用是否正确，避免出现数组下标越界的问题。\n\n以下是一维数组的初级使用（创建—打印）：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[4] &#x3D; &#123; 1, 2, 3 ,4 &#125;;\n\tint i &#x3D; 0;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d&quot;, arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n我们可以看到，打印一维数组时用了一个循环。\n上述代码中使用了sizeof来求数组的长度，sizeof其实是求数组字节的大小，一个整型为4个字节，而数组arr里有4个整型，那么大小为16，后面除上这个数组的第一个元素的字节大小（4），结果为4，这样求数组大小可以避免一些数组元素过多的问题。并且数组的长度计算还会在你改变这个数组时而改变，可以说非常方便，这是一个常用的求数组长度的方法，希望大家牢记。\n\n3.一维数组在内存中的存储\n一维数组在内存中的存储是连续的，地址由低到高，这里放段代码来展示其效果：\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[4] &#x3D; &#123; 1, 2, 3, 4 &#125;;\n\tint i &#x3D; 0;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;&amp;arr[%d] &#x3D; %p\\n&quot;, i， &amp;arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n我们可以看到，这四个元素的地址是连续的，他们之间相差4，是因为一个整型为四个字节，当一个整型值在内存中存储时，内存会开辟四个单元空间（每个单元为一个字节并且对应一个地址）用来存放这个整型值，所以在一个整型数组中也是如此，他们每个整型元素相差4。\n\n三. 二维数组1. 二维数组的创建和初始化1.1. 二维数组的创建int arr[2][3];\n\n上面便创建了一个二维数组，它形式上就是比一维数组多了一个[]。\n这里直接说明，二维数组和一维数组的通性是一样的，上述arr[2][3]，通俗来说，2表示这个二维数组有两行（两条），3表示每一行（每一条）有几列（也就是几个元素），所以我们可以认为，arr[2][3]其实就是由两个arr[3]构成的。所以我们说二维数组其实就是一维数组。\n\n1.2. 二维数组的初始化\n二维数组的初始化与一维数组的初始化大同小异，但二维数组它是分行和列的，因此二维数组的初始化又有不同。\n\nint arr[2][3] &#x3D; &#123; &#123;1,2,3 &#125;, &#123;4, 5, 6&#125; &#125;;\n\na.这里函数大小与初始化大小相同，所以这段代码表示第一个大括号表示为数组的第一行，第二个大括号表示为数组的第二行，而这里只有两行，其中每一行有三个元素（每行三列）。这是最为正确且直观的初始化方式。\nint arr[2][3] &#x3D; &#123; 1,2,3,4,5,6 &#125;;\n\nb.这里没有打大括号,但其与a展现的效果是相同的，他会自动将数组的前三个元素作为第一行，后三个元素最为第二行，这样不是很好读。\nint arr[2][3] &#x3D; &#123; 1,2,4,5,6 &#125;;\n\nc.这段代码数组初始化的元素个数就少于整个数组的元素个数的大小了，所以前三个元素还是默认第一行，后两个元素默认第二行，但最后一个没给的值默认为零（没有大括号的情况）。\nint arr[2][3] &#x3D; &#123; &#123;1,2 &#125;, 4, 5, 6 &#125;;\n\nd.这里给了大括号之后，则前面两个元素为第一行，后三个为第二行。当在打印数组内容时，第一行空缺的元素会默认为零打印。\n\n值得注意的是，二维数组在初始化的时候，行可以省略，但列不能省略，因为由列可以确定你这一行，而行缺失了列的限制就无从初始化了。\n\n2. 二维数组的使用先展示代码来表达效果：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[2][3] &#x3D; &#123; &#123;1,2 &#125;, 4, 5, 6 &#125;;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; 2; i++) &#x2F;&#x2F; 打印每行\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; 3; j++) &#x2F;&#x2F; 打印这一行的每一列\n\t\t&#123;\n\t\t\tprintf(&quot;%d &quot;, arr[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;); &#x2F;&#x2F; 每打印一行换行\n\t&#125;\n\n\treturn 0;\n&#125;\n\n我们可以看到，打印一个二维数组要用到两个循环（循环之间为嵌套关系），使用二维数组可以达到一个版面的效果，在前面三子棋和扫雷的使用效果会更明显。\n3. 二维数组在内存中的存储\n我们说二维数组其实就是由一维数组构成的，所以二维数组在内存中的储存，可以说几乎与一位数组相同。\n二维数组在内存中的储存也是连续的，他每一行的地址紧跟在前一行的地址后面，地址由低到高：\n\n四. 多维数组\n\n\n\n\n\n\n\n\n\n前面讨论的二维数组的相关内容都适用于三维数组或者更多维的数组。可以这样声明一个三维数组int arr[10][20][30];\n我们可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。例如，把上面声明的三维数组arr想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来。\n还有一种理解arr的方法是，把arr看作数组的数据。也就是说，arr内含10个元素，每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。或者，可以简单地根据所需的下标值去理解数组。\n通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循环。对于其它多维数组，以此类推。一般来说，我们只会使用到二维数组。\n\n———————————————————《C primer plus》\n五. 数组和指针（初级）1.1. 指针在数组中的使用\n指针是提供一种以符号形式使用地址方法，因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。数组表示法其实是在变相地使用指针。\n\n数组名其实就是首元素的地址，&amp;arr[0]与arr的效果相同,但&amp;arr与他俩又不相同，他是整个数组的地址，下面是代码的展示效果：\n\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tprintf(&quot;%p\\n&quot;, arr);\n\tprintf(&quot;%p\\n&quot;, &amp;arr[0]);\n\tprintf(&quot;%p\\n&quot;, &amp;arr);\n\tprintf(&quot;\\n&quot;);\n\tprintf(&quot;%p\\n&quot;, arr + 1); &#x2F;&#x2F; 数组名+1\n\tprintf(&quot;%p\\n&quot;, &amp;arr[1]); &#x2F;&#x2F; 第二个元素的地址\n\tprintf(&quot;%p\\n&quot;, &amp;arr + 1); &#x2F;&#x2F; 整个数组地址+1\n\n\treturn 0;\n&#125;\n\n\n我们可以看到（&amp;arr + 1）它跳过的是整个数组的地址，而（arr + 1）只数组中第二个元素的地址。\n\n以下是指针在数组中的具体的使用：\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tint arr1[] &#x3D; &#123; 1,2,3,4 &#125;;\n\tchar arr2[] &#x3D; &quot;abcd&quot;;\n\tint i &#x3D; 0;\n\n\tint sz1 &#x3D; sizeof(arr1) &#x2F; sizeof(arr1[0]);\n\tint sz2 &#x3D; strlen(arr2);\n\n\tint* p1 &#x3D; arr1;\n\tchar* p2 &#x3D; arr2;\n\n\tfor (i &#x3D; 0; i &lt; sz1; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, *p1 + i); &#x2F;&#x2F; 解引用操作找到对应元素打印\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\tfor (i &#x3D; 0; i &lt; sz2; i++)\n\t&#123;\n\t\tprintf(&quot;%c &quot;, *p2 + i);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n运行结果：\n1.2. 函数，数组与指针\n当我们在调用函数时，想传递一个数组过去，我们直接传递数组名就行了，因为数组名就是数组首元素的地址，所以当函数接受时需要一个指针来接收传递过来的地址，值得注意的是，在函数接受时，用类型加数组而不用指针也是可以的，这两个的效果是相同的，例：\n\n#include &lt;stdio.h&gt;\n\nvoid print(int* arr, int sz)\n&#123;\n\tint i &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\tprint(arr, sz);\n\n\treturn 0;\n&#125;\n\n\n#include &lt;stdio.h&gt;\n\nvoid print(int arr[], int sz)\n&#123;\n\tint i &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\tprint(arr, sz);\n\n\treturn 0;\n&#125;\n\n可以看到， 函数形参接受时的两种方式是等效的。\n六. 变长数组概述\n\n\n\n\n\n\n\n\n\n变长数组实际上就是数组[]里可以放变量表达式，在Linux环境下gcc可以使用，不过要注意的是，这样创建一个数组是不能初始化的。当然支持C99标准的编译器底下也可以这样使用。\n\n七. 总结\n\n\n\n\n\n\n\n\n\n数组的灵活运用可以高效地解决一些比较困难的问题，它可以很好地训练我们的编程思维。\n我们在使用数组时最好是要运用指针来操作，这样程序会更高效，占用内存会更少。\n\n","slug":"一文带你灵活使用C语言的数组","date":"2023-02-17T14:38:44.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"fc86da1651adc032c38c6b773ee69698","title":"使用C语言实现初级扫雷小游戏","content":"一. 前言\n\n\n\n\n\n\n\n\n\n本章我们用C语言简单实现一个9×9雷阵的扫雷小游戏。\n说到扫雷想必大家都不陌生，开始我们点击一个小方块，那么这个小方块上会显示它周围八个小方块里雷的个数，凭借这个数值，在判断下一个要扫的位置（当然可能前面两步需要我们的幸运成分了），当我们除雷外的所有小方块都已经显示完了，那么扫雷成功。\n这里我们分框架（框架代码在主函数中）展示游戏的实现。\n游戏实现我们分装两个 .c （代码主函数与函数定义源代码）后缀的文件和一个 .h 的文件（头文件，函数声明）\n.h : game.h.c : test.c (主函数体文件) |||||| game.c (函数定义文件)\n\n\n\n这里我们先把头文件里的库函数，函数声明和定义的全局常量以及主函数的函数调用结构展示出来，以便后面有迹可循：\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 9\n#define COL 9\n#define ROWS ROW + 2\n#define COLS COL + 2\n#define MINE_COUNT 10\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret);\n\nvoid print_board(char board[ROWS][COLS], int row, int col);\n\nvoid add_mine(char board[ROWS][COLS], int row, int col);\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);\n\n#define _CRT_SECURE_NO_WARNINGS\n\n&#x2F;&#x2F; 1.初始化雷盘与扫雷盘\n&#x2F;&#x2F; 2.打印盘\n&#x2F;&#x2F; 3.布置雷\n&#x2F;&#x2F; 4.扫雷\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  1.PLAY  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  0.EXIT  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar mine[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\tchar show[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F; 初始化盘\n\tinit_board(mine, ROWS, COLS, &#39;0&#39;);\n\tinit_board(show, ROWS, COLS, &#39;*&#39;);\n\t&#x2F;&#x2F; print_board(mine, ROW, COL);\n\tprint_board(show, ROW, COL);\n\t&#x2F;&#x2F; 布置雷\n\tadd_mine(mine, ROW, COL);\n\tprint_board(mine, ROW, COL);\n\n\t&#x2F;&#x2F; 扫雷\n\tdown_mine(mine, show, ROW, COL);\n&#125;\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入扫雷游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tprintf(&quot;游戏结束：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tSleep(1000);\n\t\t\tsystem(&quot;cls&quot;);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\n\n\n只要我们分别在另外两个 .c 文件（一个是主函数体一个是函数定义）中引入（#include “game.h”） 那么三个文件就相互作用了。\n\n二. 游戏版面与开始游戏的构建\n我们首先要打印一个菜单供玩家选择&lt;输入1&gt;则进入游戏，&lt;输入0&gt;则退出游戏，&lt;输入其它的数&gt;则输入错误，然后继续输入判断。为了一开始就让用户先选择，再判断输入的值然后判断是否再次输入，这里我们采用do-while循环结构，无论如何用户先选择一次，然后do-while里头采用switch-case来判断输入的值，而菜单我们调用一个menu（）函数来打印，下面是在主函数里的代码实现：\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  1.PLAY  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  0.EXIT  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n&#125;\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入扫雷游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tprintf(&quot;游戏结束：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\n\n\n\n我们可以看到， 这样简易的游戏初始菜单就制作好啦。\n\n三. 扫雷初始化思路\n\n\n\n\n\n\n\n\n\n由上方雷盘可以看到是一个9×9的格子，但是我们在写程序时，如何能够判断9×9边边格子的周围八个格子雷的个数？如果我们定义一个二维数组只给它9行9列这样一个起始雷盘，当我们在扫边边格子的雷的时候，我们可能会需要一些复杂的计算来完成相关的程序，所以，为了更好的简易化以及能够精确判断每个格子周围的雷，我们在雷盘两边再加上两行两列，也就是说，我们定义的二维数组他应该是要11行11列这样的起始雷盘。\n我们游戏的雷盘是9×9的，但我们定义的二维数组是11×11的，所以，当我们在玩游戏时，被扫的雷盘的打印应该少去上下两行和左右两列。\n对于程序来说，我们是否能够将布置雷盘与扫雷放在一个盘里实现呢？答案是不能的，所以这里我们要定义两个二维数组，一个用来放雷的盘不打印，另一个用来排查雷的盘要打印，并且，这两个盘之间一定要能通过某种联系来相互作用（雷盘传雷位置，扫雷盘接受，扫时能够准确定位周围雷的个数）。\n这里我们设定，雷用字符 ‘1’ 来表示，其余地方为字符 ‘0’ ，刚开始初始化盘时，要布置雷的盘先全部元素放 ‘0’ ，用来扫雷的盘全部元素放字符 ‘ * ’ ，但是我们打印时，只打印9×9那块的区域（游戏版面设定）。\n\n四. 雷阵与扫雷盘初始化*由上说到，雷阵我们先全部放入字符 ‘0’ 初始化，扫雷盘全初始化字符 ‘ * ’，由于两个盘的数组大小相同，为了减少代码量，这里写个初始化函数调用两次（雷阵初始化的调用和扫雷盘初始化的调用），所以我们需要传参每个盘的初始化内容（字符）。以下是代码实现：\ninit_board(mine, ROWS, COLS, &#39;0&#39;); &#x2F;&#x2F; 雷阵的初始化\ninit_board(show, ROWS, COLS, &#39;*&#39;); &#x2F;&#x2F; 扫雷盘的初始化\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret) &#x2F;&#x2F; 接收传来的初始化字符\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; rows; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; cols; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; ret; &#x2F;&#x2F; 初始化\n\t\t&#125;\n\t&#125;\n&#125;\n\n五. 打印扫雷盘\n在我们玩扫雷游戏中，其显示的是9×9的格子，所以我们打印的扫雷盘也是要9×9的格子（尽管初始化二维数组为11×11，那是因为便于计算扫的周围那个格子周围的雷数），但是为了玩家更好的看清楚想要扫的格子的坐标，这里在打印的每行每列开头都标上序号，这样就不用去数格子了。\n以下是打印出来的效果：以下是代码实现：\n\nprint_board(show, ROW, COL); &#x2F;&#x2F; ROW &#x3D; 9 ； COL &#x3D; 9\n\nvoid print_board(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (j &#x3D; 0; j &lt;&#x3D; row; j++) &#x2F;&#x2F; 打印列的序号\n\t&#123;\n\t\tprintf(&quot;%d &quot;, j);\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\tfor (i &#x3D; 1; i &lt;&#x3D; row; i++)\n\t&#123;\n\t\tprintf(&quot;%d&quot;, i); &#x2F;&#x2F; 每打印一行初始化打印对应行数的序号\n\t\tfor (j &#x3D; 1; j &lt;&#x3D; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot; %c&quot;, board[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\n六. 布置雷\n布置雷这一步骤需要在雷阵实现，这里规定布置十个雷，由于我们每一把游戏的雷的位置是不同的（随机的），所以布置雷这一步骤需要电脑的随机性来布置，相应函数的使用为 rand，srand（为了使rand随机化需要用到的），time（时间戳），具体的介绍在上一节”C语言实现初级三子棋“有说到，所以这里便不再详细道来。\n由于是坐标定位，所以这里我们定义两个变量来接受电脑产生的随机值以作为二维数组的坐标来放置雷。\n电脑随机布置时，我们应该使用循环让电脑不断布置，当选中的格子是 ‘0’ ，便放雷，这样的动作做十次，但如果有重复就会另外找位置布置，所以实际上循环可能不止十次。\n每随机布置一个雷，我们便在初始化为字符 ‘0’ 的雷阵并且随机选中布置雷的格子上放上字符 ‘1’ ，这样我们便能分清楚雷与不是雷的区别，这样也有益于后面扫雷阶段的实现。\n由于是在9×9的范围来布置雷，所以这里我们需要限定电脑随机产生值的范围。\n当然如果想要看看布置雷的效果，在布置完后可以打印一下雷阵，但最终我们是不会打印的。以下是代码实现（代码展现是本模块的全部代码实现的展现，与其他功能的结构组合须看全代码）（也就是这三段代码是分开的）：\n\nadd_mine(mine, ROW, COL); \n\nsrand((unsigned int)time(NULL));\n\nvoid add_mine(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint count &#x3D; 0;\n\n\twhile (count &lt; MINE_COUNT) &#x2F;&#x2F; MINE_COUNT  &#x3D; 10（雷的个数） \n\t&#123;\n\t\tint x &#x3D; rand() % row + 1;\n\t\tint y &#x3D; rand() % col + 1;\n\n\t\tif (board[x][y] &#x3D;&#x3D; &#39;0&#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;1&#39;;\n\t\t\tcount++; &#x2F;&#x2F; 每布置一个计数一次\n\t\t&#125;\n\t&#125;\n&#125;\n\n七. 扫雷\n我们通过坐标选择需要扫的格子，当格子里的字符不是 ’1‘ 时，计算周围八个格子的雷数，值得注意的是，我们的选择和计算判断过程都是需要在雷阵盘上完成，但是我们展现出来的是这个格子周围的雷数，这就需要扫雷盘和雷盘建立起联系，一个计算分析判断，另一个接受展示，所以我们在写这么一个扫雷的函数时，两个盘的相关消息都要传递过去，这样便于两盘之间的相互联系，从而达到扫雷效果。下面是代码展示：\n\ndown_mine(mine, show, ROW, COL); &#x2F;&#x2F; 一个盘计算判断，另一个接受展示\n\nint around_mine(char mine[ROWS][COLS], int x, int y)\n&#123;\n\treturn (mine[x][y + 1] + mine[x][y - 1] + mine[x + 1][y] + mine[x - 1][y] + mine[x - 1][y - 1] + mine[x + 1][y + 1] + mine[x - 1][y + 1] + mine[x + 1][y - 1] - 8 * &#39;0&#39;);\n&#125;\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\tint count &#x3D; 0;\n\n\twhile (1)\n\t&#123;\n\t\tprintf(&quot;请输入要扫雷的坐标：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col)\n\t\t&#123;\n\t\t\tif (mine[x][y] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;很遗憾，你被炸死了！\\n&quot;);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tint ret &#x3D; around_mine(mine, x, y);\n\t\t\t\tshow[x][y] &#x3D; ret + &#39;0&#39;;\n\t\t\t\tcount++;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标不合法，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\n\t\tif (count &#x3D;&#x3D; ((row * col) - MINE_COUNT))\n\t\t&#123;\n\t\t\tprintf(&quot;扫雷成功！\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n可以看到，这里面又使用了一次函数定义调用，这次定义调用是为了计算周围的雷数，而我们扫雷盘上放的是字符，那么雷数如何转化到字符，这需要字符与整型数字之间的转化关系来完成。具体可看ASCLL码表。\n八. 整个程序的代码实现：\ngame.h：\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 9\n#define COL 9\n#define ROWS ROW + 2\n#define COLS COL + 2\n#define MINE_COUNT 10\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret);\n\nvoid print_board(char board[ROWS][COLS], int row, int col);\n\nvoid add_mine(char board[ROWS][COLS], int row, int col);\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);\n\ntest.c(主函数)（框架结构）：\n\n#define _CRT_SECURE_NO_WARNINGS\n\n&#x2F;&#x2F; 1.初始化雷盘与扫雷盘\n&#x2F;&#x2F; 2.打印盘\n&#x2F;&#x2F; 3.布置雷\n&#x2F;&#x2F; 4.扫雷\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  1.PLAY  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  0.EXIT  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar mine[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\tchar show[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F; 初始化盘\n\tinit_board(mine, ROWS, COLS, &#39;0&#39;);\n\tinit_board(show, ROWS, COLS, &#39;*&#39;);\n\t&#x2F;&#x2F; print_board(mine, ROW, COL);\n\tprint_board(show, ROW, COL);\n\t&#x2F;&#x2F; 布置雷\n\tadd_mine(mine, ROW, COL);\n\t&#x2F;&#x2F; print_board(mine, ROW, COL);\n\n\t&#x2F;&#x2F; 扫雷\n\tdown_mine(mine, show, ROW, COL);\n&#125;\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入扫雷游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tprintf(&quot;游戏结束：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tSleep(1000);\n\t\t\tsystem(&quot;cls&quot;);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\ngame.c(函数的定义：模块功能的实现)：\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include &quot;game.h&quot;\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; rows; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; cols; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; ret;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid print_board(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (j &#x3D; 0; j &lt;&#x3D; row; j++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, j);\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\tfor (i &#x3D; 1; i &lt;&#x3D; row; i++)\n\t&#123;\n\t\tprintf(&quot;%d&quot;, i);\n\t\tfor (j &#x3D; 1; j &lt;&#x3D; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot; %c&quot;, board[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nvoid add_mine(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint count &#x3D; 0;\n\n\twhile (count &lt; MINE_COUNT)\n\t&#123;\n\t\tint x &#x3D; rand() % row + 1;\n\t\tint y &#x3D; rand() % col + 1;\n\n\t\tif (board[x][y] &#x3D;&#x3D; &#39;0&#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;1&#39;;\n\t\t\tcount++;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint around_mine(char mine[ROWS][COLS], int x, int y)\n&#123;\n\treturn (mine[x][y + 1] + mine[x][y - 1] + mine[x + 1][y] + mine[x - 1][y] + mine[x - 1][y - 1] + mine[x + 1][y + 1] + mine[x - 1][y + 1] + mine[x + 1][y - 1] - 8 * &#39;0&#39;);\n&#125;\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\tint count &#x3D; 0;\n\n\twhile (1)\n\t&#123;\n\t\tprintf(&quot;请输入要扫雷的坐标：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col)\n\t\t&#123;\n\t\t\tif (mine[x][y] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;很遗憾，你被炸死了！\\n&quot;);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tint ret &#x3D; around_mine(mine, x, y);\n\t\t\t\tshow[x][y] &#x3D; ret + &#39;0&#39;;\n\t\t\t\tcount++;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标不合法，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\n\t\tif (count &#x3D;&#x3D; ((row * col) - MINE_COUNT))\n\t\t&#123;\n\t\t\tprintf(&quot;扫雷成功！\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n九. 总结\n\n\n\n\n\n\n\n\n\n咱们这里实现的扫雷只是初级的，游戏里点击一个格子它可能扫出一大块，这需要更复杂的算法来实现，所以扫雷小游戏值得我们继续研究，这可以提高我们的思维和能力。\n经过扫雷和三子棋两个小游戏的对比，我们可以发现其相同点和不同点，其算法的差异和框架的异同，独自完成这两个简易的小游戏可以大大提高我们的思维能力和代码的敏感性，建议大家能够独自完成。\n\n\n本章到此结束，谢谢大家。\n\n","slug":"使用C语言实现初级扫雷小游戏","date":"2023-02-17T14:37:11.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"e0b663ff8593ec90044339189f2bc842","title":"C语言的分支与循环#熟练使用，出手就有#","content":"一. 前言\n\n\n\n\n\n\n\n\n分支和循环在C语言中几乎无处不在，作为重要的一部分，精确掌握其语法和运用逻辑，是继续向下学习的“地基”。\n二. 分支语句1. if 分支语句if 就是如果，如果怎么怎么样就干嘛干嘛，在C语言中，其表达效果也是如此。\nif (表达式)   &#x2F;&#x2F; 表达式为真执行if语句块，随后下面的分支语句都不判断执行，如果为假，判断下一个else if的表达式\n&#123;\n\t语句;\n&#125;\nelse if(表达式)  &#x2F;&#x2F; 这里的表达式只有if中的表达式为假才会判断其真假，如果为真，执行其语句块并不在判断执行下面的分支，为假则继续向下判断\n&#123;\n    语句;\n&#125;\nelse &#x2F;&#x2F; 如果前面分支的表达式都为假，执行else语句块\n&#123;\n    语句;\n&#125;\n\n\n\n\n值得注意的是，if后面如果只跟一条语句的话是可以不用打大括号的，不过最好是要打大括号，以免出现不必要的错误，并且，如果不打括号，那么后面的else就会与最近的if匹配，这样很可能造成bug。\n\n例如：\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);  \n\n\tif (n &lt;&#x3D; 10)\n\t\tif (n % 2 &#x3D;&#x3D; 0)\n\t\t\tprintf(&quot;hehe\\n&quot;);\n\telse\n\t\tprintf(&quot;haha\\n&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n如果这里我们输入12，按语法逻辑来说程序一走屏幕上应该是打印 “haha” ，但是，由于没有大括号，那条在格式上是与第一个if对齐的else语句实际上是与离他最近的那个if对齐，而第二个if在第一个if语句之下，所以将不会打印“haha”。\n所以我们一定要养成打大括号的好习惯！\n2. switch—case 语句这里先用段代码来阐明它的基本表达形式：\nswtich(表达式)\n&#123;\n\tcase 常量表达式:\n\t    执行语句;\n\t\tbreak;\n\tcase 常量表达式:\n\t    执行语句;\n\t\tbreak:\n    ......\n\tdefault:\n\t    执行语句;\n\t\tbreak:\n&#125;\n\n（1） switch 后面括号内的“表达式”必须是整数类型。也就是说可以是 int 型变量、char 型变量，也可以直接是整数或字符常量，哪怕是负数都可以。但绝对不可以是float 型变量、double 型变量、小数常量通通不行，全部都是语法错误。\n\n（2）观察上段代码，case后面跟的都是常量表达式，如果switch后面的表达式与某个case后面的常量表达式相同，那么将会执行这个case后面的语句，我们可以看到，每个case分支后面都跟了个break，这是为什么呢？\n\n\n我们看看下面这段代码：\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  1-5 为工作日 6 7 为休息日\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tswitch (n)\n\t&#123;\n\tcase 1:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 2:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 3:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 4:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 5:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 6:\n\t\tprintf(&quot;休息日\\n&quot;);\n\tcase 7:\n\t\tprintf(&quot;休息日\\n&quot;);\n\tdefault:\n\t\tprintf(&quot;输入错误\\n&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n从上面说的来看理论上我们运行程序输入1会打印 “工作日”，但实际上却不是如此：当我们输入2时：\n由上面的运行结果来看，我们很容易推出，如果case后面没有break，当我们执行一个case，后面的case都会依次被执行，那么我们现在加入break来看看：\n\n\n很明显，加入break后，每当执行一个case语句，后面的case便不会在执行，这里我们就清楚了break在switch语句中的作用：那就是停止执行下一个case，跳出switch分支语句。既然break有如此作用，那么上述代码case1-5和case6-7的重复是不是就写麻烦了，为此做出以下改进：\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tswitch (n)\n\t&#123;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\tprintf(&quot;工作日\\n&quot;);\n\t\tbreak;\n\tcase 6:\n\tcase 7:\n\t\tprintf(&quot;休息日\\n&quot;);\n\t\tbreak;\n\tdefault:\n\t\tprintf(&quot;输入错误\\n&quot;);\n\t\tbreak;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n运行结果如下：\n这样的运行结果与每个case后面都加语句和break的运行结果相同，并且代码变得更加简洁了，这是运用了case的性质和break的作用，所以当我们有很多重复项时，用switch—case语句是很好的选择。\n\n\n\n\n\n\n\n\n\n我们可以看到，代码里头还有一个 default：它的意思是，如果所有的case都没法执行，那么就执行default 后面的语句，当然，default可以放在switch里的任何一个位置，这是不影响的，别问为啥，语法规定可以哈哈哈哈哈。\n三 . 循环语句(while,  do-while,  for)\n\n\n\n\n\n\n\n\n循环顾名思义就是重复的做某事，C语言中也是如此，这三种循环大同小异，都存在判断表达式与循环体。\n1. while 循环while (判断表达式)\n&#123;\n\t语句块;\n&#125;\n\n\n\n如上，如果判断表达式为真，那么就做while里头的代码块，如果判断表达式为假，则while循环不会执行。当判断表达式一直为真时，那么将会重复执行其里面的代码，这时程序会一直运行不停止，所以，在while循环里头，我们要插入能达到我们目的的并且n次循环后能使判断表达式为假的代码，这样，while循环才会在达到我们想要的效果的同时终止循环。\n\n2. do-while 循环do  &#x2F;&#x2F; do 就是无论如何先执行一次do大括号里的代码块的语句\n&#123;\n\t代码块;\n&#125; while (判断表达式);  &#x2F;&#x2F; 这里的判断 等do做完后在执行\n\n实际上，do-while 循环与 while 循环的差别就在与 do-while 循环是无论如何先执行一遍大括号里的代码语句再进行判断表达式，而 while 是直接判断表达式是否为真，再决定要不要执行大括号里的语句。\n要注意的是，do-while 循环的 while 后面是要加 ”;“ 号的，他表示一个语句的结束标志。\n\n3. for 循环for (表达式1; 表达式2; 表达式3)\n&#123;\n\t语句块;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;  表达式1 ：初始化表达式\n&#x2F;&#x2F;&#x2F;&#x2F;  表达式2 ：判断控制表达式\n&#x2F;&#x2F;&#x2F;&#x2F;  表达式3 ：调节器\n\n\nfor 循环是将初始化，判断控制表达式，调节功能表达式集为一体的循环。这也是他与while，do-while 循环最大的不同。这也使他运用起来更方便更简洁，所以我认为，for 循环是所有循环里的首选。\n\n4. 比较 （输出1-10的和）while：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint i &#x3D; 1;\n\tint sum &#x3D; 0;\n\n\twhile (i &lt;&#x3D; 10)\n\t&#123;\n\t\tsum +&#x3D; i;\n\t\ti++;\n\t&#125;\n\n\tprintf(&quot;%d&quot;, sum);\n\n\treturn 0;\n&#125;\ndo-while：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint i &#x3D; 1;\n\tint sum &#x3D; 0;\n\n\tdo\n\t&#123;\n\t\tsum +&#x3D; i;\n\t\ti++;\n\t&#125; while (i &lt;&#x3D; 10);\n\n\tprintf(&quot;%d&quot;, sum);\n\n\treturn 0;\n&#125;\nfor：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint sum &#x3D; 0;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)\n\t&#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\n\tprintf(&quot;%d&quot;, sum);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n三段代码的执行结果是一样的，但其书写形式却不同，我们可以看到，for循环相对于其它两个循环是最简明的。在某些环境中，while与for可以互相换着用（推荐使用for），而在不同情况下，还要具体问题具体分析，但绝大多数用for循环都可以解决，而 do-while 由于他的特殊性只在某些特定的场景才使用。\n四. break 与 continue 的作用1. break\n\n\n\n\n\n\n\n\nbreak意为停止终止的意思，他在C语言中被广泛使用，很多分支与循环的调控与衔接都需要它来解决。\n1.1  break 在分支中的作用\n这里明确指出，break 在 if 分支语句中没有任何作用，他不能跳出 if 语句（语法规定），但是如果在循环里头的 if 分支用 break ，为真程序则跳出（终止）循环。\nswitch-case 是 break 的真爱粉，其作用在上面 ↑ 讲解switch时有说到。可以这么说，几乎所有的swtich分支语句都需要break。\n\n1.2 break 在循环里的作用\n很简单，break 在循环当中的作用就是跳出循环（终止循环的意思）。当你的循环为你达到了某个你需要的结果时你便可以用break跳出循环使循环不在进行。\n\n2. continuecontinue 可以说只在循环里头起作用，他的作用是，当你在循环里头满足了执行continue的条件，那么continue将会结束本次循环，直接进行下一次循环。实际上continue在程序设计中用的比较少，它的功能局限性太大了。\n五. 总结\n\n\n\n\n\n\n\n\n分支与循环的语法虽然简单，但它在实际运用中确实烧脑的存在，今后几乎所有你会遇到的问题，他都需要分支与循环来逻辑实现。因此，分支与循环我们不仅要学会，还要练透，并且能十分清楚他的逻辑。\n","slug":"C语言的分支与循环-熟练使用，出手就有","date":"2023-02-17T14:08:48.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"d5a6879e81b57b97e13538ee2b9c1dd3","title":"C语言实现初级三子棋","content":"一. 前言\n\n\n\n\n\n\n\n\n\n本章我们用C语言来实现一个初级的三子棋小游戏，三子棋想必大家都玩过，只要每一行或每一列或对角线三个棋相同，那么便获得胜利，由此我们分析下棋的步骤与获胜判断，来构建一个C语言三子棋的代码框架。\n游戏实现我们分装两个 .c （代码主函数与函数定义源代码）后缀的文件和一个 .h 的文件（头文件，函数声明）\n.h : game.h .c : test.c  (主函数体文件) ||||||    game.c (函数定义文件)\n\n\n以下是头文件里的库函数和函数声明：\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 3\n#define COL 3\n\nvoid init_board(char board[ROW][COL], int row, int col);\n\nvoid print_board(char board[ROW][COL], int row, int col);\n\nvoid player_move(char board[ROW][COL], int row, int col);\n\nvoid computer_move(char board[ROW][COL], int row, int col);\n\nchar is_win(char board[ROW][COL], int row, int col);\n\n\n只要我们分别在另外两个 .c 文件（一个是主函数体一个是函数定义）中引入\n\n#include “game.h”  那么三个文件就相互作用了。\n这里先把主函数的调用结构放在这，以便后面读起来有迹可循：\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    1.PLAY    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    0.EXIT    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar ret &#x3D; 0;\n\tchar board[ROW][COL];\n\n\tinit_board(board, ROW, COL); &#x2F;&#x2F; 初始化棋盘\n\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\n\twhile (1)\n\t&#123;\n\t\tplayer_move(board, ROW, COL); &#x2F;&#x2F; 玩家下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\tcomputer_move(board, ROW, COL); &#x2F;&#x2F; 电脑下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\tif (ret &#x3D;&#x3D; &#39;*&#39;)\n\t&#123;\n\t\tprintf(&quot;玩家获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;#&#39;)\n\t&#123;\n\t\tprintf(&quot;电脑获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;Q&#39;)\n\t&#123;\n\t\tprintf(&quot;平局！\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 玩家赢返回‘*’\n&#x2F;&#x2F; 电脑赢返回‘#’\n&#x2F;&#x2F; 平局返回 ‘Q’\n&#x2F;&#x2F; 游戏继续返回 ‘C’\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\t\t\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;您已进入三子棋游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tSleep(1000); &#x2F;&#x2F; 游戏玩完后停顿一秒\n\t\t\tsystem(&quot;cls&quot;); &#x2F;&#x2F; 清屏\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏!&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误,请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\n\n\n\n二. 游戏版面与开始游戏的构建\n我们首先要打印一个菜单供玩家选择&lt;输入1&gt;则进入游戏，&lt;输入0&gt;则退出游戏，&lt;输入其它的数&gt;则输入错误，然后继续输入判断。为了一开始就让用户先选择，再判断输入的值然后判断是否再次输入，这里我们采用do-while循环结构，无论如何用户先选择一次，然后do-while里头采用switch-case来判断输入的值，而菜单我们调用一个menu（）函数来打印，下面是在主函数里的代码实现：\n\n#include &lt;stdio.h&gt;\n\nvoid menu()\n&#123;\n\tprintf(&quot;***************************************\\n&quot;);\n\tprintf(&quot;***************************************\\n&quot;);\n\tprintf(&quot;************    1.PLAY     ************\\n&quot;);\n\tprintf(&quot;************    0.EXIT     ************\\n&quot;);\n\tprintf(&quot;***************************************\\n&quot;);\n\tprintf(&quot;***************************************\\n&quot;);\n&#125;\n\nvoid test()\n&#123;\n\tint input &#x3D; 0;\n\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入三子棋游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\n\t\t\t&#x2F;&#x2F;game(); &#x2F;&#x2F;&#x2F;  游戏实现\n\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误，请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\t&#125; while (input);  &#x2F;&#x2F;&#x2F;  以输入的值来判断是否还想再来一次游戏\n&#125;\n\nint main()\n&#123;\n\ttest();  &#x2F;&#x2F;&#x2F;  整体的框架结构函数\n\n\treturn 0;\n&#125;\n\n\n我们可以看到， 这样简易的游戏初始菜单就制作好啦。\n\n三. 棋盘初始化与打印棋盘\n棋盘的初始化与棋盘的打印是在上面的game（）函数里实现的，我们知道，三子棋的棋盘是3×3的，这里我们不妨定义一个字符类型的二维数组（三行三列），开始我们每个元素放一个空格，这便棋盘初始化了。\n\n下面是初始化代码实现：\nvoid init_board(char board[ROW][COL], int row, int col); void init_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; &#39; &#39;;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\n\n而这里的难点在于如何将一个棋盘打印出来，首先我们来看下棋盘的样子：\n可以看到，第一行的元素是 空格%c空格|空格%c空格|空格%c空格（%c为初始化的空格）（这一行打印了三次），第二行的元素为—|—|—（这一行打印了两次），为了实打实的打印棋盘，这里需要判断语句与循环语句的相互作用来实现，下面是代码实现：\n\nvoid print_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)  &#x2F;&#x2F; 打印三次，每次分别打印两行内容（最后一次打印一行）\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)  &#x2F;&#x2F; 打印  ； | |  ；\n\t\t&#123;\n\t\t\tprintf(&quot; %c &quot;, board[i][j]);\n\t\t\tif (j &lt; col - 1)  &#x2F;&#x2F;  最后一个 | 不打印\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t\tif (i &lt; row - 1)  &#x2F;&#x2F; 最后一行 ---|---|---  不打印\n\t\t&#123;\n\t\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;---&quot;);\n\t\t\t\tif (j &lt; col - 1)  &#x2F;&#x2F;  最后一个 | 不打印\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\n四. 玩家下棋\n玩家下棋是输入棋盘的坐标然后将 ‘ * ’ 号放进去 ，由于玩家很大可能不是程序员，不知道数组的下标是从零开始，这里我们采用1，2，3混合坐标来输入，如果玩家输入两个值（用空格隔开）形成的坐标在1，2，3三个数字组成的成对组合范围内并且输入的那个坐标此时为 ‘  ’ ，那么玩家下棋成功，放个 ‘ * ’ 字符进去，如果玩家输入的坐标超过所形成范围或者该坐标已有棋子，那么提示玩家输入的错误，并且重新输入。下面是玩家下棋的代码实现：\n\nvoid player_move(char board[ROW][COL], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\n\twhile (1)  &#x2F;&#x2F; 用户重复输入直到下棋成功为止跳出\n\t&#123;\n\t\tprintf(&quot;玩家下棋：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; 3 &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; 3)\n\t\t&#123;\n\t\t\tif (board[x - 1][y - 1] &#x3D;&#x3D; &#39; &#39;)\n\t\t\t&#123;\n\t\t\t\tboard[x - 1][y - 1] &#x3D; &#39;*&#39;;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;该位置已被占，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标错误，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;\n\n五. 电脑下棋\n电脑下棋，其实就是电脑随机产生两个可控（1 - 3）数然后接受值并将值重复与玩家下棋相同道理的代码实现。\n\n为了使产生的随机数一直在变化，由于时间是一直在变化的，所以这里我们使用时间函数：\n\n下面是电脑下棋的整个代码实现：\n\n\nvoid computer_move(char board[ROW][COL], int row, int col)\n&#123;\n\tprintf(&quot;电脑下棋：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\twhile (1)  &#x2F;&#x2F; 电脑随机产生数判断下棋成功跳出   下面是产生随机坐标判断\n\t&#123;\n\t\tint x &#x3D; rand() % row;\n\t\tint y &#x3D; rand() % row;\n\t\tif (board[x][y] &#x3D;&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;#&#39;;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n由于电脑下棋是随机的，所以我们想赢是很简单的事啦。\n对了， rand使用前提需要调用srand（），它在前面的主函数代码块中显示啦。\n\n六. 判断输赢\n三子棋当三个棋子相同时便获胜，这里可以是三行三列两对角线，我们如何来判断输赢呢？\n我们在每一次玩家下棋完或者电脑下棋完后都要判断他是否获胜，这里获胜的判断我们返回一个值来进行比对，比对如下（这里只是展示一下如何判断返回值来确定是否获胜，代码不连贯不衔接，语法错误存在）：\n\n&#x2F;&#x2F; 玩家赢返回‘*’\n&#x2F;&#x2F; 电脑赢返回‘#’\n&#x2F;&#x2F; 平局返回 ‘Q’\n&#x2F;&#x2F; 游戏继续返回 ‘C’\n\n\nret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\nif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n&#123;\n\tbreak;\n&#125;\n\n\nif (ret &#x3D;&#x3D; &#39;*&#39;)\n&#123;\n\tprintf(&quot;玩家获胜！\\n&quot;);\n&#125;\nelse if (ret &#x3D;&#x3D; &#39;#&#39;)\n&#123;\n\tprintf(&quot;电脑获胜！\\n&quot;);\n&#125;\nelse if (ret &#x3D;&#x3D; &#39;Q&#39;)\n&#123;\n\tprintf(&quot;平局！\\n&quot;);\n&#125;\n\n\n\n\n下面是输赢本质 is_win() 函数定义的一个代码展示：\n\nchar is_win(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)  &#x2F;&#x2F; 行判断\n\t&#123;\n\t\tif (board[i][0] &#x3D;&#x3D; board[i][1] &amp;&amp; board[i][1] &#x3D;&#x3D; board[i][2] &amp;&amp; board[i][0] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[i][0];\n\t\t&#125;\n\t&#125;\n\n\tfor (j &#x3D; 0; j &lt; col; j++)  &#x2F;&#x2F; 列判断\n\t&#123;\n\t\tif (board[0][j] &#x3D;&#x3D; board[1][j] &amp;&amp; board[1][j] &#x3D;&#x3D; board[2][j] &amp;&amp; board[0][j] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[0][j];\n\t\t&#125;\n\t&#125;\n\n\tif (board[0][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[2][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;) &#x2F;&#x2F; 对角线判断\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\tif (board[2][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[0][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;)  &#x2F;&#x2F; 对角线判断\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\treturn &#39;C&#39;;  &#x2F;&#x2F; 这里如果前面的语句都没进入，那么返回 ‘C’ ，游戏继续\n&#125;\n\n七. 整体的代码展示\ngame.h\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 3\n#define COL 3\n\nvoid init_board(char board[ROW][COL], int row, int col);\n\nvoid print_board(char board[ROW][COL], int row, int col);\n\nvoid player_move(char board[ROW][COL], int row, int col);\n\nvoid computer_move(char board[ROW][COL], int row, int col);\n\nchar is_win(char board[ROW][COL], int row, int col);\n\n\n\ntest.c (主函数模块)：\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    1.PLAY    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    0.EXIT    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar ret &#x3D; 0;\n\tchar board[ROW][COL];\n\n\tinit_board(board, ROW, COL); &#x2F;&#x2F; 初始化棋盘\n\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\n\twhile (1)\n\t&#123;\n\t\tplayer_move(board, ROW, COL); &#x2F;&#x2F; 玩家下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\tcomputer_move(board, ROW, COL); &#x2F;&#x2F; 电脑下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\tif (ret &#x3D;&#x3D; &#39;*&#39;)\n\t&#123;\n\t\tprintf(&quot;玩家获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;#&#39;)\n\t&#123;\n\t\tprintf(&quot;电脑获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;Q&#39;)\n\t&#123;\n\t\tprintf(&quot;平局！\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 玩家赢返回‘*’\n&#x2F;&#x2F; 电脑赢返回‘#’\n&#x2F;&#x2F; 平局返回 ‘Q’\n&#x2F;&#x2F; 游戏继续返回 ‘C’\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\t\t\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;您已进入三子棋游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tSleep(1000); &#x2F;&#x2F; 游戏玩完后停顿一秒\n\t\t\tsystem(&quot;cls&quot;); &#x2F;&#x2F; 清屏\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏!&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误,请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\n\n\ngame.c (函数实现文件)\n\n#include &quot;game.h&quot;\n\nvoid init_board(char board[ROW][COL], int row, int col); void init_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; &#39; &#39;;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nvoid print_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot; %c &quot;, board[i][j]);\n\t\t\tif (j &lt; col - 1)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t\tif (i &lt; row - 1)\n\t\t&#123;\n\t\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;---&quot;);\n\t\t\t\tif (j &lt; col - 1)\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nvoid player_move(char board[ROW][COL], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\n\twhile (1)\n\t&#123;\n\t\tprintf(&quot;玩家下棋：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; 3 &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; 3)\n\t\t&#123;\n\t\t\tif (board[x - 1][y - 1] &#x3D;&#x3D; &#39; &#39;)\n\t\t\t&#123;\n\t\t\t\tboard[x - 1][y - 1] &#x3D; &#39;*&#39;;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;该位置已被占，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标错误，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid computer_move(char board[ROW][COL], int row, int col)\n&#123;\n\tprintf(&quot;电脑下棋：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\twhile (1)\n\t&#123;\n\t\tint x &#x3D; rand() % row;\n\t\tint y &#x3D; rand() % row;\n\t\tif (board[x][y] &#x3D;&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;#&#39;;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\nchar is_win(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tif (board[i][0] &#x3D;&#x3D; board[i][1] &amp;&amp; board[i][1] &#x3D;&#x3D; board[i][2] &amp;&amp; board[i][0] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[i][0];\n\t\t&#125;\n\t&#125;\n\n\tfor (j &#x3D; 0; j &lt; col; j++)\n\t&#123;\n\t\tif (board[0][j] &#x3D;&#x3D; board[1][j] &amp;&amp; board[1][j] &#x3D;&#x3D; board[2][j] &amp;&amp; board[0][j] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[0][j];\n\t\t&#125;\n\t&#125;\n\n\tif (board[0][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[2][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;)\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\tif (board[2][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[0][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;)\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\treturn &#39;C&#39;;\n&#125;\n\n八. 总结\n\n\n\n\n\n\n\n\n三子棋对我们综合使用分支，循环，函数有很好的训练效果，只有我们不断的去写代码，去掌握语法之间的逻辑，才能更细致的打出优质程序。\n","slug":"C语言实现初级三子棋","date":"2023-02-17T14:07:06.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"},{"id":"a49297b33fb7686d3c6c056b10f0d94d","title":"C语言函数篇（全）","content":"一.前言本章为个人所学所理解的C语言中函数篇的相关知识，定有不足，还望大家多多指教。\n二.什么是函数？函数是一段可以重复使用的代码，用来独立地完成某个功能。\n三.函数的分类：函数可以分为库函数和自定义函数。\n1.库函数\n\n\n\n\n\n\n\n\n在说库函数之前，先给大家推荐一个网站，这个网站可以搜索到所有C语言中的库函数，它包含了这些函数的信息和如何使用的场景介绍，下面是它的网址：[cplusplus]https://legacy.cplusplus.com/\n介绍：C语言在发布时已经为我们封装好了很多函数，它们被分门别类地放到了不同的头文件中（暂时先这样认为），使用这些函数时引入对应的头文件即可。这些函数是已经被编写的且效率极高，因此，为了某些功能的实现，引入库函数是首选。比如：strlen  strcpy  memcet\n1.1 strlen的作用为求字符串长度这里放段代码展示其作用\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; &#x2F;&#x2F;引入包含strlen函数的头文件\n\nint main()\n&#123;\n\tchar arr[] &#x3D; &quot;hello&quot;;\n\n\tint ret &#x3D; strlen(arr);  &#x2F;&#x2F; 将求出的字符串返回值用整型变量接受\n\n\tprintf(&quot;%d\\n&quot;, ret);\n\n\treturn 0;\n&#125;\n下面是运行结果很明显strlen求出的值的确是“hello”的长度值。\n1.2strcpy与memset函数的使用可以说strcpy与memset有相似之处，在某些场景，这两个函数都能将其实现\n1.2.1strcpy通俗来说，strcpy是将一个字符串里的内容拷贝到另一个字符串里，值得注意的是，当一个字符串拷贝到另一个字符串里时，其第一个字符串里的字符串结束标志 “\\0” 也被拷贝进第二个字符串里，这时第二个字符串里原有的内容就会被两个“\\0”包围，从而打印第二个字符串时为第一个字符串的内容。\n代码实现：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;******&quot;;\n\tchar arr2[] &#x3D; &quot;abc&quot;;\n\n\tstrcpy(arr1, arr2);  &#x2F;&#x2F;&#x2F; 将arr2打印到目的地arr1中\n\n\tprintf(&quot;%s\\n&quot;, arr1);\n\n\treturn 0;\n&#125;\n运行结果\n1.2.2 memsetC 库函数 void *memset(void *ptr, int value, size_t num) 复制字符 value（一个无符号字符）到参数 ptr 所指向的字符串的前 num 个字符。\n代码实现：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; &#x2F;&#x2F;  用 memset 对应头文件\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;########&quot;;\n\n\tmemset(arr1, &#39;*&#39;, 4);   &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  将4个‘*’字符复制到arr1当中\n\n\tprintf(&quot;%s\\n&quot;, arr1);\n\n\treturn 0;\n&#125;\n运行结果：\n库函数还有很多，这里只是举的几个例子，如果要多的了解，可以访问上面给的网站。\n2. 自定义函数自定义函数是自己实现的为了完成整个程序某个功能所设置的，他能多次调用，服务于整个程序，并且自定义函数各模块之间尽量功能独立。\n2.1 为什么要有自定义函数？大家想想，如果所有的功能库函数都为你提供了，那还关程序员啥事？自定义函数在某种程度上更高于库函数，他能体现一个程序员的水平如何。\n2.2 自定义函数的组成与例子ret_type function_name(para, *)\n&#123;\n\t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  函数体\n&#125;\nret_type &#x2F;&#x2F;返回类型\nfunction_name &#x2F;&#x2F; 函数名\npara &#x2F;&#x2F; 函数参数\n* &#x2F;&#x2F; 另一个参数 ，待定义\n例如：1.（计算两个整型变量的和）（Add）\n#include &lt;stdio.h&gt;\n\n&#x2F;&#x2F; 这里返回值为整型\nint Add(int a, int b)  &#x2F;&#x2F;&#x2F;  用两个整型值接受传来的 a b ，这里可以重名\n&#123;\n\treturn (a + b);\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\t&#x2F;&#x2F; ret 接受返回值\n\tint ret &#x3D; Add(a, b); &#x2F;&#x2F; 传参 求和\n\n\tprintf(&quot;%d\\n&quot;, ret); &#x2F;&#x2F; 打印和值\n\n\treturn 0;\n&#125;\n运行结果：例 2. 求一个整数的位数\n#include &lt;stdio.h&gt;\n\nint fun(int n)\n&#123;\n\tint count &#x3D; 0;\n\n\twhile (n &gt; 0)\n\t&#123;\n\t\tn &#x3D; n &#x2F; 10;\n\t\tcount++;\n\t&#125;\n\n\treturn count;\n&#125;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tint ret &#x3D; fun(n);\n\n\tprintf(&quot;%d\\n&quot;, ret);\n\n\treturn 0;\n&#125;\n运行结果：这里函数名最好是取与功能相关的名字，这样更具可读性。\n2.3 void说明：如果一个函数的返回类型为void，表示这个函数没有返回值，一般这样使用可能是为了打印某个东西，也可能是将某个整型变量或者数组元素改变。例如：这里将数组元素改变。\n#include &lt;stdio.h&gt;\n\nvoid ecg(int arr[], int sz)\n&#123;\n\tint i &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tarr[i] &#x3D; 0;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tint arr[3] &#x3D; &#123; 1,2,3 &#125;;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);  &#x2F;&#x2F; 求数组 长度&#x2F;元素个数\n\n\tecg(arr, sz); &#x2F;&#x2F;&#x2F;&#x2F; 这里我们将arr数组内容全改为0\n\n\tint i &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n运行结果：这里我们将整型数组的内容全部改为 0 。\n四. 函数的参数1. 实际参数（实参）\n\n\n\n\n\n\n\n\n实参为传递给函数的参数，它可以是常量，表达式，函数（这里实参作为另一个函数的返回值）等。在实参传递时，他必须要有确定的值以便于形参接受。\n2.形式参数（形参）\n\n\n\n\n\n\n\n\n形参是实参的一份临时拷贝，当一个函数被调用时，形参才被实例化，当函数结束时，形参也相继被释放。\n五. 函数的调用1.传值调用例如：求两个数的最大值\n#include &lt;stdio.h&gt;\n\nint Max(int a, int b)\n&#123;\n\treturn (a &gt; b ? a : b);\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\n\tint ret &#x3D; Max(a, b); &#x2F;&#x2F;&#x2F;&#x2F; 这里传递的是 a b 的值\n\n\tprintf(&quot;MAX &#x3D; %d&quot;, ret);\n\n\treturn 0;\n&#125;\n运行结果：\n2. 传址调用当我们调用函数想要改变实参的值，这是我们应该使用传址调用，因为形参接受实参值时会开辟另外的空间来存放，这时想要通过改变形参来达到改变实参的目的，就不会实现，因为地址不同，所以我们要传地址。例如：交换两个整型值\n#include &lt;stdio.h&gt;\n\nvoid ecg(int* a, int* b)\n&#123;\n\tint tmp &#x3D; *a;\n\t*a &#x3D; *b;\n\t*b &#x3D; tmp;\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\tprintf(&quot;交换前：%d %d\\n&quot;, a, b);\n\n\tecg(&amp;a, &amp;b);\n\n\tprintf(&quot;交换后：%d %d\\n&quot;, a, b);\n\n\treturn 0;\n&#125;\n运行结果：\n六. 函数的嵌套调用和链式访问1.函数的嵌套调用这里用代码来展现：\n#include &lt;stdio.h&gt;\n\nint ADD(int c) &#123;\n\treturn 2 * c;\n&#125;\n\nint doubleAdd(int a, int b)  \n&#123;\n\tint c &#x3D; a + b;\n\n\tint rets &#x3D; ADD(c);  &#x2F;&#x2F;&#x2F;&#x2F;  调用 2*实参 的函数\n\n\treturn rets;\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\n\tint ret &#x3D; doubleAdd(a, b);  &#x2F;&#x2F;&#x2F;&#x2F;  调用函数\n\n\tprintf(&quot;%d\\n&quot;, ret);\n\n\treturn 0;\n&#125;\n\n2. 函数的链式访问把一个函数的返回值作为另一个函数的参数这里用一段典型代码来表示：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tprintf(&quot;%d&quot;, printf(&quot;%d&quot;, printf(&quot;%d&quot;, 43)));\n\n\treturn 0;\n&#125;\n补充：printf函数返回值是一个数的位数 ，也就是有几个数。\n七. 函数的声明和定义1. 函数的声明（1）在一个项目中声明一般在头文件里，定义与使用一般在不同的 .C 文件中。\n（2）函数的使用一定要先定义后声明后使用，如果一个自定义函数模块放在main函数后面，那么在main函数前一定要声明，不然当你在main函数中使用定义的函数时，编译器从上至下编译你的代码不会先编译你的函数定义的内容，这时就会报某某未定义错误。（3）声明就是告诉编译器函数叫什么，参数是什么，返回类型是什么。\n2. 函数的定义定义就是函数功能的实现，使它能够完成项目的某个模块。前面有定义的例子，这里就不举例了。\n八. 函数的递归1. 什么是递归？\n\n\n\n\n\n\n\n\n递归实际上就是程序自己调用自己，它常常可以把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，这可以大大减少代码量，所以递归的主要思考方式在于：把大事化小。\n2. 递归必要的两个条件 1.存在限制条件，当满足这个限制条件后，递归便不再进行。 2.每次递归第调用都要越来越接近这个限制条件。\n3. 递归练习1.求n的阶乘#include &lt;stdio.h&gt;\n\nint jc(int n)\n&#123;\n\tint i &#x3D; 0;\n\n\tif (n &lt;&#x3D; 1)\n\t&#123;\n\t\treturn 1;\n\t&#125;\n\telse\n\t&#123;\n\t\treturn n * jc(n - 1);\n \t&#125;\n&#125;\n&#x2F;&#x2F;递归\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tint ret &#x3D; jc(n);\n\n\tprintf(&quot;%d&quot;, ret);\n\n\treturn 0;\n&#125;\n2.正序打印一个整型值的每一位#include &lt;stdio.h&gt;\n\nvoid Print(int n)\n&#123;\n\tif (n &gt; 0)\n\t&#123;\n\t\tPrint(n &#x2F; 10);\n\t&#125;\n\telse\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\tprintf(&quot;%d &quot;, n % 10);\n&#125;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tPrint(n);&#x2F;&#x2F; 正序打印一个整数的每一位  \n\n\treturn 0;\n&#125;\n\n3. 递归实现strlen求字符串长度#include &lt;stdio.h&gt;\n\nint my_strlen(char* str)\n&#123;\n\tif (*str !&#x3D; &#39;\\0&#39;)\n\t&#123;\n\t\treturn 1 + my_strlen(str + 1);\n\t&#125;\n\telse\n\t&#123;\n\t\treturn 0;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tchar arr[] &#x3D; &quot;hello&quot;;\n\n\tint len &#x3D; my_strlen(arr);\n\tprintf(&quot;%d&quot;, len);\n\n\treturn 0;\n&#125;\n\n4. 递归的局限性\n\n\n\n\n\n\n\n\n值得注意的是：因为递归有以上良好的功能，所以其思考难度较大。\n\n\n\n\n\n\n\n\n\n有时，递归使代码量大大减少的同时也增加了程序的运行难度（运行效率大大降低，如：求第n个斐波那契数)，并且其可读性没有非递归那么好，所以递归也要好好思考来选择。\n\n\n\n\n\n\n\n\n\n如果递归使用不当，就会出现栈溢出（“Stack overflow”）现象，这是因为每次函数调用都会在内存的栈区开辟一个自己的空间，如果递归过多导致内存栈空间开辟过多，这时就会出现溢出现象。\n九. 总结\n\n\n\n\n\n\n\n\n总的来说，函数在C语言中具有相当高的地位，它的存在使得一个项目更具模块化，便捷化，实效性和可读性，因此，我们在学习C语言当中，应养成函数定义这一习惯，并将使用函数的思维融会贯通。\n","slug":"C语言函数篇（全）","date":"2023-02-17T14:04:16.000Z","categories_index":"C语言相关知识的深度解析","tags_index":"C语言","author_index":"坏 幸 运"}]