[{"id":"dafd374449017f7aa00611ca0f3662e1","title":"关于C语言常见操作符的解析和使用","content":"前言\n\n\n\n\n\n\n\n\n\n我们在学习C语言时肯定会用到不同的操作符来完成我们的功能，本章便是这些操作符的介绍与具体使用。\n\n1. 算数操作符\n算数操作符有四种，他们分别为：\n\n\n\n\n\n\n\n\n\n加 “**+”，减 “-”，乘 “ * ”，除 “&#x2F;”， 取模 “%**” \n值得注意的是,在C语言中乘号用 “ * “ 表示, 除号用  “ &#x2F; “  表示。\n取模号 “ % “ 求的是余数,比如 5除3余2 ,那么2便是计算的结果。\n通俗易懂,通过我们的数学知识很清楚的知道他们的作用。\n\n\n\nint main()\n&#123;\n\tint a &#x3D; 20;\n\tint b &#x3D; 12;\n\t\n\tprintf(&quot;a + b &#x3D; %d\\n&quot;, a + b);\n\tprintf(&quot;a - b &#x3D; %d\\n&quot;, a - b);\n\tprintf(&quot;a÷b &#x3D; %d\\n&quot;, a &#x2F; b); &#x2F;&#x2F; 这里20除12等于1，他不会显示后面的小数，除非计算式两边至少有一个浮点数\n\tprintf(&quot;a×b &#x3D; %d\\n&quot;, a * b);\n\tprintf(&quot;a % b &#x3D; %d\\n&quot;, a % b); &#x2F;&#x2F; 这里20模12余数是8，结果便是8\n\n\treturn 0;\n&#125;\n\n\n值得注意的是,当计算式两边至少有一个浮点数的时候,相除才会计算出小数.\n\n2.移位操作符首先,我们来补充一个小知识:\n\n\n\n\n\n\n\n\n\n\n我们都知道,一个数在内存中是以二进制数来存放的,存放的是这个数的补码,那么什么是补码呢?\n一个数的二进制有原码,反码和补码,在计算中是用补码来计算的,而打印出来的是原码,这三个码之间有这样的关系,原码符号位不变,其它位按位取反得到反码,反码加一得到补码,而又补码要得到原码,反过来就是了.\n正数的原码反码补码相同,而负数则需要结果上面的计算来得到.\n由上可以得到,移位操作符,移位其实移的是在内存中储存的二进制数的补码.\n\n2.1. 左移操作符\n\n\n\n\n\n\n\n\n(&lt;&lt;) : 补码左移,左边抛弃,右边补0.\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\t&#x2F;&#x2F; a是一个整数所以他的原码，反码，补码相同\n    &#x2F;&#x2F; 原码：00000000000000000000000000001010\n    &#x2F;&#x2F; 反码：00000000000000000000000000001010\n    &#x2F;&#x2F; 补码：00000000000000000000000000001010\n\tint b &#x3D; 15;\n\tint c &#x3D; -5;\n\t&#x2F;&#x2F; c为负数\n\t&#x2F;&#x2F; 原码：10000000000000000000000000000101\n\t&#x2F;&#x2F; 反码：11111111111111111111111111111010\n\t&#x2F;&#x2F; 补码：11111111111111111111111111111011\n\t&#x2F;&#x2F; 左移后：11111111111111111111111111110110 \n\t&#x2F;&#x2F; 减一：11111111111111111111111111110101\n\t&#x2F;&#x2F; 取反得到计算后的原码：10000000000000000000000000001010 - （-10）\n\n\tprintf(&quot;%d\\n&quot;, a &lt;&lt; 1); &#x2F;&#x2F; 左移1 &#x2F;&#x2F; 00000000000000000000000000010100 - 20\n\tprintf(&quot;%d\\n&quot;, b &lt;&lt; 1); &#x2F;&#x2F; 左移1 &#x2F;&#x2F; 00000000000000000000000000010100 - 30\n\tprintf(&quot;%d\\n&quot;, c &lt;&lt; 1); &#x2F;&#x2F; 左移1\n\t&#x2F;&#x2F; 补码左移 右边补 0\n\t&#x2F;&#x2F; 00000000000000000000000000010100 - 20\n\n\treturn 0;\n&#125;\n\n\n\n不难看出,左移操作符具有乘以 2 的效果.\n\n2.2. 右移操作符\n\n\n\n\n\n\n\n\n(&gt;&gt;):右移操作符与左移操作符计算过程几乎相同,有一点不同的是,右移操作符分为算数右移和逻辑右移:\n\n算数右移: 左边补符号位,右边抛弃.\n逻辑右移: 左边补0,右边抛弃.\n通常来说进行右移时是逻辑右移.\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; -5;\n\n\tprintf(&quot;%d\\n&quot;, a &gt;&gt; 1); &#x2F;&#x2F; 5\n\tprintf(&quot;%d\\n&quot;, b &gt;&gt; 1); &#x2F;&#x2F; -3\n\t&#x2F;&#x2F; b计算过程\n\t&#x2F;&#x2F; 原码：10000000000000000000000000000101\n\t&#x2F;&#x2F; 反码：11111111111111111111111111111010\n\t&#x2F;&#x2F; 补码：11111111111111111111111111111011\n\t&#x2F;&#x2F; 右移：11111111111111111111111111111101\n\t&#x2F;&#x2F; 减一：11111111111111111111111111111100\n\t&#x2F;&#x2F; 取反：10000000000000000000000000000011\n\t&#x2F;&#x2F; 右移1后的数为 10000000000000000000000000000011 - （-3）\n\n\treturn 0;\n&#125;\n无论是左移还是右移,我们都不能移动负数为,如: a &gt;&gt; -1.\n3.位操作符同样的,位操作符也是对补码进行计算\n3.1 &amp;\n按位与是 : 如果两个二进制补码相同位数上有一个为零则为0,都为1则为1.\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; -5;\n\t&#x2F;&#x2F; 原：10000000000000000000000000000101\n\t&#x2F;&#x2F; 反：11111111111111111111111111111010\n\t&#x2F;&#x2F; 补：11111111111111111111111111111011\n\tint b &#x3D; 3;\n\t&#x2F;&#x2F; 原：00000000000000000000000000000011\n\t&#x2F;&#x2F; 补：00000000000000000000000000000011\n\n\t&#x2F;&#x2F; a &amp; b\n\t&#x2F;&#x2F; 补：11111111111111111111111111111011\n\t&#x2F;&#x2F; 补：00000000000000000000000000000011\n\t&#x2F;&#x2F; 有一个0则为0，都为1则1\n\t&#x2F;&#x2F; 得：00000000000000000000000000000011\n\t&#x2F;&#x2F; 为整数：3\n\tprintf(&quot;%d&quot;, a &amp; b);\n\n\treturn 0;\n&#125;\n\n3.2 |\n按位或是 : 如果两个二进制补码相同位数上只要有一个为1则为1,全0则0.\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\t&#x2F;&#x2F; 补：00000000000000000000000000001010\n\tint b &#x3D; -2;\n\t&#x2F;&#x2F; 原：10000000000000000000000000000010\n\t&#x2F;&#x2F; 反：11111111111111111111111111111101\n\t&#x2F;&#x2F; 补：11111111111111111111111111111110\n\n\t&#x2F;&#x2F; a | b\n\t&#x2F;&#x2F; 00000000000000000000000000001010 \n\t&#x2F;&#x2F; 11111111111111111111111111111110\n\t&#x2F;&#x2F; 11111111111111111111111111111110 结果\n\t&#x2F;&#x2F; 减一：11111111111111111111111111111101\n\t&#x2F;&#x2F; 取反：10000000000000000000000000000010 （-2）\n\tprintf(&quot;%d&quot;, a | b); &#x2F;&#x2F; -2\n\n\treturn 0;\n&#125;\n\n3.3 ^\n按位异或是：相同为0，相异为1.\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 3;\n\t&#x2F;&#x2F; 补：00000000000000000000000000000011\n\tint b &#x3D; 5;\n\t&#x2F;&#x2F; 补：00000000000000000000000000000101\n\n\t&#x2F;&#x2F; a ^ b\n\t&#x2F;&#x2F; 00000000000000000000000000000011\n\t&#x2F;&#x2F; 00000000000000000000000000000101\n\t&#x2F;&#x2F; 00000000000000000000000000000110 - 6\n\tprintf(&quot;%d\\n&quot;, a ^ b); &#x2F;&#x2F; 6\n\tprintf(&quot;%d\\n&quot;, a ^ 0); &#x2F;&#x2F; a\n\tprintf(&quot;%d\\n&quot;, b ^ 0); &#x2F;&#x2F; b\n\tprintf(&quot;%d\\n&quot;, a ^ a); &#x2F;&#x2F; 0\n\n\treturn 0;\n&#125;\n\n\n值得注意的是：\na ^ 0 &#x3D; a;\nb ^ 0 &#x3D; b;\na ^ a &#x3D; 0;\n那么可以得到：\na ^ a ^ b &#x3D; b;\nb ^ b ^ a &#x3D; a;\n\n\n\n\n\n\n\n\n有一道经典题目：不创建临时变量交换两个变量的值。我们便可以用上述推理来实现\n\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;82c60be1cb6f4fc0b0a5b41971123922.png#pic_center)\n\n\tint a &#x3D; 3;\n\tint b &#x3D; 5;\n\n\tprintf(&quot;交换前：%d %d\\n&quot;, a, b);\n\n\ta &#x3D; a ^ b;\n\tb &#x3D; a ^ b;\n\ta &#x3D; a ^ b;\n\n\tprintf(&quot;交换后：%d %d\\n&quot;, a, b);\n\n\treturn 0;\n&#125;\n\n3.4 ~按位取反是补码二进制位如果是1则变为0，如果是0则变为1。\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 3;\n\t&#x2F;&#x2F; 补：00000000000000000000000000000011\n\t&#x2F;&#x2F; 反：11111111111111111111111111111100  补码变负\n\t&#x2F;&#x2F; -1：11111111111111111111111111111011\n\t&#x2F;&#x2F; 原：10000000000000000000000000000100  -4\n\tprintf(&quot;%d&quot;, ~a);\n\n\treturn 0;\n&#125;\n\n\n4.赋值操作符\n&#x3D;例如：a &#x3D; 5,这里将5赋值给变量a\n\n复合型：\n\n+&#x3D;  \n\n-&#x3D;\n\n&#x2F;&#x3D;\n\n*&#x3D;\n\n%&#x3D;\n\n&amp;&#x3D;\n\n|&#x3D;\n\n^&#x3D;\n\n（&lt;&lt;&#x3D;）\n\n（&gt;&gt;&#x3D;）例如：a+&#x3D;2其实就是a&#x3D;a+2,其他的复合型都是如此\n\n\n5.单目操作符\n\n\n\n\n\n\n\n\n  -            负值\n  +            正值\n  ++           a++：后置加加  ; ++a：前置加加（都是a+=1）\n  --           与++效果相同\n  !            逻辑反操作\n  &amp;            取地址符号\n  ~            二进制数按位取反\n  *            解引用操作\n  sizeof       求类型长度（以字节为单位）\n  (类型)        强制类型转换\n\n这里对++和！作讲解\n++ 首先看代码：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 1;\n\tint b &#x3D; a++; &#x2F;&#x2F; 先把a的值赋给b，a再自增1\n\tint c &#x3D; ++a; &#x2F;&#x2F; a先自增1，再赋值给c\n\n\tprintf(&quot;%d\\n&quot;, a); &#x2F;&#x2F; 3\n\tprintf(&quot;%d\\n&quot;, b); &#x2F;&#x2F; 1\n\tprintf(&quot;%d\\n&quot;, c); &#x2F;&#x2F; 3\n\n\treturn 0;\n&#125;\n前置加加和后置加加其实在上述代码里其实效果很明显了，只要我们用一次++，其对应变量就要自增1。–与++的运用效果是相同的，只不过说是自减1。\n！：!&#x3D; 就是不等于，其相当于非。!0 就是真，!1就是假。\n6.关系操作符\n(&gt;)\n(&gt;&#x3D;)\n(&lt;)\n(&lt;&#x3D;)\n(!&#x3D;)\n(&#x3D;&#x3D;)\n\n上述操作符多用在判断语句中，用来决定程序进程变化。\n7.逻辑操作符&amp;&amp;\n\n\n\n\n\n\n\n\n逻辑与：如 a&amp;&amp;b ，当a,b都为真时，表达式为真，当其中有一个为假时为假\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 1;\n\tint c &#x3D; 2;\n\tint d &#x3D; 3;\n\tint i &#x3D; a++ &amp;&amp; ++b &amp;&amp; c++; &#x2F;&#x2F; a++表达式结果为a的值，此时a&#x3D;0,由&amp;&amp;的性质有一个为假就为假，则后面都不计算了\n    &#x2F;&#x2F;但是a++还是要进行计算的，也就是a要自增1\n\tprintf(&quot;%d %d %d %d\\n&quot;, a, b, c, d);\n    &#x2F;&#x2F; 结果为 1 1 2 3\n\treturn 0;\n&#125;\n\n||\n\n\n\n\n\n\n\n\n逻辑或：如 a || b，当a，b中只要有一个为真，表达式为真，都为假表达式才为假\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 1;\n\tint b &#x3D; 2;\n\tint c &#x3D; 3;\n\tint d &#x3D; 4;\n\tint i &#x3D; a++ || b++ || ++d || c--; &#x2F;&#x2F; a++表达式结果为a，此时a&#x3D;1为真，由||性质，整个表达式结果为真，则后面的不计算了\n\t&#x2F;&#x2F; a++还是要计算的，也就是a要自增1\n\n\tprintf(&quot;%d %d %d %d\\n&quot;, a, b, c, d);\n\t&#x2F;&#x2F; 结果为 2 2 3 4\n\n\treturn 0;\n&#125;\n\n结合我们可以通过判断闰年这个经典的题目来熟悉掌握&amp;&amp; ||。\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tif (((n % 4 &#x3D;&#x3D; 0) &amp;&amp; (n % 100 !&#x3D; 0)) || (n % 400 &#x3D;&#x3D; 0))\n\t&#123;\n\t\tprintf(&quot;%d年是闰年！\\n&quot;, n);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;%d不是闰年！\\n&quot;, n);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n8.条件操作符\n\n\n\n\n\n\n\n\nexp1 ？ exp2：exp3;\n\n如果 exp1 为真，表达式结果为 exp2\n如果 exp1 为假，表达式结果为 exp3\n\n例如求两个变量的最大值：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\n\tprintf(&quot;max &#x3D; %d\\n&quot;, (a &gt; b ? a : b));\n\n\treturn 0;\n&#125;\n\n9.逗号表达式\n\n\n\n\n\n\n\n\n\n优先级最低\n用逗号隔开多个表达式\n整个表达式由左向右依次计算，计算结果为最后一个表达式的结果\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint a &#x3D; 1;\n\tint b &#x3D; 2;\n\n\tint c &#x3D; (a +&#x3D; 2, b &#x3D; b + 1, a +&#x3D; 1, a &#x2F; 2);\n\n\tprintf(&quot;%d&quot;, c); &#x2F;&#x2F; 2\n\n\treturn 0;\n&#125;\n我们可以看到从左向右依次计算，最后a &#x3D; 4，4 &#x2F; 2 &#x3D; 2，所以最后c的值为2；\n10.表达式求值10.1.隐式类型转换\n\n\n\n\n\n\n\n\nCPU在进行运算的时候一般使用整形int，所以在有些时候，当一个小于整形的类型进行计算时，计算机就会先进行整形提升再进行运算，这就是隐式类型转换。\n（通用CPU是难以直接实现两个非整形的直接相加运算）\n例：\n&#x2F;&#x2F; char short int long ...\n&#x2F;&#x2F;  1     2    4\nint main()\n&#123;\n\t&#x2F;&#x2F;char --&gt; signed char\n\tchar a &#x3D; 3;\n\t&#x2F;&#x2F;截断\n\t&#x2F;&#x2F;00000000000000000000000000000011\n\t&#x2F;&#x2F;00000011 - a\n\t&#x2F;&#x2F;\n\tchar b &#x3D; 127;\n\t&#x2F;&#x2F;00000000000000000000000001111111\n\t&#x2F;&#x2F;01111111 - b\n \n\tchar c &#x3D; a + b;\n\t&#x2F;&#x2F;00000011\n\t&#x2F;&#x2F;01111111\n\t&#x2F;&#x2F;整型提升\n\t&#x2F;&#x2F;00000000000000000000000000000011 - a\n\t&#x2F;&#x2F;00000000000000000000000001111111 - b\n\t&#x2F;&#x2F;00000000000000000000000010000010 - a + b &#x3D;c\n\t&#x2F;&#x2F;截断\n\t&#x2F;&#x2F;10000010 - c\n\tprintf(&quot;%d\\n&quot;, c);\n\t&#x2F;&#x2F;%d 是打印十进制的整数\n\t&#x2F;&#x2F;11111111111111111111111110000010 - 补码\n\t&#x2F;&#x2F;11111111111111111111111110000001 - 反码\n\t&#x2F;&#x2F;10000000000000000000000001111110 - 原码\n\t&#x2F;&#x2F;-126\n\treturn 0;\n\t&#125;\n\n————————————————\n版权声明：本文为CSDN博主「戊子仲秋」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;Locky136&#x2F;article&#x2F;details&#x2F;127812345&#x3D;\n输出结果：\n\n\n\n\n\n\n\n\n\n输出：-126\n注：\nchar：\n有符号的char的取值范围是：-128~127\n无符号的char的取值范围是：0~255\n\n以上是一位大佬的讲解（写的很详细），这里直接引用他的，大家可以多看看他的博客，一定会有很大的帮助的。                                                      ——@戊子仲秋\n\n10.2.算数转换long double：最高↑double↑float unsigned long int↑long int↑unsigned int↑int\n\n当我们再利用两个不同类型的变量来进行计算时，其算数级低的会自动升级到算数级高的类型去进行计算，如果进行一些不正当的算数转换，会导致数据丢失。\n\n如：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tfloat e &#x3D; 2.717f;\n\tint w &#x3D; e;\n\n\tprintf(&quot;%d&quot;, w);\n\n\treturn 0;\n&#125;\n运行结果为：\n\n\n\n\n\n\n\n\n\n输出： 2\n可以看到，e值小数点后面的数丢失了，这是由高级到低级转换的结果（不能用）\n11.操作符的准确使用\n操作符之间有其对应的优先级，当我们进行运算时，优先比较相邻两个操作符的优先级，如果一个表达式很复杂，简易用（）来分明其运算顺序，不然在不同的编译器上可能会有不同的运算结果。\n\n总结\n\n\n\n\n\n\n\n\nC语言中操作符的使用可以说是司空见惯的，如何正确的使用是我们必须掌握的，学到后面，我们可以尝试着巧妙运用操作符去解决一些复杂的问题，这需要我们不断地练习与巩固。在此，感谢大家的阅读！\n","slug":"关于C语言常见操作符的解析和使用","date":"2023-02-17T14:40:44.000Z","categories_index":"","tags_index":"","author_index":"坏 幸 运"},{"id":"b82bfb4a02f130e6ce0f96366fdc8a1f","title":"一文带你灵活使用C语言的数组","content":"一. 什么是数组？\n\n\n\n\n\n\n\n\n\n数组是由数据类型相同的一系列元素组成的。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确的创建数组。普通变量可以使用的类型，数组元素都可以使用。\n\n二. 一维数组1. 一维数组的创建和初始化1.1. 一维数组的创建int arr[4];\n上面便创建了一个整型数组：\n\nint 是数组的类型，在这里是整型。\narr 是数组名。\n[] 是下标引用操作符也是数组的标志，这里我们在里面给上一个4，代表一个数组名为arr的整型数组里面放了四个元素。\n\n值得注意的是，我们在定义数组时，[] 里的必须是一个常量表达式（const），这是C99标准之前规定的。也就是说，如果我们在前面创建一个整型变量给个初始值10，在创建数组时[]里放的是这个整型变量的变量名，这样编译器会报错，在语法上也是不支持的（C99标准之前）。\n当然，我们还可以用宏定义一个常量来作为数组[]里的表达式从而创建一个数组：\n#include &lt;stdio.h&gt;\n\n#define num 100 \n\nint main()\n&#123;\n\tint arr[num]; &#x2F;&#x2F; 这里是支持这样去创建的\n\n\treturn 0;\n&#125;\n\n\n1.2. 一维数组的初始化\n首先我们要知道什么是数组的初始化？也就是说，在我们创建了一个数组后，给数组一个{0}，或者把这个数组填满，这都可以算作数组初始化。\n我还是建议大家在创建一个数组后能够给数组初始化，这样在后面使用时，就不会出现一些奇奇怪怪的值。这是因为，当你在给一个元素个数为4的整型数组初始化{0}后，你去打印这个数组，他会默认你这数组的四个元素都为0，不然就是一些很奇怪的随机值。\n如果不指定数组大小而给数组某些值，那么这个数组的大小会根据你给的这些值的个数来确定。\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[4] &#x3D; &#123; 0 &#125;;\n\n\treturn 0;\n&#125;\n\n\n\n如果一个整型数组它初始化不完全，那么没初始化的元素他也会默认为零：\n\nint main()\n&#123;\n\tint arr[4] &#x3D; &#123; 1 ,2 &#125;;\n\n\treturn 0;\n&#125;\n\n\n当然，其它类型的初始化也是一样（char等）。\n\n2. 一维数组的使用\n这里首先讲解一下[]操作符，它名为下标引用操作符。在创建一个数组时，它是数组的标志，也起定义数组大小的作用。在使用一个数组时，他的作用便是下标引用了。值得注意的是，数组的下标是这个元素从左往右数的位数减一，也就是说数组的下标是从零开始的，第一个元素的下标为0，第二个元素的下标为1，以此类推。所以我们在使用数组时，一定要注意下标的使用是否正确，避免出现数组下标越界的问题。\n\n以下是一维数组的初级使用（创建—打印）：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[4] &#x3D; &#123; 1, 2, 3 ,4 &#125;;\n\tint i &#x3D; 0;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d&quot;, arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n我们可以看到，打印一维数组时用了一个循环。\n上述代码中使用了sizeof来求数组的长度，sizeof其实是求数组字节的大小，一个整型为4个字节，而数组arr里有4个整型，那么大小为16，后面除上这个数组的第一个元素的字节大小（4），结果为4，这样求数组大小可以避免一些数组元素过多的问题。并且数组的长度计算还会在你改变这个数组时而改变，可以说非常方便，这是一个常用的求数组长度的方法，希望大家牢记。\n\n3.一维数组在内存中的存储\n一维数组在内存中的存储是连续的，地址由低到高，这里放段代码来展示其效果：\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[4] &#x3D; &#123; 1, 2, 3, 4 &#125;;\n\tint i &#x3D; 0;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;&amp;arr[%d] &#x3D; %p\\n&quot;, i， &amp;arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n我们可以看到，这四个元素的地址是连续的，他们之间相差4，是因为一个整型为四个字节，当一个整型值在内存中存储时，内存会开辟四个单元空间（每个单元为一个字节并且对应一个地址）用来存放这个整型值，所以在一个整型数组中也是如此，他们每个整型元素相差4。\n\n三. 二维数组1. 二维数组的创建和初始化1.1. 二维数组的创建int arr[2][3];\n\n上面便创建了一个二维数组，它形式上就是比一维数组多了一个[]。\n这里直接说明，二维数组和一维数组的通性是一样的，上述arr[2][3]，通俗来说，2表示这个二维数组有两行（两条），3表示每一行（每一条）有几列（也就是几个元素），所以我们可以认为，arr[2][3]其实就是由两个arr[3]构成的。所以我们说二维数组其实就是一维数组。\n\n1.2. 二维数组的初始化\n二维数组的初始化与一维数组的初始化大同小异，但二维数组它是分行和列的，因此二维数组的初始化又有不同。\n\nint arr[2][3] &#x3D; &#123; &#123;1,2,3 &#125;, &#123;4, 5, 6&#125; &#125;;\n\na.这里函数大小与初始化大小相同，所以这段代码表示第一个大括号表示为数组的第一行，第二个大括号表示为数组的第二行，而这里只有两行，其中每一行有三个元素（每行三列）。这是最为正确且直观的初始化方式。\nint arr[2][3] &#x3D; &#123; 1,2,3,4,5,6 &#125;;\n\nb.这里没有打大括号,但其与a展现的效果是相同的，他会自动将数组的前三个元素作为第一行，后三个元素最为第二行，这样不是很好读。\nint arr[2][3] &#x3D; &#123; 1,2,4,5,6 &#125;;\n\nc.这段代码数组初始化的元素个数就少于整个数组的元素个数的大小了，所以前三个元素还是默认第一行，后两个元素默认第二行，但最后一个没给的值默认为零（没有大括号的情况）。\nint arr[2][3] &#x3D; &#123; &#123;1,2 &#125;, 4, 5, 6 &#125;;\n\nd.这里给了大括号之后，则前面两个元素为第一行，后三个为第二行。当在打印数组内容时，第一行空缺的元素会默认为零打印。\n\n值得注意的是，二维数组在初始化的时候，行可以省略，但列不能省略，因为由列可以确定你这一行，而行缺失了列的限制就无从初始化了。\n\n2. 二维数组的使用先展示代码来表达效果：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[2][3] &#x3D; &#123; &#123;1,2 &#125;, 4, 5, 6 &#125;;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; 2; i++) &#x2F;&#x2F; 打印每行\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; 3; j++) &#x2F;&#x2F; 打印这一行的每一列\n\t\t&#123;\n\t\t\tprintf(&quot;%d &quot;, arr[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;); &#x2F;&#x2F; 每打印一行换行\n\t&#125;\n\n\treturn 0;\n&#125;\n\n我们可以看到，打印一个二维数组要用到两个循环（循环之间为嵌套关系），使用二维数组可以达到一个版面的效果，在前面三子棋和扫雷的使用效果会更明显。\n3. 二维数组在内存中的存储\n我们说二维数组其实就是由一维数组构成的，所以二维数组在内存中的储存，可以说几乎与一位数组相同。\n二维数组在内存中的储存也是连续的，他每一行的地址紧跟在前一行的地址后面，地址由低到高：\n\n四. 多维数组\n\n\n\n\n\n\n\n\n\n前面讨论的二维数组的相关内容都适用于三维数组或者更多维的数组。可以这样声明一个三维数组int arr[10][20][30];\n我们可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。例如，把上面声明的三维数组arr想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来。\n还有一种理解arr的方法是，把arr看作数组的数据。也就是说，arr内含10个元素，每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。或者，可以简单地根据所需的下标值去理解数组。\n通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循环。对于其它多维数组，以此类推。一般来说，我们只会使用到二维数组。\n\n———————————————————《C primer plus》\n五. 数组和指针（初级）1.1. 指针在数组中的使用\n指针是提供一种以符号形式使用地址方法，因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。数组表示法其实是在变相地使用指针。\n\n数组名其实就是首元素的地址，&amp;arr[0]与arr的效果相同,但&amp;arr与他俩又不相同，他是整个数组的地址，下面是代码的展示效果：\n\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tprintf(&quot;%p\\n&quot;, arr);\n\tprintf(&quot;%p\\n&quot;, &amp;arr[0]);\n\tprintf(&quot;%p\\n&quot;, &amp;arr);\n\tprintf(&quot;\\n&quot;);\n\tprintf(&quot;%p\\n&quot;, arr + 1); &#x2F;&#x2F; 数组名+1\n\tprintf(&quot;%p\\n&quot;, &amp;arr[1]); &#x2F;&#x2F; 第二个元素的地址\n\tprintf(&quot;%p\\n&quot;, &amp;arr + 1); &#x2F;&#x2F; 整个数组地址+1\n\n\treturn 0;\n&#125;\n\n\n我们可以看到（&amp;arr + 1）它跳过的是整个数组的地址，而（arr + 1）只数组中第二个元素的地址。\n\n以下是指针在数组中的具体的使用：\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tint arr1[] &#x3D; &#123; 1,2,3,4 &#125;;\n\tchar arr2[] &#x3D; &quot;abcd&quot;;\n\tint i &#x3D; 0;\n\n\tint sz1 &#x3D; sizeof(arr1) &#x2F; sizeof(arr1[0]);\n\tint sz2 &#x3D; strlen(arr2);\n\n\tint* p1 &#x3D; arr1;\n\tchar* p2 &#x3D; arr2;\n\n\tfor (i &#x3D; 0; i &lt; sz1; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, *p1 + i); &#x2F;&#x2F; 解引用操作找到对应元素打印\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\tfor (i &#x3D; 0; i &lt; sz2; i++)\n\t&#123;\n\t\tprintf(&quot;%c &quot;, *p2 + i);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n运行结果：\n1.2. 函数，数组与指针\n当我们在调用函数时，想传递一个数组过去，我们直接传递数组名就行了，因为数组名就是数组首元素的地址，所以当函数接受时需要一个指针来接收传递过来的地址，值得注意的是，在函数接受时，用类型加数组而不用指针也是可以的，这两个的效果是相同的，例：\n\n#include &lt;stdio.h&gt;\n\nvoid print(int* arr, int sz)\n&#123;\n\tint i &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\tprint(arr, sz);\n\n\treturn 0;\n&#125;\n\n\n#include &lt;stdio.h&gt;\n\nvoid print(int arr[], int sz)\n&#123;\n\tint i &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tint arr[] &#x3D; &#123; 1,2,3,4,5 &#125;;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);\n\tprint(arr, sz);\n\n\treturn 0;\n&#125;\n\n可以看到， 函数形参接受时的两种方式是等效的。\n六. 变长数组概述\n\n\n\n\n\n\n\n\n\n变长数组实际上就是数组[]里可以放变量表达式，在Linux环境下gcc可以使用，不过要注意的是，这样创建一个数组是不能初始化的。当然支持C99标准的编译器底下也可以这样使用。\n\n七. 总结\n\n\n\n\n\n\n\n\n\n数组的灵活运用可以高效地解决一些比较困难的问题，它可以很好地训练我们的编程思维。\n我们在使用数组时最好是要运用指针来操作，这样程序会更高效，占用内存会更少。\n\n","slug":"一文带你灵活使用C语言的数组","date":"2023-02-17T14:38:44.000Z","categories_index":"","tags_index":"","author_index":"坏 幸 运"},{"id":"fc86da1651adc032c38c6b773ee69698","title":"使用C语言实现初级扫雷小游戏","content":"一. 前言\n\n\n\n\n\n\n\n\n\n本章我们用C语言简单实现一个9×9雷阵的扫雷小游戏。\n说到扫雷想必大家都不陌生，开始我们点击一个小方块，那么这个小方块上会显示它周围八个小方块里雷的个数，凭借这个数值，在判断下一个要扫的位置（当然可能前面两步需要我们的幸运成分了），当我们除雷外的所有小方块都已经显示完了，那么扫雷成功。\n这里我们分框架（框架代码在主函数中）展示游戏的实现。\n游戏实现我们分装两个 .c （代码主函数与函数定义源代码）后缀的文件和一个 .h 的文件（头文件，函数声明）\n.h : game.h.c : test.c (主函数体文件) |||||| game.c (函数定义文件)\n\n\n\n这里我们先把头文件里的库函数，函数声明和定义的全局常量以及主函数的函数调用结构展示出来，以便后面有迹可循：\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 9\n#define COL 9\n#define ROWS ROW + 2\n#define COLS COL + 2\n#define MINE_COUNT 10\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret);\n\nvoid print_board(char board[ROWS][COLS], int row, int col);\n\nvoid add_mine(char board[ROWS][COLS], int row, int col);\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);\n\n#define _CRT_SECURE_NO_WARNINGS\n\n&#x2F;&#x2F; 1.初始化雷盘与扫雷盘\n&#x2F;&#x2F; 2.打印盘\n&#x2F;&#x2F; 3.布置雷\n&#x2F;&#x2F; 4.扫雷\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  1.PLAY  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  0.EXIT  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar mine[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\tchar show[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F; 初始化盘\n\tinit_board(mine, ROWS, COLS, &#39;0&#39;);\n\tinit_board(show, ROWS, COLS, &#39;*&#39;);\n\t&#x2F;&#x2F; print_board(mine, ROW, COL);\n\tprint_board(show, ROW, COL);\n\t&#x2F;&#x2F; 布置雷\n\tadd_mine(mine, ROW, COL);\n\tprint_board(mine, ROW, COL);\n\n\t&#x2F;&#x2F; 扫雷\n\tdown_mine(mine, show, ROW, COL);\n&#125;\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入扫雷游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tprintf(&quot;游戏结束：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tSleep(1000);\n\t\t\tsystem(&quot;cls&quot;);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\n\n\n只要我们分别在另外两个 .c 文件（一个是主函数体一个是函数定义）中引入（#include “game.h”） 那么三个文件就相互作用了。\n\n二. 游戏版面与开始游戏的构建\n我们首先要打印一个菜单供玩家选择&lt;输入1&gt;则进入游戏，&lt;输入0&gt;则退出游戏，&lt;输入其它的数&gt;则输入错误，然后继续输入判断。为了一开始就让用户先选择，再判断输入的值然后判断是否再次输入，这里我们采用do-while循环结构，无论如何用户先选择一次，然后do-while里头采用switch-case来判断输入的值，而菜单我们调用一个menu（）函数来打印，下面是在主函数里的代码实现：\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  1.PLAY  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  0.EXIT  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n&#125;\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入扫雷游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tprintf(&quot;游戏结束：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\n\n\n\n我们可以看到， 这样简易的游戏初始菜单就制作好啦。\n\n三. 扫雷初始化思路\n\n\n\n\n\n\n\n\n\n由上方雷盘可以看到是一个9×9的格子，但是我们在写程序时，如何能够判断9×9边边格子的周围八个格子雷的个数？如果我们定义一个二维数组只给它9行9列这样一个起始雷盘，当我们在扫边边格子的雷的时候，我们可能会需要一些复杂的计算来完成相关的程序，所以，为了更好的简易化以及能够精确判断每个格子周围的雷，我们在雷盘两边再加上两行两列，也就是说，我们定义的二维数组他应该是要11行11列这样的起始雷盘。\n我们游戏的雷盘是9×9的，但我们定义的二维数组是11×11的，所以，当我们在玩游戏时，被扫的雷盘的打印应该少去上下两行和左右两列。\n对于程序来说，我们是否能够将布置雷盘与扫雷放在一个盘里实现呢？答案是不能的，所以这里我们要定义两个二维数组，一个用来放雷的盘不打印，另一个用来排查雷的盘要打印，并且，这两个盘之间一定要能通过某种联系来相互作用（雷盘传雷位置，扫雷盘接受，扫时能够准确定位周围雷的个数）。\n这里我们设定，雷用字符 ‘1’ 来表示，其余地方为字符 ‘0’ ，刚开始初始化盘时，要布置雷的盘先全部元素放 ‘0’ ，用来扫雷的盘全部元素放字符 ‘ * ’ ，但是我们打印时，只打印9×9那块的区域（游戏版面设定）。\n\n四. 雷阵与扫雷盘初始化*由上说到，雷阵我们先全部放入字符 ‘0’ 初始化，扫雷盘全初始化字符 ‘ * ’，由于两个盘的数组大小相同，为了减少代码量，这里写个初始化函数调用两次（雷阵初始化的调用和扫雷盘初始化的调用），所以我们需要传参每个盘的初始化内容（字符）。以下是代码实现：\ninit_board(mine, ROWS, COLS, &#39;0&#39;); &#x2F;&#x2F; 雷阵的初始化\ninit_board(show, ROWS, COLS, &#39;*&#39;); &#x2F;&#x2F; 扫雷盘的初始化\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret) &#x2F;&#x2F; 接收传来的初始化字符\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; rows; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; cols; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; ret; &#x2F;&#x2F; 初始化\n\t\t&#125;\n\t&#125;\n&#125;\n\n五. 打印扫雷盘\n在我们玩扫雷游戏中，其显示的是9×9的格子，所以我们打印的扫雷盘也是要9×9的格子（尽管初始化二维数组为11×11，那是因为便于计算扫的周围那个格子周围的雷数），但是为了玩家更好的看清楚想要扫的格子的坐标，这里在打印的每行每列开头都标上序号，这样就不用去数格子了。\n以下是打印出来的效果：以下是代码实现：\n\nprint_board(show, ROW, COL); &#x2F;&#x2F; ROW &#x3D; 9 ； COL &#x3D; 9\n\nvoid print_board(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (j &#x3D; 0; j &lt;&#x3D; row; j++) &#x2F;&#x2F; 打印列的序号\n\t&#123;\n\t\tprintf(&quot;%d &quot;, j);\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\tfor (i &#x3D; 1; i &lt;&#x3D; row; i++)\n\t&#123;\n\t\tprintf(&quot;%d&quot;, i); &#x2F;&#x2F; 每打印一行初始化打印对应行数的序号\n\t\tfor (j &#x3D; 1; j &lt;&#x3D; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot; %c&quot;, board[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\n六. 布置雷\n布置雷这一步骤需要在雷阵实现，这里规定布置十个雷，由于我们每一把游戏的雷的位置是不同的（随机的），所以布置雷这一步骤需要电脑的随机性来布置，相应函数的使用为 rand，srand（为了使rand随机化需要用到的），time（时间戳），具体的介绍在上一节”C语言实现初级三子棋“有说到，所以这里便不再详细道来。\n由于是坐标定位，所以这里我们定义两个变量来接受电脑产生的随机值以作为二维数组的坐标来放置雷。\n电脑随机布置时，我们应该使用循环让电脑不断布置，当选中的格子是 ‘0’ ，便放雷，这样的动作做十次，但如果有重复就会另外找位置布置，所以实际上循环可能不止十次。\n每随机布置一个雷，我们便在初始化为字符 ‘0’ 的雷阵并且随机选中布置雷的格子上放上字符 ‘1’ ，这样我们便能分清楚雷与不是雷的区别，这样也有益于后面扫雷阶段的实现。\n由于是在9×9的范围来布置雷，所以这里我们需要限定电脑随机产生值的范围。\n当然如果想要看看布置雷的效果，在布置完后可以打印一下雷阵，但最终我们是不会打印的。以下是代码实现（代码展现是本模块的全部代码实现的展现，与其他功能的结构组合须看全代码）（也就是这三段代码是分开的）：\n\nadd_mine(mine, ROW, COL); \n\nsrand((unsigned int)time(NULL));\n\nvoid add_mine(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint count &#x3D; 0;\n\n\twhile (count &lt; MINE_COUNT) &#x2F;&#x2F; MINE_COUNT  &#x3D; 10（雷的个数） \n\t&#123;\n\t\tint x &#x3D; rand() % row + 1;\n\t\tint y &#x3D; rand() % col + 1;\n\n\t\tif (board[x][y] &#x3D;&#x3D; &#39;0&#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;1&#39;;\n\t\t\tcount++; &#x2F;&#x2F; 每布置一个计数一次\n\t\t&#125;\n\t&#125;\n&#125;\n\n七. 扫雷\n我们通过坐标选择需要扫的格子，当格子里的字符不是 ’1‘ 时，计算周围八个格子的雷数，值得注意的是，我们的选择和计算判断过程都是需要在雷阵盘上完成，但是我们展现出来的是这个格子周围的雷数，这就需要扫雷盘和雷盘建立起联系，一个计算分析判断，另一个接受展示，所以我们在写这么一个扫雷的函数时，两个盘的相关消息都要传递过去，这样便于两盘之间的相互联系，从而达到扫雷效果。下面是代码展示：\n\ndown_mine(mine, show, ROW, COL); &#x2F;&#x2F; 一个盘计算判断，另一个接受展示\n\nint around_mine(char mine[ROWS][COLS], int x, int y)\n&#123;\n\treturn (mine[x][y + 1] + mine[x][y - 1] + mine[x + 1][y] + mine[x - 1][y] + mine[x - 1][y - 1] + mine[x + 1][y + 1] + mine[x - 1][y + 1] + mine[x + 1][y - 1] - 8 * &#39;0&#39;);\n&#125;\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\tint count &#x3D; 0;\n\n\twhile (1)\n\t&#123;\n\t\tprintf(&quot;请输入要扫雷的坐标：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col)\n\t\t&#123;\n\t\t\tif (mine[x][y] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;很遗憾，你被炸死了！\\n&quot;);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tint ret &#x3D; around_mine(mine, x, y);\n\t\t\t\tshow[x][y] &#x3D; ret + &#39;0&#39;;\n\t\t\t\tcount++;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标不合法，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\n\t\tif (count &#x3D;&#x3D; ((row * col) - MINE_COUNT))\n\t\t&#123;\n\t\t\tprintf(&quot;扫雷成功！\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n可以看到，这里面又使用了一次函数定义调用，这次定义调用是为了计算周围的雷数，而我们扫雷盘上放的是字符，那么雷数如何转化到字符，这需要字符与整型数字之间的转化关系来完成。具体可看ASCLL码表。\n八. 整个程序的代码实现：\ngame.h：\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 9\n#define COL 9\n#define ROWS ROW + 2\n#define COLS COL + 2\n#define MINE_COUNT 10\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret);\n\nvoid print_board(char board[ROWS][COLS], int row, int col);\n\nvoid add_mine(char board[ROWS][COLS], int row, int col);\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);\n\ntest.c(主函数)（框架结构）：\n\n#define _CRT_SECURE_NO_WARNINGS\n\n&#x2F;&#x2F; 1.初始化雷盘与扫雷盘\n&#x2F;&#x2F; 2.打印盘\n&#x2F;&#x2F; 3.布置雷\n&#x2F;&#x2F; 4.扫雷\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  1.PLAY  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  0.EXIT  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar mine[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\tchar show[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F; 初始化盘\n\tinit_board(mine, ROWS, COLS, &#39;0&#39;);\n\tinit_board(show, ROWS, COLS, &#39;*&#39;);\n\t&#x2F;&#x2F; print_board(mine, ROW, COL);\n\tprint_board(show, ROW, COL);\n\t&#x2F;&#x2F; 布置雷\n\tadd_mine(mine, ROW, COL);\n\t&#x2F;&#x2F; print_board(mine, ROW, COL);\n\n\t&#x2F;&#x2F; 扫雷\n\tdown_mine(mine, show, ROW, COL);\n&#125;\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入扫雷游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tprintf(&quot;游戏结束：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tSleep(1000);\n\t\t\tsystem(&quot;cls&quot;);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\ngame.c(函数的定义：模块功能的实现)：\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include &quot;game.h&quot;\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; rows; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; cols; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; ret;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid print_board(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (j &#x3D; 0; j &lt;&#x3D; row; j++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, j);\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\tfor (i &#x3D; 1; i &lt;&#x3D; row; i++)\n\t&#123;\n\t\tprintf(&quot;%d&quot;, i);\n\t\tfor (j &#x3D; 1; j &lt;&#x3D; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot; %c&quot;, board[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nvoid add_mine(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint count &#x3D; 0;\n\n\twhile (count &lt; MINE_COUNT)\n\t&#123;\n\t\tint x &#x3D; rand() % row + 1;\n\t\tint y &#x3D; rand() % col + 1;\n\n\t\tif (board[x][y] &#x3D;&#x3D; &#39;0&#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;1&#39;;\n\t\t\tcount++;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint around_mine(char mine[ROWS][COLS], int x, int y)\n&#123;\n\treturn (mine[x][y + 1] + mine[x][y - 1] + mine[x + 1][y] + mine[x - 1][y] + mine[x - 1][y - 1] + mine[x + 1][y + 1] + mine[x - 1][y + 1] + mine[x + 1][y - 1] - 8 * &#39;0&#39;);\n&#125;\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\tint count &#x3D; 0;\n\n\twhile (1)\n\t&#123;\n\t\tprintf(&quot;请输入要扫雷的坐标：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col)\n\t\t&#123;\n\t\t\tif (mine[x][y] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;很遗憾，你被炸死了！\\n&quot;);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tint ret &#x3D; around_mine(mine, x, y);\n\t\t\t\tshow[x][y] &#x3D; ret + &#39;0&#39;;\n\t\t\t\tcount++;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标不合法，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\n\t\tif (count &#x3D;&#x3D; ((row * col) - MINE_COUNT))\n\t\t&#123;\n\t\t\tprintf(&quot;扫雷成功！\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n九. 总结\n\n\n\n\n\n\n\n\n\n咱们这里实现的扫雷只是初级的，游戏里点击一个格子它可能扫出一大块，这需要更复杂的算法来实现，所以扫雷小游戏值得我们继续研究，这可以提高我们的思维和能力。\n经过扫雷和三子棋两个小游戏的对比，我们可以发现其相同点和不同点，其算法的差异和框架的异同，独自完成这两个简易的小游戏可以大大提高我们的思维能力和代码的敏感性，建议大家能够独自完成。\n\n\n本章到此结束，谢谢大家。\n\n","slug":"使用C语言实现初级扫雷小游戏","date":"2023-02-17T14:37:11.000Z","categories_index":"","tags_index":"","author_index":"坏 幸 运"},{"id":"e0b663ff8593ec90044339189f2bc842","title":"C语言的分支与循环#熟练使用，出手就有#","content":"一. 前言\n\n\n\n\n\n\n\n\n分支和循环在C语言中几乎无处不在，作为重要的一部分，精确掌握其语法和运用逻辑，是继续向下学习的“地基”。\n二. 分支语句1. if 分支语句if 就是如果，如果怎么怎么样就干嘛干嘛，在C语言中，其表达效果也是如此。\nif (表达式)   &#x2F;&#x2F; 表达式为真执行if语句块，随后下面的分支语句都不判断执行，如果为假，判断下一个else if的表达式\n&#123;\n\t语句;\n&#125;\nelse if(表达式)  &#x2F;&#x2F; 这里的表达式只有if中的表达式为假才会判断其真假，如果为真，执行其语句块并不在判断执行下面的分支，为假则继续向下判断\n&#123;\n    语句;\n&#125;\nelse &#x2F;&#x2F; 如果前面分支的表达式都为假，执行else语句块\n&#123;\n    语句;\n&#125;\n\n\n\n\n值得注意的是，if后面如果只跟一条语句的话是可以不用打大括号的，不过最好是要打大括号，以免出现不必要的错误，并且，如果不打括号，那么后面的else就会与最近的if匹配，这样很可能造成bug。\n\n例如：\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);  \n\n\tif (n &lt;&#x3D; 10)\n\t\tif (n % 2 &#x3D;&#x3D; 0)\n\t\t\tprintf(&quot;hehe\\n&quot;);\n\telse\n\t\tprintf(&quot;haha\\n&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n如果这里我们输入12，按语法逻辑来说程序一走屏幕上应该是打印 “haha” ，但是，由于没有大括号，那条在格式上是与第一个if对齐的else语句实际上是与离他最近的那个if对齐，而第二个if在第一个if语句之下，所以将不会打印“haha”。\n所以我们一定要养成打大括号的好习惯！\n2. switch—case 语句这里先用段代码来阐明它的基本表达形式：\nswtich(表达式)\n&#123;\n\tcase 常量表达式:\n\t    执行语句;\n\t\tbreak;\n\tcase 常量表达式:\n\t    执行语句;\n\t\tbreak:\n    ......\n\tdefault:\n\t    执行语句;\n\t\tbreak:\n&#125;\n\n（1） switch 后面括号内的“表达式”必须是整数类型。也就是说可以是 int 型变量、char 型变量，也可以直接是整数或字符常量，哪怕是负数都可以。但绝对不可以是float 型变量、double 型变量、小数常量通通不行，全部都是语法错误。\n\n（2）观察上段代码，case后面跟的都是常量表达式，如果switch后面的表达式与某个case后面的常量表达式相同，那么将会执行这个case后面的语句，我们可以看到，每个case分支后面都跟了个break，这是为什么呢？\n\n\n我们看看下面这段代码：\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  1-5 为工作日 6 7 为休息日\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tswitch (n)\n\t&#123;\n\tcase 1:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 2:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 3:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 4:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 5:\n\t\tprintf(&quot;工作日\\n&quot;);\n\tcase 6:\n\t\tprintf(&quot;休息日\\n&quot;);\n\tcase 7:\n\t\tprintf(&quot;休息日\\n&quot;);\n\tdefault:\n\t\tprintf(&quot;输入错误\\n&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n从上面说的来看理论上我们运行程序输入1会打印 “工作日”，但实际上却不是如此：当我们输入2时：\n由上面的运行结果来看，我们很容易推出，如果case后面没有break，当我们执行一个case，后面的case都会依次被执行，那么我们现在加入break来看看：\n\n\n很明显，加入break后，每当执行一个case语句，后面的case便不会在执行，这里我们就清楚了break在switch语句中的作用：那就是停止执行下一个case，跳出switch分支语句。既然break有如此作用，那么上述代码case1-5和case6-7的重复是不是就写麻烦了，为此做出以下改进：\n\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tswitch (n)\n\t&#123;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\tprintf(&quot;工作日\\n&quot;);\n\t\tbreak;\n\tcase 6:\n\tcase 7:\n\t\tprintf(&quot;休息日\\n&quot;);\n\t\tbreak;\n\tdefault:\n\t\tprintf(&quot;输入错误\\n&quot;);\n\t\tbreak;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n运行结果如下：\n这样的运行结果与每个case后面都加语句和break的运行结果相同，并且代码变得更加简洁了，这是运用了case的性质和break的作用，所以当我们有很多重复项时，用switch—case语句是很好的选择。\n\n\n\n\n\n\n\n\n\n我们可以看到，代码里头还有一个 default：它的意思是，如果所有的case都没法执行，那么就执行default 后面的语句，当然，default可以放在switch里的任何一个位置，这是不影响的，别问为啥，语法规定可以哈哈哈哈哈。\n三 . 循环语句(while,  do-while,  for)\n\n\n\n\n\n\n\n\n循环顾名思义就是重复的做某事，C语言中也是如此，这三种循环大同小异，都存在判断表达式与循环体。\n1. while 循环while (判断表达式)\n&#123;\n\t语句块;\n&#125;\n\n\n\n如上，如果判断表达式为真，那么就做while里头的代码块，如果判断表达式为假，则while循环不会执行。当判断表达式一直为真时，那么将会重复执行其里面的代码，这时程序会一直运行不停止，所以，在while循环里头，我们要插入能达到我们目的的并且n次循环后能使判断表达式为假的代码，这样，while循环才会在达到我们想要的效果的同时终止循环。\n\n2. do-while 循环do  &#x2F;&#x2F; do 就是无论如何先执行一次do大括号里的代码块的语句\n&#123;\n\t代码块;\n&#125; while (判断表达式);  &#x2F;&#x2F; 这里的判断 等do做完后在执行\n\n实际上，do-while 循环与 while 循环的差别就在与 do-while 循环是无论如何先执行一遍大括号里的代码语句再进行判断表达式，而 while 是直接判断表达式是否为真，再决定要不要执行大括号里的语句。\n要注意的是，do-while 循环的 while 后面是要加 ”;“ 号的，他表示一个语句的结束标志。\n\n3. for 循环for (表达式1; 表达式2; 表达式3)\n&#123;\n\t语句块;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;  表达式1 ：初始化表达式\n&#x2F;&#x2F;&#x2F;&#x2F;  表达式2 ：判断控制表达式\n&#x2F;&#x2F;&#x2F;&#x2F;  表达式3 ：调节器\n\n\nfor 循环是将初始化，判断控制表达式，调节功能表达式集为一体的循环。这也是他与while，do-while 循环最大的不同。这也使他运用起来更方便更简洁，所以我认为，for 循环是所有循环里的首选。\n\n4. 比较 （输出1-10的和）while：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint i &#x3D; 1;\n\tint sum &#x3D; 0;\n\n\twhile (i &lt;&#x3D; 10)\n\t&#123;\n\t\tsum +&#x3D; i;\n\t\ti++;\n\t&#125;\n\n\tprintf(&quot;%d&quot;, sum);\n\n\treturn 0;\n&#125;\ndo-while：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint i &#x3D; 1;\n\tint sum &#x3D; 0;\n\n\tdo\n\t&#123;\n\t\tsum +&#x3D; i;\n\t\ti++;\n\t&#125; while (i &lt;&#x3D; 10);\n\n\tprintf(&quot;%d&quot;, sum);\n\n\treturn 0;\n&#125;\nfor：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint sum &#x3D; 0;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)\n\t&#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\n\tprintf(&quot;%d&quot;, sum);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n三段代码的执行结果是一样的，但其书写形式却不同，我们可以看到，for循环相对于其它两个循环是最简明的。在某些环境中，while与for可以互相换着用（推荐使用for），而在不同情况下，还要具体问题具体分析，但绝大多数用for循环都可以解决，而 do-while 由于他的特殊性只在某些特定的场景才使用。\n四. break 与 continue 的作用1. break\n\n\n\n\n\n\n\n\nbreak意为停止终止的意思，他在C语言中被广泛使用，很多分支与循环的调控与衔接都需要它来解决。\n1.1  break 在分支中的作用\n这里明确指出，break 在 if 分支语句中没有任何作用，他不能跳出 if 语句（语法规定），但是如果在循环里头的 if 分支用 break ，为真程序则跳出（终止）循环。\nswitch-case 是 break 的真爱粉，其作用在上面 ↑ 讲解switch时有说到。可以这么说，几乎所有的swtich分支语句都需要break。\n\n1.2 break 在循环里的作用\n很简单，break 在循环当中的作用就是跳出循环（终止循环的意思）。当你的循环为你达到了某个你需要的结果时你便可以用break跳出循环使循环不在进行。\n\n2. continuecontinue 可以说只在循环里头起作用，他的作用是，当你在循环里头满足了执行continue的条件，那么continue将会结束本次循环，直接进行下一次循环。实际上continue在程序设计中用的比较少，它的功能局限性太大了。\n五. 总结\n\n\n\n\n\n\n\n\n分支与循环的语法虽然简单，但它在实际运用中确实烧脑的存在，今后几乎所有你会遇到的问题，他都需要分支与循环来逻辑实现。因此，分支与循环我们不仅要学会，还要练透，并且能十分清楚他的逻辑。\n","slug":"C语言的分支与循环-熟练使用，出手就有","date":"2023-02-17T14:08:48.000Z","categories_index":"","tags_index":"","author_index":"坏 幸 运"},{"id":"d5a6879e81b57b97e13538ee2b9c1dd3","title":"C语言实现初级三子棋","content":"一. 前言\n\n\n\n\n\n\n\n\n\n本章我们用C语言来实现一个初级的三子棋小游戏，三子棋想必大家都玩过，只要每一行或每一列或对角线三个棋相同，那么便获得胜利，由此我们分析下棋的步骤与获胜判断，来构建一个C语言三子棋的代码框架。\n游戏实现我们分装两个 .c （代码主函数与函数定义源代码）后缀的文件和一个 .h 的文件（头文件，函数声明）\n.h : game.h .c : test.c  (主函数体文件) ||||||    game.c (函数定义文件)\n\n\n以下是头文件里的库函数和函数声明：\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 3\n#define COL 3\n\nvoid init_board(char board[ROW][COL], int row, int col);\n\nvoid print_board(char board[ROW][COL], int row, int col);\n\nvoid player_move(char board[ROW][COL], int row, int col);\n\nvoid computer_move(char board[ROW][COL], int row, int col);\n\nchar is_win(char board[ROW][COL], int row, int col);\n\n\n只要我们分别在另外两个 .c 文件（一个是主函数体一个是函数定义）中引入\n\n#include “game.h”  那么三个文件就相互作用了。\n这里先把主函数的调用结构放在这，以便后面读起来有迹可循：\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    1.PLAY    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    0.EXIT    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar ret &#x3D; 0;\n\tchar board[ROW][COL];\n\n\tinit_board(board, ROW, COL); &#x2F;&#x2F; 初始化棋盘\n\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\n\twhile (1)\n\t&#123;\n\t\tplayer_move(board, ROW, COL); &#x2F;&#x2F; 玩家下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\tcomputer_move(board, ROW, COL); &#x2F;&#x2F; 电脑下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\tif (ret &#x3D;&#x3D; &#39;*&#39;)\n\t&#123;\n\t\tprintf(&quot;玩家获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;#&#39;)\n\t&#123;\n\t\tprintf(&quot;电脑获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;Q&#39;)\n\t&#123;\n\t\tprintf(&quot;平局！\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 玩家赢返回‘*’\n&#x2F;&#x2F; 电脑赢返回‘#’\n&#x2F;&#x2F; 平局返回 ‘Q’\n&#x2F;&#x2F; 游戏继续返回 ‘C’\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\t\t\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;您已进入三子棋游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tSleep(1000); &#x2F;&#x2F; 游戏玩完后停顿一秒\n\t\t\tsystem(&quot;cls&quot;); &#x2F;&#x2F; 清屏\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏!&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误,请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\n\n\n\n二. 游戏版面与开始游戏的构建\n我们首先要打印一个菜单供玩家选择&lt;输入1&gt;则进入游戏，&lt;输入0&gt;则退出游戏，&lt;输入其它的数&gt;则输入错误，然后继续输入判断。为了一开始就让用户先选择，再判断输入的值然后判断是否再次输入，这里我们采用do-while循环结构，无论如何用户先选择一次，然后do-while里头采用switch-case来判断输入的值，而菜单我们调用一个menu（）函数来打印，下面是在主函数里的代码实现：\n\n#include &lt;stdio.h&gt;\n\nvoid menu()\n&#123;\n\tprintf(&quot;***************************************\\n&quot;);\n\tprintf(&quot;***************************************\\n&quot;);\n\tprintf(&quot;************    1.PLAY     ************\\n&quot;);\n\tprintf(&quot;************    0.EXIT     ************\\n&quot;);\n\tprintf(&quot;***************************************\\n&quot;);\n\tprintf(&quot;***************************************\\n&quot;);\n&#125;\n\nvoid test()\n&#123;\n\tint input &#x3D; 0;\n\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入三子棋游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\n\t\t\t&#x2F;&#x2F;game(); &#x2F;&#x2F;&#x2F;  游戏实现\n\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误，请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\t&#125; while (input);  &#x2F;&#x2F;&#x2F;  以输入的值来判断是否还想再来一次游戏\n&#125;\n\nint main()\n&#123;\n\ttest();  &#x2F;&#x2F;&#x2F;  整体的框架结构函数\n\n\treturn 0;\n&#125;\n\n\n我们可以看到， 这样简易的游戏初始菜单就制作好啦。\n\n三. 棋盘初始化与打印棋盘\n棋盘的初始化与棋盘的打印是在上面的game（）函数里实现的，我们知道，三子棋的棋盘是3×3的，这里我们不妨定义一个字符类型的二维数组（三行三列），开始我们每个元素放一个空格，这便棋盘初始化了。\n\n下面是初始化代码实现：\nvoid init_board(char board[ROW][COL], int row, int col); void init_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; &#39; &#39;;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\n\n而这里的难点在于如何将一个棋盘打印出来，首先我们来看下棋盘的样子：\n可以看到，第一行的元素是 空格%c空格|空格%c空格|空格%c空格（%c为初始化的空格）（这一行打印了三次），第二行的元素为—|—|—（这一行打印了两次），为了实打实的打印棋盘，这里需要判断语句与循环语句的相互作用来实现，下面是代码实现：\n\nvoid print_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)  &#x2F;&#x2F; 打印三次，每次分别打印两行内容（最后一次打印一行）\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)  &#x2F;&#x2F; 打印  ； | |  ；\n\t\t&#123;\n\t\t\tprintf(&quot; %c &quot;, board[i][j]);\n\t\t\tif (j &lt; col - 1)  &#x2F;&#x2F;  最后一个 | 不打印\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t\tif (i &lt; row - 1)  &#x2F;&#x2F; 最后一行 ---|---|---  不打印\n\t\t&#123;\n\t\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;---&quot;);\n\t\t\t\tif (j &lt; col - 1)  &#x2F;&#x2F;  最后一个 | 不打印\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\n四. 玩家下棋\n玩家下棋是输入棋盘的坐标然后将 ‘ * ’ 号放进去 ，由于玩家很大可能不是程序员，不知道数组的下标是从零开始，这里我们采用1，2，3混合坐标来输入，如果玩家输入两个值（用空格隔开）形成的坐标在1，2，3三个数字组成的成对组合范围内并且输入的那个坐标此时为 ‘  ’ ，那么玩家下棋成功，放个 ‘ * ’ 字符进去，如果玩家输入的坐标超过所形成范围或者该坐标已有棋子，那么提示玩家输入的错误，并且重新输入。下面是玩家下棋的代码实现：\n\nvoid player_move(char board[ROW][COL], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\n\twhile (1)  &#x2F;&#x2F; 用户重复输入直到下棋成功为止跳出\n\t&#123;\n\t\tprintf(&quot;玩家下棋：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; 3 &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; 3)\n\t\t&#123;\n\t\t\tif (board[x - 1][y - 1] &#x3D;&#x3D; &#39; &#39;)\n\t\t\t&#123;\n\t\t\t\tboard[x - 1][y - 1] &#x3D; &#39;*&#39;;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;该位置已被占，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标错误，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;\n\n五. 电脑下棋\n电脑下棋，其实就是电脑随机产生两个可控（1 - 3）数然后接受值并将值重复与玩家下棋相同道理的代码实现。\n\n为了使产生的随机数一直在变化，由于时间是一直在变化的，所以这里我们使用时间函数：\n\n下面是电脑下棋的整个代码实现：\n\n\nvoid computer_move(char board[ROW][COL], int row, int col)\n&#123;\n\tprintf(&quot;电脑下棋：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\twhile (1)  &#x2F;&#x2F; 电脑随机产生数判断下棋成功跳出   下面是产生随机坐标判断\n\t&#123;\n\t\tint x &#x3D; rand() % row;\n\t\tint y &#x3D; rand() % row;\n\t\tif (board[x][y] &#x3D;&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;#&#39;;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n由于电脑下棋是随机的，所以我们想赢是很简单的事啦。\n对了， rand使用前提需要调用srand（），它在前面的主函数代码块中显示啦。\n\n六. 判断输赢\n三子棋当三个棋子相同时便获胜，这里可以是三行三列两对角线，我们如何来判断输赢呢？\n我们在每一次玩家下棋完或者电脑下棋完后都要判断他是否获胜，这里获胜的判断我们返回一个值来进行比对，比对如下（这里只是展示一下如何判断返回值来确定是否获胜，代码不连贯不衔接，语法错误存在）：\n\n&#x2F;&#x2F; 玩家赢返回‘*’\n&#x2F;&#x2F; 电脑赢返回‘#’\n&#x2F;&#x2F; 平局返回 ‘Q’\n&#x2F;&#x2F; 游戏继续返回 ‘C’\n\n\nret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\nif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n&#123;\n\tbreak;\n&#125;\n\n\nif (ret &#x3D;&#x3D; &#39;*&#39;)\n&#123;\n\tprintf(&quot;玩家获胜！\\n&quot;);\n&#125;\nelse if (ret &#x3D;&#x3D; &#39;#&#39;)\n&#123;\n\tprintf(&quot;电脑获胜！\\n&quot;);\n&#125;\nelse if (ret &#x3D;&#x3D; &#39;Q&#39;)\n&#123;\n\tprintf(&quot;平局！\\n&quot;);\n&#125;\n\n\n\n\n下面是输赢本质 is_win() 函数定义的一个代码展示：\n\nchar is_win(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)  &#x2F;&#x2F; 行判断\n\t&#123;\n\t\tif (board[i][0] &#x3D;&#x3D; board[i][1] &amp;&amp; board[i][1] &#x3D;&#x3D; board[i][2] &amp;&amp; board[i][0] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[i][0];\n\t\t&#125;\n\t&#125;\n\n\tfor (j &#x3D; 0; j &lt; col; j++)  &#x2F;&#x2F; 列判断\n\t&#123;\n\t\tif (board[0][j] &#x3D;&#x3D; board[1][j] &amp;&amp; board[1][j] &#x3D;&#x3D; board[2][j] &amp;&amp; board[0][j] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[0][j];\n\t\t&#125;\n\t&#125;\n\n\tif (board[0][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[2][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;) &#x2F;&#x2F; 对角线判断\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\tif (board[2][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[0][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;)  &#x2F;&#x2F; 对角线判断\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\treturn &#39;C&#39;;  &#x2F;&#x2F; 这里如果前面的语句都没进入，那么返回 ‘C’ ，游戏继续\n&#125;\n\n七. 整体的代码展示\ngame.h\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 3\n#define COL 3\n\nvoid init_board(char board[ROW][COL], int row, int col);\n\nvoid print_board(char board[ROW][COL], int row, int col);\n\nvoid player_move(char board[ROW][COL], int row, int col);\n\nvoid computer_move(char board[ROW][COL], int row, int col);\n\nchar is_win(char board[ROW][COL], int row, int col);\n\n\n\ntest.c (主函数模块)：\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    1.PLAY    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    0.EXIT    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar ret &#x3D; 0;\n\tchar board[ROW][COL];\n\n\tinit_board(board, ROW, COL); &#x2F;&#x2F; 初始化棋盘\n\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\n\twhile (1)\n\t&#123;\n\t\tplayer_move(board, ROW, COL); &#x2F;&#x2F; 玩家下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\tcomputer_move(board, ROW, COL); &#x2F;&#x2F; 电脑下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\tif (ret &#x3D;&#x3D; &#39;*&#39;)\n\t&#123;\n\t\tprintf(&quot;玩家获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;#&#39;)\n\t&#123;\n\t\tprintf(&quot;电脑获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;Q&#39;)\n\t&#123;\n\t\tprintf(&quot;平局！\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 玩家赢返回‘*’\n&#x2F;&#x2F; 电脑赢返回‘#’\n&#x2F;&#x2F; 平局返回 ‘Q’\n&#x2F;&#x2F; 游戏继续返回 ‘C’\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\t\t\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;您已进入三子棋游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tSleep(1000); &#x2F;&#x2F; 游戏玩完后停顿一秒\n\t\t\tsystem(&quot;cls&quot;); &#x2F;&#x2F; 清屏\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏!&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误,请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;\n\n\n\ngame.c (函数实现文件)\n\n#include &quot;game.h&quot;\n\nvoid init_board(char board[ROW][COL], int row, int col); void init_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; &#39; &#39;;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nvoid print_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot; %c &quot;, board[i][j]);\n\t\t\tif (j &lt; col - 1)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t\tif (i &lt; row - 1)\n\t\t&#123;\n\t\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;---&quot;);\n\t\t\t\tif (j &lt; col - 1)\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nvoid player_move(char board[ROW][COL], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\n\twhile (1)\n\t&#123;\n\t\tprintf(&quot;玩家下棋：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; 3 &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; 3)\n\t\t&#123;\n\t\t\tif (board[x - 1][y - 1] &#x3D;&#x3D; &#39; &#39;)\n\t\t\t&#123;\n\t\t\t\tboard[x - 1][y - 1] &#x3D; &#39;*&#39;;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;该位置已被占，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标错误，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid computer_move(char board[ROW][COL], int row, int col)\n&#123;\n\tprintf(&quot;电脑下棋：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\twhile (1)\n\t&#123;\n\t\tint x &#x3D; rand() % row;\n\t\tint y &#x3D; rand() % row;\n\t\tif (board[x][y] &#x3D;&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;#&#39;;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\nchar is_win(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tif (board[i][0] &#x3D;&#x3D; board[i][1] &amp;&amp; board[i][1] &#x3D;&#x3D; board[i][2] &amp;&amp; board[i][0] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[i][0];\n\t\t&#125;\n\t&#125;\n\n\tfor (j &#x3D; 0; j &lt; col; j++)\n\t&#123;\n\t\tif (board[0][j] &#x3D;&#x3D; board[1][j] &amp;&amp; board[1][j] &#x3D;&#x3D; board[2][j] &amp;&amp; board[0][j] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[0][j];\n\t\t&#125;\n\t&#125;\n\n\tif (board[0][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[2][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;)\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\tif (board[2][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[0][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;)\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\treturn &#39;C&#39;;\n&#125;\n\n八. 总结\n\n\n\n\n\n\n\n\n三子棋对我们综合使用分支，循环，函数有很好的训练效果，只有我们不断的去写代码，去掌握语法之间的逻辑，才能更细致的打出优质程序。\n","slug":"C语言实现初级三子棋","date":"2023-02-17T14:07:06.000Z","categories_index":"","tags_index":"","author_index":"坏 幸 运"},{"id":"a49297b33fb7686d3c6c056b10f0d94d","title":"C语言函数篇（全）","content":"一.前言本章为个人所学所理解的C语言中函数篇的相关知识，定有不足，还望大家多多指教。\n二.什么是函数？函数是一段可以重复使用的代码，用来独立地完成某个功能。\n三.函数的分类：函数可以分为库函数和自定义函数。\n1.库函数\n\n\n\n\n\n\n\n\n在说库函数之前，先给大家推荐一个网站，这个网站可以搜索到所有C语言中的库函数，它包含了这些函数的信息和如何使用的场景介绍，下面是它的网址：[cplusplus]https://legacy.cplusplus.com/\n介绍：C语言在发布时已经为我们封装好了很多函数，它们被分门别类地放到了不同的头文件中（暂时先这样认为），使用这些函数时引入对应的头文件即可。这些函数是已经被编写的且效率极高，因此，为了某些功能的实现，引入库函数是首选。比如：strlen  strcpy  memcet\n1.1 strlen的作用为求字符串长度这里放段代码展示其作用\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; &#x2F;&#x2F;引入包含strlen函数的头文件\n\nint main()\n&#123;\n\tchar arr[] &#x3D; &quot;hello&quot;;\n\n\tint ret &#x3D; strlen(arr);  &#x2F;&#x2F; 将求出的字符串返回值用整型变量接受\n\n\tprintf(&quot;%d\\n&quot;, ret);\n\n\treturn 0;\n&#125;\n下面是运行结果很明显strlen求出的值的确是“hello”的长度值。\n1.2strcpy与memset函数的使用可以说strcpy与memset有相似之处，在某些场景，这两个函数都能将其实现\n1.2.1strcpy通俗来说，strcpy是将一个字符串里的内容拷贝到另一个字符串里，值得注意的是，当一个字符串拷贝到另一个字符串里时，其第一个字符串里的字符串结束标志 “\\0” 也被拷贝进第二个字符串里，这时第二个字符串里原有的内容就会被两个“\\0”包围，从而打印第二个字符串时为第一个字符串的内容。\n代码实现：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;******&quot;;\n\tchar arr2[] &#x3D; &quot;abc&quot;;\n\n\tstrcpy(arr1, arr2);  &#x2F;&#x2F;&#x2F; 将arr2打印到目的地arr1中\n\n\tprintf(&quot;%s\\n&quot;, arr1);\n\n\treturn 0;\n&#125;\n运行结果\n1.2.2 memsetC 库函数 void *memset(void *ptr, int value, size_t num) 复制字符 value（一个无符号字符）到参数 ptr 所指向的字符串的前 num 个字符。\n代码实现：\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; &#x2F;&#x2F;  用 memset 对应头文件\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;########&quot;;\n\n\tmemset(arr1, &#39;*&#39;, 4);   &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  将4个‘*’字符复制到arr1当中\n\n\tprintf(&quot;%s\\n&quot;, arr1);\n\n\treturn 0;\n&#125;\n运行结果：\n库函数还有很多，这里只是举的几个例子，如果要多的了解，可以访问上面给的网站。\n2. 自定义函数自定义函数是自己实现的为了完成整个程序某个功能所设置的，他能多次调用，服务于整个程序，并且自定义函数各模块之间尽量功能独立。\n2.1 为什么要有自定义函数？大家想想，如果所有的功能库函数都为你提供了，那还关程序员啥事？自定义函数在某种程度上更高于库函数，他能体现一个程序员的水平如何。\n2.2 自定义函数的组成与例子ret_type function_name(para, *)\n&#123;\n\t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  函数体\n&#125;\nret_type &#x2F;&#x2F;返回类型\nfunction_name &#x2F;&#x2F; 函数名\npara &#x2F;&#x2F; 函数参数\n* &#x2F;&#x2F; 另一个参数 ，待定义\n例如：1.（计算两个整型变量的和）（Add）\n#include &lt;stdio.h&gt;\n\n&#x2F;&#x2F; 这里返回值为整型\nint Add(int a, int b)  &#x2F;&#x2F;&#x2F;  用两个整型值接受传来的 a b ，这里可以重名\n&#123;\n\treturn (a + b);\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\t&#x2F;&#x2F; ret 接受返回值\n\tint ret &#x3D; Add(a, b); &#x2F;&#x2F; 传参 求和\n\n\tprintf(&quot;%d\\n&quot;, ret); &#x2F;&#x2F; 打印和值\n\n\treturn 0;\n&#125;\n运行结果：例 2. 求一个整数的位数\n#include &lt;stdio.h&gt;\n\nint fun(int n)\n&#123;\n\tint count &#x3D; 0;\n\n\twhile (n &gt; 0)\n\t&#123;\n\t\tn &#x3D; n &#x2F; 10;\n\t\tcount++;\n\t&#125;\n\n\treturn count;\n&#125;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tint ret &#x3D; fun(n);\n\n\tprintf(&quot;%d\\n&quot;, ret);\n\n\treturn 0;\n&#125;\n运行结果：这里函数名最好是取与功能相关的名字，这样更具可读性。\n2.3 void说明：如果一个函数的返回类型为void，表示这个函数没有返回值，一般这样使用可能是为了打印某个东西，也可能是将某个整型变量或者数组元素改变。例如：这里将数组元素改变。\n#include &lt;stdio.h&gt;\n\nvoid ecg(int arr[], int sz)\n&#123;\n\tint i &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tarr[i] &#x3D; 0;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tint arr[3] &#x3D; &#123; 1,2,3 &#125;;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);  &#x2F;&#x2F; 求数组 长度&#x2F;元素个数\n\n\tecg(arr, sz); &#x2F;&#x2F;&#x2F;&#x2F; 这里我们将arr数组内容全改为0\n\n\tint i &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;\n运行结果：这里我们将整型数组的内容全部改为 0 。\n四. 函数的参数1. 实际参数（实参）\n\n\n\n\n\n\n\n\n实参为传递给函数的参数，它可以是常量，表达式，函数（这里实参作为另一个函数的返回值）等。在实参传递时，他必须要有确定的值以便于形参接受。\n2.形式参数（形参）\n\n\n\n\n\n\n\n\n形参是实参的一份临时拷贝，当一个函数被调用时，形参才被实例化，当函数结束时，形参也相继被释放。\n五. 函数的调用1.传值调用例如：求两个数的最大值\n#include &lt;stdio.h&gt;\n\nint Max(int a, int b)\n&#123;\n\treturn (a &gt; b ? a : b);\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\n\tint ret &#x3D; Max(a, b); &#x2F;&#x2F;&#x2F;&#x2F; 这里传递的是 a b 的值\n\n\tprintf(&quot;MAX &#x3D; %d&quot;, ret);\n\n\treturn 0;\n&#125;\n运行结果：\n2. 传址调用当我们调用函数想要改变实参的值，这是我们应该使用传址调用，因为形参接受实参值时会开辟另外的空间来存放，这时想要通过改变形参来达到改变实参的目的，就不会实现，因为地址不同，所以我们要传地址。例如：交换两个整型值\n#include &lt;stdio.h&gt;\n\nvoid ecg(int* a, int* b)\n&#123;\n\tint tmp &#x3D; *a;\n\t*a &#x3D; *b;\n\t*b &#x3D; tmp;\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\tprintf(&quot;交换前：%d %d\\n&quot;, a, b);\n\n\tecg(&amp;a, &amp;b);\n\n\tprintf(&quot;交换后：%d %d\\n&quot;, a, b);\n\n\treturn 0;\n&#125;\n运行结果：\n六. 函数的嵌套调用和链式访问1.函数的嵌套调用这里用代码来展现：\n#include &lt;stdio.h&gt;\n\nint ADD(int c) &#123;\n\treturn 2 * c;\n&#125;\n\nint doubleAdd(int a, int b)  \n&#123;\n\tint c &#x3D; a + b;\n\n\tint rets &#x3D; ADD(c);  &#x2F;&#x2F;&#x2F;&#x2F;  调用 2*实参 的函数\n\n\treturn rets;\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\n\tint ret &#x3D; doubleAdd(a, b);  &#x2F;&#x2F;&#x2F;&#x2F;  调用函数\n\n\tprintf(&quot;%d\\n&quot;, ret);\n\n\treturn 0;\n&#125;\n\n2. 函数的链式访问把一个函数的返回值作为另一个函数的参数这里用一段典型代码来表示：\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tprintf(&quot;%d&quot;, printf(&quot;%d&quot;, printf(&quot;%d&quot;, 43)));\n\n\treturn 0;\n&#125;\n补充：printf函数返回值是一个数的位数 ，也就是有几个数。\n七. 函数的声明和定义1. 函数的声明（1）在一个项目中声明一般在头文件里，定义与使用一般在不同的 .C 文件中。\n（2）函数的使用一定要先定义后声明后使用，如果一个自定义函数模块放在main函数后面，那么在main函数前一定要声明，不然当你在main函数中使用定义的函数时，编译器从上至下编译你的代码不会先编译你的函数定义的内容，这时就会报某某未定义错误。（3）声明就是告诉编译器函数叫什么，参数是什么，返回类型是什么。\n2. 函数的定义定义就是函数功能的实现，使它能够完成项目的某个模块。前面有定义的例子，这里就不举例了。\n八. 函数的递归1. 什么是递归？\n\n\n\n\n\n\n\n\n递归实际上就是程序自己调用自己，它常常可以把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，这可以大大减少代码量，所以递归的主要思考方式在于：把大事化小。\n2. 递归必要的两个条件 1.存在限制条件，当满足这个限制条件后，递归便不再进行。 2.每次递归第调用都要越来越接近这个限制条件。\n3. 递归练习1.求n的阶乘#include &lt;stdio.h&gt;\n\nint jc(int n)\n&#123;\n\tint i &#x3D; 0;\n\n\tif (n &lt;&#x3D; 1)\n\t&#123;\n\t\treturn 1;\n\t&#125;\n\telse\n\t&#123;\n\t\treturn n * jc(n - 1);\n \t&#125;\n&#125;\n&#x2F;&#x2F;递归\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tint ret &#x3D; jc(n);\n\n\tprintf(&quot;%d&quot;, ret);\n\n\treturn 0;\n&#125;\n2.正序打印一个整型值的每一位#include &lt;stdio.h&gt;\n\nvoid Print(int n)\n&#123;\n\tif (n &gt; 0)\n\t&#123;\n\t\tPrint(n &#x2F; 10);\n\t&#125;\n\telse\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\tprintf(&quot;%d &quot;, n % 10);\n&#125;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tPrint(n);&#x2F;&#x2F; 正序打印一个整数的每一位  \n\n\treturn 0;\n&#125;\n\n3. 递归实现strlen求字符串长度#include &lt;stdio.h&gt;\n\nint my_strlen(char* str)\n&#123;\n\tif (*str !&#x3D; &#39;\\0&#39;)\n\t&#123;\n\t\treturn 1 + my_strlen(str + 1);\n\t&#125;\n\telse\n\t&#123;\n\t\treturn 0;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tchar arr[] &#x3D; &quot;hello&quot;;\n\n\tint len &#x3D; my_strlen(arr);\n\tprintf(&quot;%d&quot;, len);\n\n\treturn 0;\n&#125;\n\n4. 递归的局限性\n\n\n\n\n\n\n\n\n值得注意的是：因为递归有以上良好的功能，所以其思考难度较大。\n\n\n\n\n\n\n\n\n\n有时，递归使代码量大大减少的同时也增加了程序的运行难度（运行效率大大降低，如：求第n个斐波那契数)，并且其可读性没有非递归那么好，所以递归也要好好思考来选择。\n\n\n\n\n\n\n\n\n\n如果递归使用不当，就会出现栈溢出（“Stack overflow”）现象，这是因为每次函数调用都会在内存的栈区开辟一个自己的空间，如果递归过多导致内存栈空间开辟过多，这时就会出现溢出现象。\n九. 总结\n\n\n\n\n\n\n\n\n总的来说，函数在C语言中具有相当高的地位，它的存在使得一个项目更具模块化，便捷化，实效性和可读性，因此，我们在学习C语言当中，应养成函数定义这一习惯，并将使用函数的思维融会贯通。\n","slug":"C语言函数篇（全）","date":"2023-02-17T14:04:16.000Z","categories_index":"","tags_index":"","author_index":"坏 幸 运"}]