{"title":"【基础算法】关于高精度计算的问题【很高位数数据的加减乘除(相关代码用C++实现)】","uid":"48de73fbd4a7bbcd1c473c6c29503249","slug":"【基础算法】关于高精度计算的问题【很高位数数据的加减乘除-相关代码用C-实现-】","date":"2023-03-03T15:49:06.000Z","updated":"2023-03-03T15:50:14.498Z","comments":true,"path":"api/articles/【基础算法】关于高精度计算的问题【很高位数数据的加减乘除-相关代码用C-实现-】.json","keywords":null,"cover":"/photo/R-C (6).jpeg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><ul>\n<li>当我们在利用计算机进行一些计算时，可能会遇到这类问题 ： <strong>有些计算要求精度高，希望计算的数的位数可达几十位甚至几百位，虽然计算机的计算精度也算较高了，但因受到硬件的限制，往往达不到实际问题所要求的精度。</strong></li>\n<li>这时我们就可以通过程序设计来解决这类问题，<code>例如：</code><font color=red><strong>创建一个数组，通过数组来存放高精度数的每一位上的数</strong></font>。</li>\n</ul>\n<hr>\n<h1 id=\"1-高精度加法\"><a href=\"#1-高精度加法\" class=\"headerlink\" title=\"1.高精度加法\"></a>1.高精度加法</h1><ul>\n<li><p>高精度加法是两个位数很大的两个数相加，例如<code>1234567898756432123456789 + 66666666666666666666666</code>，这时候我们用平常的整型或者长整型去存放数据都是会溢出导致数据丢失的，所以此时我们可以用一个数组来存放每个数相对应位上的数（使用<code>vector&lt;int&gt;</code>， 假设这两个高精度数都大于<code>0</code>）。</p>\n</li>\n<li><p>不过在<code>C++</code>中，直接将数输入到<code>vector</code>中是不可取的，并且加法是从两个数的低位开始相加一直加到高位，如果我们正常输入从高位开始存放的话，对于后面程序的设计是不方便的，所以这里我们用<code>string</code>来表示相应高精度数，然后将这个string从低位开始转化成整数依次存放在<code>vector&lt;int&gt;</code>当中，这样两个<code>vector&lt;int&gt;</code>就是我们想要的高精度数了。</p>\n</li>\n<li><p>同时我们需要另一个<code>vector&lt;int&gt;</code>来存放相加后的数，由于相加数的存放是倒着的，所以最终的结果也是倒着存放在<code>vector&lt;int&gt;</code>中的，此时打印就需要从后面往前面打印输出。</p>\n</li>\n<li><p>加法不难，但要注意的是，如何在程序中表示进位，我们都知道，每一位数相加超过<code>10</code>就要进位<code>1</code>，表示这一位的前一位要<code>+1</code>。3和5相加为8不用进位，而7和8相加要进位，最后在这一位留下来的是<code>（7 + 8）- 10 = 5</code>，在程序中可以表示为<code>（7 + 8）% 10</code>。而这个<code>%10</code>就显得格外重要了，如果你相加后的数小于<code>10</code>，它<code>%10</code>后，还是它本身，如果大于<code>10</code>，它就相当于去掉一个<code>10</code>，剩下的数就放进表示最终答案的<code>vector&lt;int&gt;</code>。</p>\n</li>\n<li><p>最后要注意的是，两个位上的数相加后的结果要<code>/=10</code>,这是表示要除去这一位该留下的结果以及得到需要进的位，例如：<code>7 + 8 = 15</code> ，在该位应该留下的最终结果为 <code>15 % 10 = 5</code>，最后 <code>15 /= 10</code> 得到<code>1</code>，表示要进位<code>1</code>，该位的结果<code>5</code>除去。</p>\n</li>\n</ul>\n<p><font color=red><strong>下面是相关操作的代码实现：</strong></font></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B)\n&#123;\n\tvector&lt;int&gt; C;\n\n\tint tmp &#x3D; 0;\n\n\tfor (int i &#x3D; 0; i &lt; A.size() || i &lt; B.size() || tmp; i++)\n\t&#123;\n\t\tif (i &lt; A.size()) tmp +&#x3D; A[i];\n\t\tif (i &lt; B.size()) tmp +&#x3D; B[i];\n\t\tC.push_back(tmp % 10);\n\t\ttmp &#x2F;&#x3D; 10;\n\t&#125;\n\n\twhile (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n\treturn C;\n&#125;\n\nint main()\n&#123;\n\tstring a, b;\n\tcin &gt;&gt; a &gt;&gt; b;\n\tvector&lt;int&gt; A, B;\n\n\tfor (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i--) A.push_back(a[i] - &#39;0&#39;);\n\tfor (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i--) B.push_back(b[i] - &#39;0&#39;);\n\n\tauto C &#x3D; add(A, B);\n\n\tfor (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i--) cout &lt;&lt; C[i];\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n&#125;</code></pre>\n\n<p><font color=red><strong>代码测试：</strong></font></p>\n<ol>\n<li><p><img src=\"https://img-blog.csdnimg.cn/5c03452b71d34e36ac4f1008d6c9c5f3.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p><img src=\"https://img-blog.csdnimg.cn/b137a7adc8164db69a9b9d9db43a2407.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ol>\n<p><font color=red><strong>代码细节解释：</strong></font></p>\n<ul>\n<li><p>这里是将高精度数分别从低位到高位存放到两个<code>vector&lt;int&gt;</code>中；</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i--) A.push_back(a[i] - &#39;0&#39;);\nfor (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i--) B.push_back(b[i] - &#39;0&#39;);</code></pre>\n\n\n</li>\n<li><p>这个<code>for</code>循环便是相加的代码，两个<code>if</code>表示如果这个数的位数加完了，就停止加入<code>tmp</code>，判断条件表示将<code>tmp</code>加完为止（<font color=red>也就是如果两个数位数相同，最高位相加完后又进了一位，此时 tmp 为 1 并且不在加入数据，这个1 也是有效位，因此需要加入C中</font>）</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for (int i &#x3D; 0; i &lt; A.size() || i &lt; B.size() || tmp; i++)\n&#123;\n\tif (i &lt; A.size()) tmp +&#x3D; A[i];\n\tif (i &lt; B.size()) tmp +&#x3D; B[i];\n\tC.push_back(tmp % 10);\n\ttmp &#x2F;&#x3D; 10;\n&#125;</code></pre>\n\n</li>\n<li><p>这个<code>while</code>表示去掉<code>前导0</code>，虽然加法不会出现<code>前导0</code>的情况，但不排除输入的数据都为<code>0</code>的情况。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();</code></pre>\n\n\n<hr>\n<h1 id=\"2-高精度减法\"><a href=\"#2-高精度减法\" class=\"headerlink\" title=\"2.高精度减法\"></a>2.高精度减法</h1><ul>\n<li><p>高精度减法是两个很高位数的数相减，值得注意的是，减法需要借位，并且相减会出现结果为正还是负的情况，因此，高精度减法的程序比高精度加法的程序稍复杂。</p>\n</li>\n<li><p>对于结果是正还是负的情况，我们可以写一个<code>cmp</code>函数对存放两个高精度数的<code>string</code>进行比较，然后规定<code>sub</code>函数第一个参数为大的那个数，我们只要将大的那个传入第一个参数即可。如果是第二个输入的高精度数较大，在打印结果的时候先打印一个<code>‘ - ’</code>即可。</p>\n</li>\n<li><p>在进行相减的时候，我们可以先定义一个标记借位的变量<code>tmp</code>(初始化为<code>0</code>)，如果一位上相减为负数，说明需要向前借一位，所以在减的循环中第一条语句可以为：<code>tmp = big[i] - tmp;</code>，如果结果小于零，将<code>tmp</code>置为<code>1</code>，等进入下一次循环，第一条语句就自动减一，起到借位的效果。</p>\n</li>\n<li><p>那么结果小于<code>0</code>，我们该如何确定这一位的最终答案呢？我们只需要在<code>push_back</code>时，里面的参数设为<code>（tmp + 10）% 10</code>,这样就可以处理<code>tmp</code>所有的情况了（详细点看代码注释）。</p>\n</li>\n<li><p>由于我们是通过将高精度数的每一位存入数组来计算的，并且减法会出现最高位依次连续是<code>0</code>的情况，因此作为答案的数组，高位可能存放有<code>0</code>，在打印的时候这些0都会被打印出来，所以这里要有删去高位<code>0</code>的操作。</p>\n</li>\n</ul>\n<p><font color=red><strong>下面是相关操作的代码实现：</strong></font></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nbool cmp(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B)\n&#123;\n\tif (A.size() !&#x3D; B.size()) return A.size() &gt; B.size();\n\n\t&#x2F;&#x2F; 这一步说明A，B两个高精度数长度相等，此时从最高位依次比较\n\tfor (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i--)\n\t\tif (A[i] !&#x3D; B[i])\n\t\t\treturn A[i] &gt; B[i];\n\n\treturn true;\n&#125;\n\nvector&lt;int&gt; sub(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B)\n&#123;\n\tvector&lt;int&gt; C;\n\tint tmp &#x3D; 0; &#x2F;&#x2F; 用来标记借位\n\n\t&#x2F;&#x2F; 这里A要大，所以 i &lt; A.size()\n\tfor (int i &#x3D; 0; i &lt; A.size(); i++)\n\t&#123;\n\t\ttmp &#x3D; A[i] - tmp; &#x2F;&#x2F; 表示上一步有没有借位\n\t\tif (i &lt; B.size()) tmp -&#x3D; B[i];\n\t\t&#x2F;&#x2F; (tmp + 10) % 10 这是因为：\n\t\t&#x2F;&#x2F; 当tmp&lt;0时，说明这一位A的小于B的，因此要借位\n\t\t&#x2F;&#x2F;    所以tmp+10后就相当于借位后的数，%10后便是留在这一位的最终结果\n\t\t&#x2F;&#x2F; 当tmp&gt;0时，说明这一位A的大于B的，尽管加了10\n\t\t&#x2F;&#x2F;    但%10后加10与不加10是一样的（可脑补一下）\n\t\tC.push_back((tmp + 10) % 10);\n\t\t&#x2F;&#x2F; 如果tmp&lt;0,表示这一位A的小于B的，因此将tmp置为1，下一次循环的第一步减去一\n\t\tif (tmp &lt; 0) tmp &#x3D; 1;\n\t\telse tmp &#x3D; 0;\n\t&#125;\n\n\t&#x2F;&#x2F; 由于高位会出现0的情况(22226 - 22223 &#x3D; 3)，所以这里要去前导0\n\twhile (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n\treturn C;\n&#125;\n\nint main()\n&#123;\n\tstring a, b;\n\tcin &gt;&gt; a &gt;&gt; b;\n\tvector&lt;int&gt; A, B;\n\n\tfor (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i--) A.push_back(a[i] - &#39;0&#39;);\n\tfor (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i--) B.push_back(b[i] - &#39;0&#39;);\n\n\tif (cmp(A, B))\n\t&#123;\n\t\tauto C &#x3D; sub(A, B);\n\t\tfor (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i--) cout &lt;&lt; C[i];\n\t&#125;\n\telse\n\t&#123;\n\t\tauto C &#x3D; sub(B, A);\n\t\tcout &lt;&lt; &#39;-&#39;;\n\t\tfor (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i--) cout &lt;&lt; C[i];\n\t&#125;\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<p><font color=red><strong>代码测试：</strong></font></p>\n<ol>\n<li></li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/49f9ef55749846d9a191e01ee6702785.png\" alt=\"在这里插入图片描述\"></p>\n<ol start=\"2\">\n<li><img src=\"https://img-blog.csdnimg.cn/606286685844435fa30fdfeceedeac04.png\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<h1 id=\"3-高精度乘法\"><a href=\"#3-高精度乘法\" class=\"headerlink\" title=\"3.高精度乘法\"></a>3.高精度乘法</h1><ul>\n<li><p>在学完高精度加法和减法后，对于高精度乘法理解起来是很快的，这里我们规定，输入的第一个数为高精度数，第二个数为<code>int</code>范围内的数,并且两个数都是正整数。</p>\n</li>\n<li><p>有了上面的规定，接下来的操作就简单了，我们只需要关注如何乘，如何<code>push</code>,以及去前导<code>0</code>即可。</p>\n</li>\n<li><p>相乘前的准备与高精度加减类似，只不过输入的其中一个参数变为了<code>int</code> 。</p>\n</li>\n<li><p>整个相乘的过程：定义一个<code>tmp</code> ，将高精度数的每一位与<code>int</code>数相乘加入<code>tmp</code>(每一次循环将每一位相乘后的结果加入<code>tmp</code>)，然后每一次循环中，将<code>tmp%10</code>（每次取出个位上的数）<code>push_back</code>，再<code>tmp/=10</code>丢掉个位上的数，直到高精度的每一位数都乘过或者<code>tmp</code>为<code>0</code>循环结束，这样就完成了高精度的乘法。</p>\n</li>\n<li><p>如果输入的两个数有<code>0</code>，那么结果终究会是<code>0</code>，所以高精度乘法也要有去除前导零的操作。</p>\n</li>\n</ul>\n<p><font color=red><strong>下面是相关操作的代码实现：</strong></font></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b)\n&#123;\n\tvector&lt;int&gt; C;\n\n\tint tmp &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; A.size() || tmp; i++)\n\t&#123;\n\t\t&#x2F;&#x2F; 如果A没有遍历完就一直将每一位与b相乘加入tmp\n\t\tif (i &lt; A.size()) tmp +&#x3D; A[i] * b;\n\t\t&#x2F;&#x2F; （tmp % 10）是push tmp的个位\n\t\tC.push_back(tmp % 10);\n\t\t&#x2F;&#x2F; 丢弃个位\n\t\ttmp &#x2F;&#x3D; 10;\n\t&#125;\n\n\twhile (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n\treturn C;\n&#125;\n\nint main()\n&#123;\n\tstring a;\n\tint b, flag &#x3D; 1;\n\tcin &gt;&gt; a &gt;&gt; b;\n\tvector&lt;int&gt; A;\n\t\n\tfor (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i--) A.push_back(a[i] - &#39;0&#39;);\n\n\tauto C &#x3D; mul(A, b);\n\n\tfor (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i--) cout &lt;&lt; C[i];\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<p><font color=red><strong>代码测试：</strong></font></p>\n<p><img src=\"https://img-blog.csdnimg.cn/0789dd5f07d64ac08af4dbf4900d5d23.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/e04bf36df71b413f9ab85e4f8af561e6.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red><strong>选取测试案例图解：</strong></font></p>\n<p><img src=\"https://img-blog.csdnimg.cn/30eab85100774a868d2290af88e3c523.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-高精度除法\"><a href=\"#4-高精度除法\" class=\"headerlink\" title=\"4.高精度除法\"></a>4.高精度除法</h1><ul>\n<li><p>高精度除法与高精度乘法相比，多了一个变量<code>r</code>用来储存余数，其余的输入与乘法相同，但最后输出要把<code>r</code>打印。同样的，这里我们规定，两个数都是正整数，并且<code>int</code>范围内的那个数不能为<code>0</code>(一个高精度数除以一个<code>int</code>范围内的整数)。</p>\n</li>\n<li><p>对于整个相除的过程，肯定也是需要一个循环的。我们都知道，每一位相处的余数，都要相当于乘以<code>10</code>与下一位相加，由于<code>r</code>初始为<code>0</code>,因此循环的第一句可以写为<code>r = r * 10 + A[i]</code> ,<code>A[i]</code>为当前位的数，<code>r*10</code>表示上一位数相除得到的余数，如果上一位数余数为零，则这个表达式结果为<code>0</code>。</p>\n</li>\n<li><p>执行完上一条语句后便得到了被除数，此时就可以<code>push</code>:<code>r / 除数</code>，表示当前位的结果，最后再<code>r %= 除数</code> 除去除完的<code>除数</code>，这样整个过程就设计完成了。</p>\n</li>\n<li><p>由于<code>main</code>函数打印正确答案是从尾开始将每一位打印到头的，并且正确答案是由高位到低位从数组的头依次存放的，因此下一步需要逆置一下结果数组。</p>\n</li>\n<li><p>最后，除法会有高位为<code>0</code>的情况,因此还要有一步去除前导<code>0</code>的操作。</p>\n</li>\n</ul>\n<p><font color=red><strong>下面是相关操作的代码实现：</strong></font></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\n&#x2F;&#x2F; 要改变main函数里的余数r，因此要引用\nvector&lt;int&gt; div(vector&lt;int&gt;&amp; A, int b, int&amp; r)\n&#123;\n\tvector&lt;int&gt; C;\n\n\t&#x2F;&#x2F; 根据除法的过程，从高位开始除\n\tfor (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i--)\n\t&#123;\n\t\t&#x2F;&#x2F; r开始为0，则第一次循环就为A的最高位与b相除\n\t\t&#x2F;&#x2F; 如果 r&gt;b 则会有余数 ，所以下一次循环将这个余数 乘以10+A[i] 便是第二次循环要除的数\n\t\t&#x2F;&#x2F; 如果 r&lt;b 则余数就是r本身，第三条语句 r%&#x3D;b 就相当于没执行过\n\t\tr &#x3D; r * 10 + A[i];\n\t\tC.push_back(r &#x2F; b); &#x2F;&#x2F; push 这一次除b的结果，如果r&lt;b，则push:0\n\t\tr %&#x3D; b;\n\t&#125;\n\t\n\t&#x2F;&#x2F; 由于得到的结果是从高位向低位开始存的，所以这里逆置一下，便于去除前导0\n\treverse(C.begin(), C.end());\n\t&#x2F;&#x2F; 除法会出现0的情况，因此这里要处理前导0\n\twhile (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n\treturn C;\n&#125;\n\nint main()\n&#123;\n\tstring a;\n\t&#x2F;&#x2F; b为int范围内的数\n\t&#x2F;&#x2F; 创建一个变量r来储存余数\n\tint b, r &#x3D; 0;\n\tcin &gt;&gt; a &gt;&gt; b;\n\t&#x2F;&#x2F; A用来储存高精度数\n\tvector&lt;int&gt; A;\n\n\tfor (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i--) A.push_back(a[i] - &#39;0&#39;);\n\n\tauto C &#x3D; div(A, b, r);\n\n\t&#x2F;&#x2F; 打印还是与前面一样，因为div中结果逆置了\n\tfor (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i--) cout &lt;&lt; C[i];\n\t&#x2F;&#x2F; 这里打印余数\n\tcout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<p><font color=red><strong>代码测试：</strong></font></p>\n<ol>\n<li></li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/4f144218cdd448cfa43b06d12d1197a3.png\" alt=\"在这里插入图片描述\"></p>\n<ol start=\"2\">\n<li></li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/d9f5202692df48169fa332cd220aed71.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red><strong>选取测试案例图解：</strong></font></p>\n<p><font color=red><strong>输入</strong></font></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>128<br>8</p></blockquote>\n<p><font color=red><strong>输出</strong></font></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>16<br>0</p></blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/dc825f28adb44cac9f64f5aa1b81bde2.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>上述可以说都是高精度计算的基础模板，实际上在很多题目中都可以用到这一模板，比如某些链表的题。所以我们要增强对这一类模板的熟练度，以便在后面的刷题中遇到能用此模板解决的问题能够想起来有这一模板可以用。</p></blockquote>\n<p><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></p>\n","feature":null,"text":"前言 当我们在利用计算机进行一些计算时，可能会遇到这类问题 ： 有些计算要求精度高，希望计算的数的位数可达几十位甚至几百位，虽然计算机的计算精度也算较高了，但因受到硬件的限制，往往达不到实际问题所要求的精度。 这时我们就可以通过程序设计来解决这类问题，例如：创建一个数组，通过数组...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95\"><span class=\"toc-text\">1.高精度加法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95\"><span class=\"toc-text\">2.高精度减法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95\"><span class=\"toc-text\">3.高精度乘法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95\"><span class=\"toc-text\">4.高精度除法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"带你轻松实现通讯录(C语言版)","uid":"d8d9f05eeb5cca634b8a4aa98273e85e","slug":"带你轻松实现通讯录-C语言版","date":"2023-03-03T15:50:40.000Z","updated":"2023-03-03T15:54:23.002Z","comments":true,"path":"api/articles/带你轻松实现通讯录-C语言版.json","keywords":null,"cover":"/photo/屏幕截图_20230218_121115.png","text":" 前言 学习&#x3D;&#x3D;C语言&#x3D;&#x3D;的小伙伴，相信都要经历实现通讯录这一关吧，接下来就带你手把手实现自己的通讯录！ 通讯录初始化 整个程序我们需要分三个文件，一个是头文件：Contacts.h：用来存放宏，结构体以及函数声明，还有需要用的库函数。一个...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":23,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":23,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}}},"next_post":{"title":"【数据结构与算法】算法的时间复杂度和空间复杂度","uid":"73ff783753dfb9187579f115eb370182","slug":"【数据结构与算法】算法的时间复杂度和空间复杂度","date":"2023-03-03T15:45:47.000Z","updated":"2023-03-03T15:48:47.845Z","comments":true,"path":"api/articles/【数据结构与算法】算法的时间复杂度和空间复杂度.json","keywords":null,"cover":"/photo/屏幕截图_20230122_043306.png","text":" 前言 关于时空复杂度的分析，是每一个程序员的必备技能，本文将带你了解什么是时空复杂度？熟知怎样去计算一个算法的时间复杂度和空间复杂度。 1.算法效率1.1.如何衡量一个算法的好坏如何衡量一个算法的好坏呢？我们先看一段代码： int Fib(int N) &#123; if(N ...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":null}}