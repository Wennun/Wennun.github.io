{"title":"关于C语言对文件的操作","uid":"c2996624a24a0b1686f1aaf8ff1ca6e4","slug":"关于C语言对文件的操作","date":"2023-02-18T06:38:53.000Z","updated":"2023-02-18T06:40:40.114Z","comments":true,"path":"api/articles/关于C语言对文件的操作.json","keywords":null,"cover":"/photo/屏幕截图_20230218_121321.png","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>相信大家对文件都不陌生，我们在计算机的一系列操作都离不开文件，如果Linux没有了文件，那他就不叫Linux了，有了文件，我们的计算机才能够正常运行，有了文件我们才能够在计算机上写东西并能够帮我们保存下来。</li>\n<li>C语言也提供了一系列的函数来操控文件，本篇文章只介绍那些常见和常用的函数。</li>\n</ul></blockquote>\n<h1 id=\"1-为什么使用文件\"><a href=\"#1-为什么使用文件\" class=\"headerlink\" title=\"1. 为什么使用文件\"></a>1. 为什么使用文件</h1><p><strong>我们有可能会写通讯录，写过通讯录的都知道，如果没有文件操作，程序运行后输入的数据在程序结束就没有了，联系人信息也就没有了，如果不能存放联系人的信息，那通讯录还有什么用？所以必然的我们需要文件操作来将输入的联系人的信息存放到文件当中，下一次运行时再将之前已经保存在文件中的联系人的信息拿出来，这一系列的操作就是C语言的文件操作，对应的就需要使用一些相关操作函数。简单来说，文件操作能够将输入的通讯录的数据存放在硬盘文件中，这样就做到了数据的持久化。</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>所以使用文件，只有好处没有坏处。</p></blockquote>\n<h1 id=\"2-什么是文件\"><a href=\"#2-什么是文件\" class=\"headerlink\" title=\"2. 什么是文件\"></a>2. 什么是文件</h1><ul>\n<li>硬盘上的文件就是文件。</li>\n<li>而文件又分为程序文件和数据文件</li>\n</ul>\n<h2 id=\"程序文件\"><a href=\"#程序文件\" class=\"headerlink\" title=\"程序文件\"></a>程序文件</h2><p>程序文件就是一段程序，包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。</p>\n<h2 id=\"数据文件\"><a href=\"#数据文件\" class=\"headerlink\" title=\"数据文件\"></a>数据文件</h2><ul>\n<li>数据文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。</li>\n<li>本章讨论的是数据文件。</li>\n<li>在前面我们所学习所处理的数据的输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果显示到显示器上。</li>\n<li>其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使用，这里处理的就是磁盘上文件</li>\n</ul>\n<h1 id=\"3-文件的打开和关闭\"><a href=\"#3-文件的打开和关闭\" class=\"headerlink\" title=\"3. 文件的打开和关闭\"></a>3. 文件的打开和关闭</h1><p>在理解前面的文件介绍后，这里我们开始学习C语言是如何进行文件操作的？</p>\n<p>要进行文件操作，当然要知道文件的打开和关闭，在这之前，我们要学习<font color=blue size=5>文件指针。</p>\n<ul>\n<li><p>缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。</p>\n</li>\n<li><p>每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名<code>FILE</code>。</p>\n<p> 例如，VS2013编译环境提供的 stdio.h 头文件中有以下的文件类型申明：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct _iobuf &#123;  &#x2F;&#x2F; 是一个结构体\n        &#x2F;&#x2F; 文件的各类信息\n        char *_ptr;\n        int   _cnt;\n        char *_base;\n        int   _flag;\n        int   _file;\n        int   _charbuf;\n        int   _bufsiz;\n        char *_tmpfname;\n       &#125;;\ntypedef struct _iobuf FILE; &#x2F;&#x2F; 取名FILE</code></pre>\n\n\n<ul>\n<li><p>不同的C编译器的FILE类型包含的内容不完全相同，但是大同小异。</p>\n</li>\n<li><p>每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息，我们使用者不必关心细节。</p>\n</li>\n<li><p>一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。<br>例如，这里创建一个<code>FILE*</code>的指针变量：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">FILE* pf;&#x2F;&#x2F;文件指针变量</code></pre>\n\n\n<p><strong>定义pf是一个指向FILE类型数据的指针变量。可以使<code>pf</code>指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能够访问该文件。也就是说通过文件指针变量能够找到与它关联的文件。</strong></p>\n<p>如下图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/21dff942691e4465b898135bc637dd67.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>有了上面的文件指针相关概念的认知后，接下来就可以进行文件的打开和关闭了</strong></p>\n<ul>\n<li><p>文件的打开和关闭</p>\n<ol>\n<li>文件在读写之前应该先打开文件，在使用结束之后应该关闭文件。</li>\n<li>在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。</li>\n<li><code>ANSIC</code> 规定使用<code>fopen</code>函数来打开文件，<code>fclose</code>来关闭文件。</li>\n</ol>\n</li>\n<li><p><code>fopen</code>：</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/139465bca0f0460fac07f05e999aff35.png\" alt=\"在这里插入图片描述\"><br>如果打开文件失败，返回一个<code>NULL</code>；</p>\n<ul>\n<li><code>fclose</code>：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int fclose ( FILE * stream );\n&#x2F;&#x2F; 可以直接这样关闭\nfclose(pf);  &#x2F;&#x2F; pf 是一个 FILE* 的指针变量，他此时指向一个文件，这里将他关闭\n&#x2F;&#x2F; 最后这里最好将这个pf指针置空\npf &#x3D; NULL;</code></pre>\n<p>这两个函数的头文件都是<code>&lt;stdio.h&gt;</code>。</p>\n<p>文件的打开方式有很多，如下图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/87301b9b70624cd889141765ea69c0ef.png\" alt=\"在这里插入图片描述\"></p>\n<p>当然，这么多方式，我们只要着重熟练使用前5个就Ok了。</p>\n<p>说了这么多，下面实例操作一下：</p>\n<p>假设不自己创建文件以读的方式打开文件：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 这里读文件，如果此时当前目录下没有这个文件，fopen返回一个空指针\n\t&#x2F;&#x2F; 假设此时没有这个文件\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;r&quot;);\t\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\t&#x2F;&#x2F; 没有打开成功\n\t\t&#x2F;&#x2F; 打印错误信息\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F; 打开成功后\n\t\t&#x2F;&#x2F; ......\n\t\t&#x2F;&#x2F; 一系列文件操作\n\n\t\t&#x2F;&#x2F; 关闭文件\n\t\tfclose(pf);  &#x2F;&#x2F; 传递指向文件的指针\n\t\tpf &#x3D; NULL;\n\t&#125;\n\n\treturn 0;\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fea792363c6b4d978705cbc5da2b8f2e.png\" alt=\"在这里插入图片描述\"><br>可以看到，报错信息很明显：没有这个文件，说明<code>读</code>需要文件已经存在，这也就对应了上面文件打开方式图的内容，如果此时以<code>写（w）</code>的方式打开？根据上面的内容，他会自动创建一个文件。</p>\n<p>打开文件代码改为：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">FILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;w&quot;);</code></pre>\n<p>此时程序运行，终端什么都没有，但是在当前文件多出了一个文件，正是fopen里的那个test.txt文件：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/4fb12f188ec2484fb334e77cb7133cbe.png\" alt=\"在这里插入图片描述\"></p>\n<p>所以，以何种形式打开文件，其效果是不一样的，这也给了我们更多的选择。</p>\n<h1 id=\"4-文件的顺序读写\"><a href=\"#4-文件的顺序读写\" class=\"headerlink\" title=\"4. 文件的顺序读写\"></a>4. 文件的顺序读写</h1><p>文件的顺序读写当然需要一批函数来帮助我们操作，下面是一系列这样有这样功能的函数，接下来一一介绍和使用：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2be61362a4e6466c86f97ce6be677819.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"fgetc\"><a href=\"#fgetc\" class=\"headerlink\" title=\"fgetc\"></a><code>fgetc</code></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>fgetc</code>是从文件中读取一个字符的函数</p></blockquote>\n<p>下面是函数参数原型：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/94b1923392514dcca38cb1b5394f05f2.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/e5b4b283c40b4bbcbcc43af2f5743fa8.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/97bf605720b544cca6a9adfc1514fd49.png\" alt=\"在这里插入图片描述\"></p>\n<p>话不多说，先在当前文件创建一个<code>test.txt</code>,并在里面输入<code>abcdef</code>，然后进行<code>fgetc</code>的文件操作：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;  &#x2F;&#x2F; 对应函数头文件\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; fgetc 相当于从文件中读取字符，所以这里要以r的形式打开文件\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;r&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开成功\n\t&#x2F;&#x2F; 开始读取字符\n\tint ch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到字符的ASCLL码值\n\tprintf(&quot;%c\\n&quot;, ch);\n\tch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到下一个字符的ASCLL码值，函数会自动往下找\n\tprintf(&quot;%c\\n&quot;, ch);\n\tch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到下一个字符的ASCLL码值，函数会自动往下找\n\tprintf(&quot;%c\\n&quot;, ch);\n\tch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到下一个字符的ASCLL码值，函数会自动往下找\n\tprintf(&quot;%c\\n&quot;, ch);\n\tch &#x3D; fgetc(pf);  &#x2F;&#x2F; 得到下一个字符的ASCLL码值，函数会自动往下找\n\tprintf(&quot;%c\\n&quot;, ch);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/73d902c8ec6642e48c4fc576278d9519.png\" alt=\"在这里插入图片描述\"><br>当然我们也可以不必这么麻烦，直接写个<font color=red size=5>循环</font>瞬间将文件里的字符弄出来打印。</p>\n<h2 id=\"fputc\"><a href=\"#fputc\" class=\"headerlink\" title=\"fputc\"></a><code>fputc</code></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>fputc</code>是将字符写入文件当中，既然是写入，回顾<code>写（w）</code>的特点，如果文件不存在，自动创建一个文件，如果文件存在，则覆盖那个已经存在的文件。<br><img src=\"https://img-blog.csdnimg.cn/02ebbaa6c878478fbef8786f81116b32.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/9f108578a34a49d9b054173fcc98b6a0.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/89b47fb1c6d6412f8a0a6668c0fe27a3.png\" alt=\"在这里插入图片描述\"></p></blockquote>\n<p>这里不创建文件，直接使用（当前文件里没有<code>test.txt</code>文件）：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; fputc 将字符写入文件，所以这里用w\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;w&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 开始写入\n\tfor (char ch &#x3D; &#39;a&#39;; ch &lt;&#x3D; &#39;z&#39;; ++ch)\n\t&#123;\n\t\t&#x2F;&#x2F; 循环写入a-z 26 个字母\n\t\tfputc(ch, pf);\n\t&#125;\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n\n<p>我们打开<code>test.txt</code>文件观察是否写入：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/23c2c9ffff814279b9b05bd47cf5dfe7.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到，的确将26个字母写入文件。</p>\n<h2 id=\"fgets\"><a href=\"#fgets\" class=\"headerlink\" title=\"fgets\"></a><code>fgets</code></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>fgets</code>与<code>fgetc</code>很相似，只有s和c的差别，但<code>fgets</code>是从文件里得到一行字符(一读就读一行)，也就是一行字符串，而<code>fgetc</code>只是得到一个字符，这功能上的差别还是很大的。<br><img src=\"https://img-blog.csdnimg.cn/7c0ae08a543c4659b2dce3eb89b623ad.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/5f4cb1ac283e49b79c63a7fa19fa0df2.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/ed87dcdd2dd446fa85cc2732e0cd3249.png\" alt=\"在这里插入图片描述\"></p></blockquote>\n<p>下面就以在上面由<code>fputc</code>写好的文件<code>test.txt</code>来作为<code>fgets</code>使用的文件对象来展示<code>fgets</code>的使用效果：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t                &#x2F;&#x2F; 得字符串 用 &#39;r&#39;\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;r&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 开始从文件读字符串\n\tchar buf[100];\n\t&#x2F;&#x2F; 从pf中读取十个，用buf指向这一字符串\n\tfgets(buf, 10, pf);\n\tprintf(&quot;%s\\n&quot;, buf);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/6dd48619efbe4e8fbec17e4d0c83d022.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"fputs\"><a href=\"#fputs\" class=\"headerlink\" title=\"fputs\"></a><code>fputs</code></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>理解了fgets函数后，该函数得功能也就很清楚了：将字符串输入到文件中<br><img src=\"https://img-blog.csdnimg.cn/0c5431b04ce940c086361ca89a7e02da.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/d571eb4d1df54118acf9576204317ab3.png\" alt=\"在这里插入图片描述\"></p></blockquote>\n<p>该函数的使用：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 输入字符串到文件中 用        &#39;w&#39;\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;w&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 输入字符串到文件中\n\tchar s[] &#x3D; &quot;I love you!&quot;;\n\tfputs(s, pf);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/f65f4d0503604b17b7e39f49544beb64.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"fprintf\"><a href=\"#fprintf\" class=\"headerlink\" title=\"fprintf\"></a><code>fprintf</code></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>该函数是以格式化的形式向文件输入数据。<br><img src=\"https://img-blog.csdnimg.cn/4445fff59e684af7a9fd37155e9effea.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/1c35979c83cf4e04a458de486aa3b376.png\" alt=\"在这里插入图片描述\"></p></blockquote>\n<p><code>fprintf</code>纯概念有些难理解，使用起来其实没那么难：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt; &#x2F;&#x2F; 对应头文件\n#include &lt;stdlib.h&gt;\n\nstruct S\n&#123;\n\tchar s[20];\n\tint a;\n\tfloat b;\n&#125;;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 结构体成员数据\n\tstruct S s &#x3D; &#123; &quot;zhangsan&quot;, 520, 13.14 &#125;;\n\n\t&#x2F;&#x2F; 输入数据到文件中 用          &#39;w&#39;\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;w&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 输入数据到文件中\n\tfprintf(pf, &quot;%s %d %f&quot;, s.s, s.a, s.b);\n\t&#x2F;&#x2F; printf(&quot;%s %d %f&quot;, s.s, s.a, s.b);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/2b98cd73abbe4855b7c0963465b5a61e.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"fscanf\"><a href=\"#fscanf\" class=\"headerlink\" title=\"fscanf\"></a><code>fscanf</code></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>有了<code>fprintf</code>的理解，<code>fscanf</code>也很容易明白了，<code>scanf</code>是从键盘输入到内存当中，而<code>fscanf</code>则是从文件当中读取数据输入到内存当中。<br><img src=\"https://img-blog.csdnimg.cn/406437027bec41d8a8079e46d6214ab0.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/48dd02a7cdc24ff49c1d81070ceed137.png\" alt=\"在这里插入图片描述\"></p></blockquote>\n<p>我们将上面<code>fprintf</code>输入到文件<code>test.txt</code>的数据在读取出来放入一个结构体当中：<br><img src=\"https://img-blog.csdnimg.cn/93996ba3ae0f4844ad8df5f1b45cbdfe.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt; &#x2F;&#x2F; 对应头文件\n#include &lt;stdlib.h&gt;\n\nstruct S\n&#123;\n\tchar s[20];\n\tint a;\n\tfloat b;\n&#125;;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 结构体成员数据\n\tstruct S s &#x3D; &#123; 0 &#125;;\n\n\t&#x2F;&#x2F; 输入数据到文件中 用          &#39;r&#39;\n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;r&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开文件成功\n\t&#x2F;&#x2F; 从文件中读取数据\n\tfscanf(pf, &quot;%s %d %f&quot;, s.s, &amp;s.a, &amp;s.b);\n\t&#x2F;&#x2F; 打印结果\n\tprintf(&quot;%s %d %f\\n&quot;, s.s, s.a, s.b);\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/e08a724b9c104681a05d5bdff0d9fb17.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到，<code>fscanf</code>的确把文件中的数据放到了结构体变量<code>s</code>中。</p>\n<h2 id=\"流的介绍\"><a href=\"#流的介绍\" class=\"headerlink\" title=\"流的介绍\"></a>流的介绍</h2><p>任何一个C语言程序运行的时候，默认打开三个流：</p>\n<ol>\n<li>stdin - 标准输入流（键盘）类型：FILE*</li>\n<li>stdout - 标准输出流（屏幕）类型：FILE*</li>\n<li>stderr - 标准错误流（屏幕）类型：FILE*</li>\n</ol>\n<p>以上的函数不但适用于文件，还是用于这三个流，上面的函数图后面一条就表示了，这些函数适用于所有流。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint ch &#x3D; fgetc(stdin);  &#x2F;&#x2F; 从键盘输入\n\tfputc(ch, stdout); &#x2F;&#x2F; 在屏幕上输出\n\n\treturn 0;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/ebdcc7988ad34baa98f52067fce16a3c.png\" alt=\"在这里插入图片描述\"></p>\n<p>当然，以上的函数都可以进行相关的操作，流就是用来输入输出的。</p>\n<h2 id=\"fwrite\"><a href=\"#fwrite\" class=\"headerlink\" title=\"fwrite\"></a><code>fwrite</code></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>该函数与上面的函数不同，他是以二进制的方式将数据写入文件，也就是当我们打开写入数据的文件时会发现里面都是一些二进制乱码，完全看不懂。<br><img src=\"https://img-blog.csdnimg.cn/6ee899fe5483456f81bddaffc6fc39db.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/8717f5720d67453f824238d154e49baf.png\" alt=\"在这里插入图片描述\"></p></blockquote>\n<p>既然是二进制写入，那<code>fopen</code>哪里就要写成<code>wb（表示以二进制写入）</code>。</p>\n<p>使用如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; fwrite写，二进制形式的写“wb”     \n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;wb&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开成功\n\tint arr[] &#x3D; &#123; 1,2,3,4,5,6 &#125;;\n\n\t&#x2F;&#x2F; 从arr处写入   写入的大小为整个数组的大小   写入1个   写到pf指向的文件当中\n\tfor (int i &#x3D; 0; i &lt; 6; i++)\n\t&#123;\n\t    &#x2F;&#x2F; 循环将arr中的每一个元素写入文件\n\t\tfwrite(arr + i, sizeof(int), 1, pf);\n\t&#125;\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/7e7ffc62c3a94b7abddb3bde03012e45.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到，文件<code>test.txt</code>里面是一些乱东西。</p>\n<h2 id=\"fread\"><a href=\"#fread\" class=\"headerlink\" title=\"fread\"></a><code>fread</code></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>该函数是进行二进制数据文件的读取的，跟<code>fwrite</code>函数一个读一个写，下面是其函数原型：<br><img src=\"https://img-blog.csdnimg.cn/495b74bd38944ce78e3c6d23a44ba977.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/c729be7a2a884e33907e7561a95a57ce.png\" alt=\"在这里插入图片描述\"></p></blockquote>\n<p>就将<code>fwrite</code>写进<code>test.txt</code>的二进制乱码读取出来看是不是开始的<code>arr</code>数组数据：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; fread写，二进制形式的读取“wb”     \n\tFILE* pf &#x3D; fopen(&quot;test.txt&quot;, &quot;rb&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;open fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F; 打开成功\n\tint arr[20];\n\n\t&#x2F;&#x2F; 将文件的数据写入arr   一个整型一个整型的写入   写入1个   从pf指向的文件中读取\n\tfor (int i &#x3D; 0; i &lt; 6; i++)\n\t&#123;\n\t\tfread(arr + i, sizeof(int), 1, pf);\n\t&#125;\n\n\t&#x2F;&#x2F;  打印\n\tfor (int i &#x3D; 0; i &lt; 6; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n\n\t&#x2F;&#x2F; 关闭文件\n\tfclose(pf);\n\tpf &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<p><img src=\"https://img-blog.csdnimg.cn/0279d28a01854733a5377efa9270ce2a.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"5-文本文件和二进制文件\"><a href=\"#5-文本文件和二进制文件\" class=\"headerlink\" title=\"5. 文本文件和二进制文件\"></a>5. 文本文件和二进制文件</h1><ul>\n<li><p>根据数据的组织形式，数据文件被称为文本文件或者二进制文件。</p>\n</li>\n<li><p>数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。</p>\n</li>\n<li><p>如果要求在外存上以<code>ASCII</code>码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。</p>\n</li>\n<li><p><code>一个数据在内存中是怎么存储的呢？</code><br>字符一律以<code>ASCII</code>形式存储，数值型数据既可以用<code>ASCII</code>形式存储，也可以使用二进制形式存储。 </p>\n<ol>\n<li>当以二进制形式存储，文件里是一系列的二进制乱码；</li>\n<li>当以<code>ASCLL</code>形式储存，则是以字符形式表达其面值。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"6-文件读取结束的判定\"><a href=\"#6-文件读取结束的判定\" class=\"headerlink\" title=\"6. 文件读取结束的判定\"></a>6. 文件读取结束的判定</h1><ul>\n<li>有两个函数可以用作文件读取结束的判定<ol>\n<li><code>feof</code></li>\n<li><code>ferror </code></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"被错误使用的feof\"><a href=\"#被错误使用的feof\" class=\"headerlink\" title=\"被错误使用的feof\"></a>被错误使用的feof</h2><ul>\n<li>牢记：在文件读取过程中，不能用<code>feof</code>函数的返回值直接用来判断文件的是否结束。而是应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束。</li>\n</ul>\n<ol>\n<li>文本文件读取是否结束，判断返回值是否为 <code>EOF （ fgetc ）</code>，或者<code> NULL （ fgets ）</code><br>例如：<br><code>fgetc </code>判断是否为<code>EOF</code>.<br><code>fgets </code>判断返回值是否为<code> NULL</code> .</li>\n<li>二进制文件的读取结束判断，判断返回值是否小于实际要读的个数。<br>例如：<br><code>fread</code>判断返回值是否小于实际要读的个数。</li>\n</ol>\n<h1 id=\"7-文件缓冲区\"><a href=\"#7-文件缓冲区\" class=\"headerlink\" title=\"7. 文件缓冲区\"></a>7. 文件缓冲区</h1><ul>\n<li>ANSIC 标准采用“缓冲文件系统”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/d2de0870c2214f02bc312aa112b53735.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>文件操作实际上是不常用的，大部分公司都有其内部的文件管理系统，所以，对文件操作的困惑不要停留太久。</p></blockquote>\n<p><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></p>\n","text":"前言 相信大家对文件都不陌生，我们在计算机的一系列操作都离不开文件，如果Linux没有了文件，那他就不叫Linux了，有了文件，我们的计算机才能够正常运行，有了文件我们才能够在计算机上写东西并能够帮我们保存下来。 C语言也提供了一系列的函数来操控文件，本篇文章只介绍那些常见和常用...","link":"","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":23,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":23,"path":"api/tags/C语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">1. 为什么使用文件</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">2. 什么是文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">程序文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">数据文件</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">3. 文件的打开和关闭</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99\"><span class=\"toc-text\">4. 文件的顺序读写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fgetc\"><span class=\"toc-text\">fgetc</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fputc\"><span class=\"toc-text\">fputc</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fgets\"><span class=\"toc-text\">fgets</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fputs\"><span class=\"toc-text\">fputs</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fprintf\"><span class=\"toc-text\">fprintf</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fscanf\"><span class=\"toc-text\">fscanf</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%9A%84%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">流的介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fwrite\"><span class=\"toc-text\">fwrite</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fread\"><span class=\"toc-text\">fread</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5. 文本文件和二进制文件</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%93%E6%9D%9F%E7%9A%84%E5%88%A4%E5%AE%9A\"><span class=\"toc-text\">6. 文件读取结束的判定</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A2%AB%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%9A%84feof\"><span class=\"toc-text\">被错误使用的feof</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">7. 文件缓冲区</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"程序的编译与链接","uid":"9644227715b55b99af65739565b00100","slug":"程序的编译与链接","date":"2023-02-18T06:41:16.000Z","updated":"2023-02-18T06:42:20.604Z","comments":true,"path":"api/articles/程序的编译与链接.json","keywords":null,"cover":"/photo/屏幕截图_20230218_121142.png","text":" 前言 每当我们运行一段代码时，编译器都会自动的帮我们编译代码并将代码转换为一个二进制可执行文件（.exe）， 有了这个可执行文件，便可以执行我们写的程序了。那么编译器对代码的编译以及生成可执行程序的过程是怎样的呢？这个问题便是本文章将要探讨的。 程序的环境在ANSI C的任何一...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":23,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":23,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}}},"next_post":{"title":"C语言一个特殊的数组【柔性数组】","uid":"c624797c7b313fdd30471a2503f8d11d","slug":"C语言一个特殊的数组【柔性数组】","date":"2023-02-18T06:29:28.000Z","updated":"2023-02-18T06:30:24.629Z","comments":true,"path":"api/articles/C语言一个特殊的数组【柔性数组】.json","keywords":null,"cover":"/photo/OIP-C.jpeg","text":"前言 也许你从来就没有听过柔性数组（flexible array）这个概念，但他是真的存在； 柔性数组的概念存在于C99标准当中，C99标准表示：结构体的最后一个成员可以是一个大小不确定的数组，这个数组就叫做柔性数组; 既然搭配了柔性这一修饰词，那么这个数组就不会是”耿直“的了。...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":23,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":23,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}}}}