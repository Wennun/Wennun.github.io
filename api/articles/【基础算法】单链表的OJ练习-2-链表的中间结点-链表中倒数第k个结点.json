{"title":"【基础算法】单链表的OJ练习(2)","uid":"98becb8c7065890d0806582243945652","slug":"【基础算法】单链表的OJ练习-2-链表的中间结点-链表中倒数第k个结点","date":"2023-03-03T15:53:57.000Z","updated":"2023-03-03T15:58:34.903Z","comments":true,"path":"api/articles/【基础算法】单链表的OJ练习-2-链表的中间结点-链表中倒数第k个结点.json","keywords":null,"cover":"/photo/R-C (3).jpeg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><ul>\n<li><p>对于单链表的OJ练习，<font color=blue size=4>需要深刻理解做题的思路</font>，这样我们才能够在任何场景都能够熟练的解答有关链表的问题。</p>\n</li>\n<li><p>关于OJ练习（1）：&#x3D;&#x3D;-&gt;&#x3D;&#x3D; <a href=\"https://blog.csdn.net/Wennytime/article/details/129310471\">传送门</a> &#x3D;&#x3D;&lt;-&#x3D;&#x3D;，其题目较为简单，思路也好理解，本章与<code>（1）</code>差不多，难度不大，<font color=orange size=4>核心点就在于理解解题思路。</font></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"链表的中间结点\"><a href=\"#链表的中间结点\" class=\"headerlink\" title=\"链表的中间结点\"></a>链表的中间结点</h1><p>题目链接：&#x3D;&#x3D;-&gt;&#x3D;&#x3D; <a href=\"https://leetcode.cn/problems/middle-of-the-linked-list/\">传送门</a> &#x3D;&#x3D;&lt;-&#x3D;&#x3D;。</p>\n<ul>\n<li>该题目描述为：<font color=red size=4><strong>给你单链表的头结点 head ，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</font></strong></li>\n</ul>\n<p>1.如果节点数为奇数，这个中间节点就显而易见了。（3）<br><img src=\"https://img-blog.csdnimg.cn/2593f55035134933bfbdca16a0d8b974.png\" alt=\"在这里插入图片描述\"></p>\n<p>2.如果节点数为偶数，这里认为中间两个节点的第二个节点为中间节点。（4）<br><img src=\"https://img-blog.csdnimg.cn/ec275193467e4d85be6758069397fcc6.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red size=4>思路一</font>：</p>\n<ul>\n<li><p>我们可以先遍历一遍链表，统计一下链表节点的个数。</p>\n</li>\n<li><p>然后将这个个数除以二加一（count &#x2F; 2 + 1）便是中间这个节点的位置。</p>\n</li>\n<li><p>当然，我们在循环寻找这个中间节点的时候，是从头节点开始的，因此循环只需要循环<code>（（count / 2 + 1） - 1）</code>即可。</p>\n</li>\n</ul>\n<p><font color=blue size=4>代码实现：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct ListNode* middleNode(struct ListNode* head)&#123;\n    struct ListNode* cur &#x3D; head;\n    int count &#x3D; 0;\n\n    while (cur)\n    &#123;\n        count ++ ;\n        cur &#x3D; cur-&gt;next;\n    &#125;\n\n    count &#x3D; count &#x2F; 2 + 1;\n\n    while (-- count) &#x2F;&#x2F; 循环count - 1次\n    &#123;\n        head &#x3D; head-&gt;next;\n    &#125;\n\n    return head;\n&#125;</code></pre>\n\n<p><font color=red size=4>思路二</font>：</p>\n<ul>\n<li><p>该做法为快慢指针。</p>\n</li>\n<li><p>啥为快慢指针呢？在本题有关当中，我们定义两个指针指向链表的头节点，并且共同遍历链表，不同的是，一个指针每一次走两步，另一个指针每次走一步，这就是快慢指针。</p>\n</li>\n<li><p>每当快指针满足循环结束条件，慢指针都是指向链表的中间节点的。因为快指针走两步，慢指针走一步，整个移动的位移差相差一倍，所以每当快指针满足结束条件的时候，慢指针走的步数都是快指针走的步数的一半， 因此慢指针指向的那个节点就是整个链表的中间节点。</p>\n</li>\n<li><p>快指针结束的条件有两种情况，一种是快指针刚好指向空结束，一种是快指针指向尾节点结束，也就是快指针的<code>next</code>为<code>NULL</code>。</p>\n</li>\n</ul>\n<p> 1.当快指针刚好指向<code>NULL</code>结束，此时链表的节点个数为偶数：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b67895822f834005a7625e360c8200c9.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>2.当快指针指向尾节点结束，也就是快指针的<code>next</code>为<code>NULL</code>，此时链表的节点个数为奇数：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a430d71ec70641f6a35deb65a7870f63.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><font color=blue size=4>代码实现：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct ListNode* middleNode(struct ListNode* head)&#123;\n    struct ListNode* fast &#x3D; head, * slow &#x3D; head;\n\n    while (fast &amp;&amp; fast-&gt;next)\n    &#123;\n        fast &#x3D; fast-&gt;next-&gt;next;\n        slow &#x3D; slow-&gt;next;\n    &#125;\n\n    return slow;\n&#125;</code></pre>\n\n<p><font color=red size=4>注意：</font><br><code>while</code>循环的判断条件，<code>fast</code>一定要在前面，这是因为：判断是从左到右判断的，如果<code>fast-&gt;next</code>在前，而此时链表的结点的个数为偶数，那么<code>fast</code>就会直接到达<code>NULL</code>，这时候对空指针解引用操作就出问题了。</p>\n<hr>\n<h1 id=\"链表中倒数第k个结点\"><a href=\"#链表中倒数第k个结点\" class=\"headerlink\" title=\"链表中倒数第k个结点\"></a>链表中倒数第k个结点</h1><p>题目链接：&#x3D;&#x3D;-&gt;&#x3D;&#x3D; <a href=\"https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&&tqId=11167&rp=2&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking\">传送门</a> &#x3D;&#x3D;&lt;-&#x3D;&#x3D;。</p>\n<ul>\n<li>该题目描述为：<font color=red size=4><strong>输入一个链表，输出该链表中倒数第k个结点。。</strong></font></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/49dfc5d2c1a2457eb40d4f52eb5122fd.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red size=4>思路一</font>：</p>\n<ul>\n<li><p>既然是倒数第<code>k</code>个，那我们就看看是正数的第几个。</p>\n</li>\n<li><p>先遍历一遍单链表，统计一下链表的结点个数（<code>count</code>），通过数学知识，可得倒数的第<code>k</code>个结点就是正数的第<code>count - k + 1</code>个节点，这时只要在遍历一次链表，找到第<code>count - k + 1</code>个节点返回即可。</p>\n</li>\n<li><p>当然，这里嘚注意<code>k</code>是不是大于链表节点的个数的情况。</p>\n</li>\n</ul>\n<p><font color=blue size=4>代码实现：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct ListNode* FindKthToTail(struct ListNode* pListHead, int k ) &#123;\n    struct ListNode* cur &#x3D; pListHead;\n\n    int count &#x3D; 0;\n    &#x2F;&#x2F; 统计链表节点的个数\n    while (cur)\n    &#123;\n        count ++ ;\n        cur &#x3D; cur-&gt;next;\n    &#125;\n\n    &#x2F;&#x2F; 如果k大于链表的节点个数，直接返回NULL\n    if (k &gt; count) return NULL;\n    \n    int tmp &#x3D; count - k;\n\t\n\t&#x2F;&#x2F; 由于从头个节点开始算，因此只需要循环count - k次就可以找到倒数第k个节点\n    while (tmp -- )\n    &#123;\n        pListHead &#x3D; pListHead-&gt;next;\n    &#125;\n\n    return pListHead;\n&#125;</code></pre>\n\n\n<p><font color=red size=4>思路二</font>：</p>\n<ul>\n<li>同样是快慢指针，这里的快慢指针解法是：快指针先向后走<code>k</code>步或者先向后走<code>k - 1</code>步，然后快指针与慢指针同时向后走，当快指针满足循环结束条件停止，此时慢指针指向的节点就是倒数第<code>k</code>个节点。</li>\n</ul>\n<p>1.如果快指针先向后走<code>k</code>步，此时快指针与慢指针之间相差<code>k</code>步，因此，当快指针到达<code>NULL</code>时，此时慢指针刚好指向倒数第<code>k</code>个节点。（倒数第<code>k</code>个节点与<code>NULL</code>相差<code>k</code>步）(循环结束条件：<code>fast == NULL</code>)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/19cd3f81edca44ef835831189bc23155.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>2.如果快指针先向后走<code>k - 1</code>步，此时快指针与慢指针之间相差<code>k - 1</code>步，然后快指针与慢指针同时向后走，当快指针满足循环结束条件停止，此时慢指针指向的节点就是倒数第<code>k</code>个节点。（倒数第<code>k</code>个节点与<code>尾节点</code>相差<code>k - 1</code>步）（循环结束条件：<code>fast-&gt;next == NULL</code>）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/54901dae52c74be1b5648974653ce5dd.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><font color=blue size=4>代码实现：(这里只实现fast先走k步的情况，fast先走k - 1的情况大同小异)</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct ListNode* FindKthToTail(struct ListNode* pListHead, int k ) &#123;\n    struct ListNode* slow &#x3D; pListHead, * fast &#x3D; pListHead;\n    &#x2F;&#x2F; fast先走k步\n    while (k -- )\n    &#123;\n        if (!fast) return NULL; &#x2F;&#x2F; 如果k还没为0但fast已经指向空了，说明k大于链表的结点的个数，此时直接返回NULL\n        fast &#x3D; fast-&gt;next;\n    &#125;\n\t\n\t&#x2F;&#x2F; 当fast为NULL时结束循环\n    while (fast)\n    &#123;\n        fast &#x3D; fast-&gt;next;\n        slow &#x3D; slow-&gt;next;\n    &#125;\n\n    return slow;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><font color=red size=4><strong>对于单链表的题目练习，最重要的是思路，我们在数据结构阶段要养成画图的习惯，因为它能帮助我们更好的理解。后续还会有单链表相关的题目练习。</strong></font></p></blockquote>\n<p><font color=blue size=4><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></font></p>\n","feature":true,"text":"前言 对于单链表的OJ练习，需要深刻理解做题的思路，这样我们才能够在任何场景都能够熟练的解答有关链表的问题。 关于OJ练习（1）：&#x3D;&#x3D;-&gt;&#x3D;&#x3D; 传送门 &#x3D;&#x3D;&lt;-&#x3D;&#x3D;，其题目较为简单，思路也...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9\"><span class=\"toc-text\">链表的中间结点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9\"><span class=\"toc-text\">链表中倒数第k个结点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"【基础算法】单链表的OJ练习(1)","uid":"7ca2e84fccf5532a68e25ef3af8a8b80","slug":"【基础算法】单链表的OJ练习-1-反转链表-合并两个有序链表","date":"2023-03-03T15:53:46.000Z","updated":"2023-03-03T15:57:14.395Z","comments":true,"path":"api/articles/【基础算法】单链表的OJ练习-1-反转链表-合并两个有序链表.json","keywords":null,"cover":"/photo/R-C (4).jpeg","text":"前言 上一章讲解了单链表 &#x3D;&#x3D;-&gt;&#x3D;&#x3D; 传送门 &#x3D;&#x3D;&lt;-&#x3D;&#x3D; ，后面几章就对单链表进行一些简单的题目练习，目的是为了更好的理解单链表的实现以及加深对某些函数接口的熟练度。 本章带来了两个题...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":true}}