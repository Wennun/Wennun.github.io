{"title":"关于C语言非常重要的动态内存管理函数的解析和使用","uid":"a34c5dd4aef1e7a0fbf034a166eaf417","slug":"关于C语言非常重要的动态内存管理函数的解析和使用","date":"2023-02-18T06:14:44.000Z","updated":"2023-02-18T06:16:57.263Z","comments":true,"path":"api/articles/关于C语言非常重要的动态内存管理函数的解析和使用.json","keywords":null,"cover":"/photo/屏幕截图_20230122_041251.png","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li><strong>动态内存管理函数可以说很好用，但是有些小危险</strong>。</li>\n<li><strong>所谓动态内存分配，就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。 动态内存分配不像 数组 等 静态内存 分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。</strong></li>\n<li><strong>动态内存函数的头文件都是：<code>&lt;stdlib.h&gt;</code></strong></li>\n</ul></blockquote>\n<h1 id=\"为什么存在动态内存分配？\"><a href=\"#为什么存在动态内存分配？\" class=\"headerlink\" title=\"为什么存在动态内存分配？\"></a>为什么存在动态内存分配？</h1><p>我们已经掌握的内存开辟方式有：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int val &#x3D; 20; &#x2F;&#x2F;在栈空间上开辟四个字节\nchar arr[10] &#x3D; &#123;0&#125;; &#x2F;&#x2F;在栈空间上开辟10个字节的连续空间</code></pre>\n\n\n<p>但是上述的开辟空间的方式有两个特点：</p>\n<ol>\n<li>空间开辟大小是固定的。</li>\n<li>数组在声明的时候，必须指定数组的长度，它所需要的内存在编译时分配。但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态存开辟了。</li>\n</ol>\n<p><strong>此外：在后面的通讯录的完整实现，以及数据结构的完整实现大都是需要动态内存来实现的。</strong></p>\n<h1 id=\"malloc-和-free\"><a href=\"#malloc-和-free\" class=\"headerlink\" title=\"malloc 和 free\"></a><code>malloc</code> 和 <code>free</code></h1><h2 id=\"1-malloc\"><a href=\"#1-malloc\" class=\"headerlink\" title=\"1.malloc\"></a>1.malloc</h2><p><code>malloc</code>是C语言提供的一个内存开辟函数，该函数的参数如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d666dd3c2d41480999e5cb157f660e8a.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/c213fcb3cdca47d3b59810bfdd438a25.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=blue>返回值：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/264edf14b96746caa573116a43eede32.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。</li>\n<li>如果开辟成功，则返回一个指向开辟好空间的指针。</li>\n<li>如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。</li>\n<li>返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。</li>\n<li>如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。</li>\n</ul>\n<p> <strong><code>malloc</code>开辟的内存空间都是每有初始化的，观察内存如下：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/0c9160dea3c44bf384b89f75eff4053f.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-free\"><a href=\"#2-free\" class=\"headerlink\" title=\"2.free\"></a>2.free</h2><p><strong>C语言提供了另外一个函数<code>free</code>，专门是用来做动态内存的释放和回收的，函数参数如下：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/8531ef4b3420412e8cc8652db2c9ee74.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/dbf473bb77f548e5890408c80a3a3a5d.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><code> free</code>函数用来释放动态开辟的内存。</li>\n<li>如果参数 <code>ptr</code> 指向的空间不是动态开辟的，那<code>free</code>函数的行为是未定义的。</li>\n<li>如果参数 <code>ptr</code> 是<code>NULL</code>指针，则函数什么事都不做。</li>\n</ul>\n<p><strong>注意：任何只要是开辟的动态内存空间（堆上的），都要<code>free</code>释放返还给操作系统。</strong></p>\n<h2 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3.使用\"></a>3.使用</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>malloc</code>与<code>free</code>是要共同使用的，有<code>malloc</code>开辟空间就一定要有<code>free</code>释放空间，通过上面的函数介绍，接下来结合使用。</p></blockquote>\n<p><strong>例如，这里动态开辟一个能够存放<code>10</code>个整型的数组：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; &#x2F;&#x2F; 对应头文件\n\nint main()\n&#123;\n    &#x2F;&#x2F; 因为返回的是void*，最好强转以下\n\tint* tmp &#x3D; (int*)malloc(sizeof(int) * 10); &#x2F;&#x2F; 也可以直接放一个40（要40字节）\n\n\t&#x2F;&#x2F; 一定要检查开辟成功没有\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;malloc fail&quot;);  &#x2F;&#x2F; 这里打印错误“开辟失败”\n\t\texit(-1);  &#x2F;&#x2F; 这里可以理解为直接退出程序\n\t&#125;\n\n\t&#x2F;&#x2F; 开辟没问题，进行以下操作\n\t&#x2F;&#x2F; 给开辟的数组赋值\n\tfor (int i &#x3D; 0; i &lt; 10; ++i)\n\t&#123;\n\t\ttmp[i] &#x3D; i + 1;\n\t&#125;\n\n\t&#x2F;&#x2F; 打印\n\tfor (int i &#x3D; 0; i &lt; 10; ++i)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, tmp[i]);\n\t&#125;\n\n\t&#x2F;&#x2F; 操作完后一定要释放空间\n\t&#x2F;&#x2F; 传递指向那段空间起始位置的指针\n\tfree(tmp);\n\t&#x2F;&#x2F; 释放后要把该指针置为空，不然后面一不小心又使用该指针找到那块空间，属于非法访问了\n\ttmp &#x3D; NULL;  \n\n\treturn 0;\n&#125;</code></pre>\n<p><strong>如果后面不释放，虽然现在的机器大都会自动返还给操作系统，但是出于严谨和安全，一定要记得<code>free</code>,不然会造成内存泄露问题，这是很严重的。</strong></p>\n<h1 id=\"calloc\"><a href=\"#calloc\" class=\"headerlink\" title=\"calloc\"></a><code>calloc</code></h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>calloc</code>也是动态内存分配函数<br><img src=\"https://img-blog.csdnimg.cn/695953d051dd48a7b4ba5fec61e4d86e.png\" alt=\"在这里插入图片描述\"></p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 例如这里开辟一个有十个整型元素的数组\nint* arr &#x3D; (int*)calloc(10, sizeof(int));</code></pre>\n\n\n<p><img src=\"https://img-blog.csdnimg.cn/b9ea3edc0d254c86ab41e4792cf7429c.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7a85aed6caad40c2a4c39c6088ee1bb7.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>通过上面的介绍，可以发现，<code>calloc</code>的功能与<code>malloc</code>几乎相同，其有两点不同之处：</strong></p>\n<ol>\n<li><code>calloc</code>与<code>malloc</code>的函数参数不同；</li>\n<li><code>calloc</code>开辟的空间会将全部元素初始化<code>0</code>，而<code>malloc</code>则是随机值。</li>\n</ol>\n<p><strong>如：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; &#x2F;&#x2F; 对应头文件\n\nint main()\n&#123;\n\t&#x2F;&#x2F;               个数     一个元素的大小\n\tint* tmp &#x3D; calloc(10, sizeof(int)); \n\n\t&#x2F;&#x2F; 一定要检查开辟成功没有\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;calloc fail&quot;);  &#x2F;&#x2F; 这里打印错误“开辟失败”\n\t\texit(-1);  &#x2F;&#x2F; 这里可以理解为直接退出程序\n\t&#125;\n\n\t&#x2F;&#x2F; 开辟没问题，进行以下操作\n\t&#x2F;&#x2F; 给开辟的数组赋值\n\tfor (int i &#x3D; 0; i &lt; 10; ++i)\n\t&#123;\n\t\ttmp[i] &#x3D; i + 1;\n\t&#125;\n\n\t&#x2F;&#x2F; 打印\n\tfor (int i &#x3D; 0; i &lt; 10; ++i)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, tmp[i]);\n\t&#125;\n\n\t&#x2F;&#x2F; 操作完后一定要释放空间\n\t&#x2F;&#x2F; 传递指向那段空间起始位置的指针\n\tfree(tmp);\n\t&#x2F;&#x2F; 释放后要把该指针置为空，不然后面一不小心又使用该指针找到那块空间，属于非法访问了\n\ttmp &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/af0d5b96460344de86dc454448973f3f.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>所以如何我们对申请的内存空间的内容要求初始化，那么可以很方便的使用calloc函数来完成任务。</strong></p>\n<h1 id=\"realloc\"><a href=\"#realloc\" class=\"headerlink\" title=\"realloc\"></a><code>realloc</code></h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>realloc函数的出现让动态内存管理更加灵活。</strong></p></blockquote>\n<ul>\n<li><strong>有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候管理内存，我们一定会对内存的大小做灵活的调整。那 realloc 函数就可以做到对动态开辟内存大小的灵活调整。</strong></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/40416037061c4d0b84f8aa1c95657339.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/6766f7c88c684faf8ca18bf6be4b6a9a.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/fb14ed7fc1624a2d9e652f1cc3d5e726.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/5a2038120e1d4fa8b75059755f4c91a0.png\" alt=\"在这里插入图片描述\"></p>\n<p>基础点：</p>\n<ol>\n<li><code>ptr</code> 是要调整的内存地址。</li>\n<li><code>size</code> 调整之后新大小。</li>\n<li>返回值为调整之后的内存起始位置。</li>\n<li>这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到 新 的空间。</li>\n</ol>\n<ul>\n<li><font size=5><strong>realloc在调整内存空间的是存在两种情况：</strong></li>\n</ul>\n<p><strong>情况<code>1</code>： 内存中原有的空间之后有足够的空间来存放重新开辟的新大小的空间，这时直接在原有的空间之后追加空间。</strong><br><strong>情况<code>2</code>： 内存中原有的空间之后没有足够的空间来存放重新开辟的新大小的空间，这时在堆上另找一个合适大小的连续空间来使用。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/8a139270502a4adea4e01396e7e25d51.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>那么我们如何来写代码呢？</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\tint* tmp &#x3D; (int*)malloc(100);\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;malloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\t&#x2F;&#x2F;扩展容量\n\t&#x2F;&#x2F;代码1\n\ttmp &#x3D; (int*)realloc(tmp, 1000);&#x2F;&#x2F;这样可以吗？(如果申请失败会如何？)\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\t\n\t&#x2F;&#x2F;代码2\n\tint* p &#x3D; realloc(tmp, 1000);\n\tif (p &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;realloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\ttmp &#x3D; p;\n\t\n\t&#x2F;&#x2F; 释放\n\tfree(tmp);\n\ttmp &#x3D; NULL;\n\n\treturn 0;\n&#125;</code></pre>\n<ul>\n<li><strong>上面有两种写法，代码<code>1</code>跟代码<code>2</code>。</strong></li>\n</ul>\n<ol>\n<li>分析代码1：如果重新开辟的空间开辟成功，并且是在原空间上做修改，那么这是可行的；如果原空间后面没有足够空间来开辟，另寻找到一份空间来存放，此时的地址空间的起始地址发生了改变，如果空间申请失败，而此时又将该空间的起始地址给了原有的指针变量tmp，这时原有空间就找不到了，并且会出现错误，所以还是不严谨的；</li>\n<li>分析代码2：代码2是先将重新开辟的空间的起始地址交给一个临时变量，在判断这份空间的有效性，最后才赋值给原有的指针变量，这样做才是最安全且不会亏损原有空间的，所以，根据代码2的严谨性强的特点，以后realloc一定要写代码2这种样式。</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>有了<code>realloc</code>buff的加持，我们想让数组变他就嘚变，哈哈哈</p></blockquote>\n<h1 id=\"常见的动态内存错误\"><a href=\"#常见的动态内存错误\" class=\"headerlink\" title=\"常见的动态内存错误\"></a>常见的动态内存错误</h1><h2 id=\"1-对NULL指针的解引用操作\"><a href=\"#1-对NULL指针的解引用操作\" class=\"headerlink\" title=\"1.对NULL指针的解引用操作\"></a>1.对NULL指针的解引用操作</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void test()\n&#123;\n\t int *p &#x3D; (int *)malloc(INT_MAX&#x2F;4);\n\t &#x2F;&#x2F; 这里没有判断是否开辟成功\n\t *p &#x3D; 20;  &#x2F;&#x2F;如果p的值是NULL，就会有问题\n\t free(p);\n\t p &#x3D; NULL;\n&#125;</code></pre>\n\n<h2 id=\"2-对动态开辟空间的越界访问\"><a href=\"#2-对动态开辟空间的越界访问\" class=\"headerlink\" title=\"2.对动态开辟空间的越界访问\"></a>2.对动态开辟空间的越界访问</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void test()\n&#123;\n\t int i &#x3D; 0;\n\t int *p &#x3D; (int *)malloc(10*sizeof(int));\n\t if(NULL &#x3D;&#x3D; p)\n\t &#123;\n\t     exit(-1);\n\t &#125;\n\t \n\t for(i &#x3D; 0; i &lt;&#x3D; 10; i++)\n\t &#123;\n\t     *(p+i) &#x3D; i;&#x2F;&#x2F;当i是10的时候越界访问\n\t &#125;\n\t \n\t free(p);\n\t p &#x3D; NULL;\n&#125;</code></pre>\n<p><strong>当<code>i</code>为<code>10</code>就越界访问了，越界访问的后果就不用多说了把（哈哈哈哈哈，非法闯入）。</strong></p>\n<h2 id=\"3-对非动态开辟内存使用free释放\"><a href=\"#3-对非动态开辟内存使用free释放\" class=\"headerlink\" title=\"3.对非动态开辟内存使用free释放\"></a>3.对非动态开辟内存使用free释放</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void test()\n&#123;\n\t int a &#x3D; 10;\n\t int *p &#x3D; &amp;a;\n\t free(p);  &#x2F;&#x2F;ok?\n\t p &#x3D; NULL;\n&#125;</code></pre>\n<p><strong>free是不能释放除动态开辟的内存以外的内存的，只适用于堆上。</strong></p>\n<h2 id=\"4-使用free释放一块动态开辟内存的一部分\"><a href=\"#4-使用free释放一块动态开辟内存的一部分\" class=\"headerlink\" title=\"4.使用free释放一块动态开辟内存的一部分\"></a>4.使用free释放一块动态开辟内存的一部分</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void test()\n&#123;\n\t int *p &#x3D; (int *)malloc(100);\n\t p++;\n\t free(p);&#x2F;&#x2F;p不再指向动态内存的起始位置\n\t p &#x3D; NULL;\n&#125;</code></pre>\n<p><strong>free这样子释放相当于拦腰截断，会存在内存泄漏的问题。</strong></p>\n<h2 id=\"5-对同一块动态内存多次释放\"><a href=\"#5-对同一块动态内存多次释放\" class=\"headerlink\" title=\"5.对同一块动态内存多次释放\"></a>5.对同一块动态内存多次释放</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void test()\n&#123;\n\t int *p &#x3D; (int *)malloc(100);\n\t free(p);\n\t free(p);&#x2F;&#x2F;重复释放\n\t p &#x3D; NULL;\n&#125;</code></pre>\n\n<p><strong>对同一块空间多次释放，这当然是不行的。</strong></p>\n<h2 id=\"6-动态开辟内存忘记释放（内存泄漏）\"><a href=\"#6-动态开辟内存忘记释放（内存泄漏）\" class=\"headerlink\" title=\"6.动态开辟内存忘记释放（内存泄漏）\"></a>6.动态开辟内存忘记释放（内存泄漏）</h2><p><strong>这样是绝对不行的，内存泄漏迟早会吃光你的内存。</strong></p>\n<p>例如：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void test()\n&#123;\n\t int *p &#x3D; (int *)malloc(100);\n\t if(NULL !&#x3D; p)\n\t &#123;\n\t \t*p &#x3D; 20;\n\t &#125;\n&#125;\nint main()\n&#123;\n\t test();\n\t &#x2F;&#x2F; p指向的动态内存空间没有释放，虽然p变量销毁了，但申请的空间还在\n\t return 0；\n&#125;</code></pre>\n\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>动态内存分配是不是很容易就学会了，接下来就可以 ”肆无忌惮“ 的玩弄 ”数组“ 了，不过要小心内存泄漏噢！</p></blockquote>\n<p><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></p>\n","feature":true,"text":"前言 动态内存管理函数可以说很好用，但是有些小危险。 所谓动态内存分配，就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。 动态内存分配不像 数组 等 静态内存 分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":22,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":22,"path":"api/tags/C语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9F\"><span class=\"toc-text\">为什么存在动态内存分配？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#malloc-%E5%92%8C-free\"><span class=\"toc-text\">malloc 和 free</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-malloc\"><span class=\"toc-text\">1.malloc</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-free\"><span class=\"toc-text\">2.free</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">3.使用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#calloc\"><span class=\"toc-text\">calloc</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#realloc\"><span class=\"toc-text\">realloc</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">常见的动态内存错误</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.对NULL指针的解引用操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">2.对动态开辟空间的越界访问</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">3.对非动态开辟内存使用free释放</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86\"><span class=\"toc-text\">4.使用free释放一块动态开辟内存的一部分</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%AF%B9%E5%90%8C%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">5.对同一块动态内存多次释放</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89\"><span class=\"toc-text\">6.动态开辟内存忘记释放（内存泄漏）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"关于常引用的问题","uid":"53f3e274c7bda3bde7e9b295614179bc","slug":"关于常引用的问题-什么是权限放大？权限放小？隐式或强制转换居然还有这一步？","date":"2023-02-18T06:45:14.000Z","updated":"2023-02-18T06:54:00.841Z","comments":true,"path":"api/articles/关于常引用的问题-什么是权限放大？权限放小？隐式或强制转换居然还有这一步？.json","keywords":null,"cover":"/photo/屏幕截图_20230122_040600.png","text":"前言 引用在c++中的使用非常常见，可以说是很重要的，引用的常引用相关的问题让很多人稍不留神就出错了，这里我们就来谈谈常引用的问题。 关于权限 关于权限有权限缩小和权限放大的问题，比如一个文件，当初它只有读的权限，而现在你给它再加个写的权限，这就是权限放大；又或当初它读，写的权限...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"C++阶段相关知识点与问题的深度解析","slug":"C-阶段相关知识点与问题的深度解析","count":1,"path":"api/categories/C-阶段相关知识点与问题的深度解析.json"}],"tags":[{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"C语言常用内存函数的深度解析与自我实现","uid":"f270be882af30c8038e39539db2e9228","slug":"C语言常用内存函数的深度解析与自我实现","date":"2023-02-18T04:05:03.000Z","updated":"2023-02-18T06:55:07.991Z","comments":true,"path":"api/articles/C语言常用内存函数的深度解析与自我实现.json","keywords":null,"cover":"/photo/R-C.jpeg","text":"前言 内存函数的使用广泛度大于常用字符串函数的使用广泛度，因为字符串函数只适用于与字符相关的，而内存函数适用于各个类型，因为他是从内存出发，对内存进行修改，因此，学会内存函数，可谓收获满满呀。 这些内存函数的头文件是&lt;string.h&gt; memcpy 该函数的功能是内...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":22,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":22,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":true}}