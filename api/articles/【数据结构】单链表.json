{"title":"【数据结构】单链表","uid":"bfad240cf4f429ffe303cb01324aaae0","slug":"【数据结构】单链表","date":"2023-03-03T15:53:13.000Z","updated":"2023-03-03T15:56:22.300Z","comments":true,"path":"api/articles/【数据结构】单链表.json","keywords":null,"cover":"/photo/v2-99dff3d20928f72a1edd7aa1bebc4a21_r.jpg","content":"<hr>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><ul>\n<li><p><font color=blue size=4><strong>在学习数据结构时，单链表可谓是第一个需要跨越的台阶。</strong></font></p>\n</li>\n<li><p>从<code>C语言</code>到<code>数据结构</code>，单链表能够真正的反映我们<code>C语言</code>到底学的扎不扎实，那是因为，单链表对于<code>C语言</code>中的<strong>指针，结构体，以及函数模块的实现</strong>有较高的要求。因此，通过本章的学习，要是能够自我实现单链表，那你的<code>C语言功底</code>会厚实，你的<code>代码能力</code>也会提升。</p>\n</li>\n<li><p>当然，从<code>C语言</code>到数据结构阶段，单链表只是第一个需要跨越的台阶，后面还有更难的数据结构在等着大家，后面我会相继出文章。</p>\n</li>\n</ul>\n<h1 id=\"单链表与顺序表的比较\"><a href=\"#单链表与顺序表的比较\" class=\"headerlink\" title=\"单链表与顺序表的比较\"></a>单链表与顺序表的比较</h1><ul>\n<li><p>顺序表与单链表同属于<code>线性表</code>, \t<font color=red size=4>线性表（linear list）</font>是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结构，常见的线性表有：顺序表、链表、栈、队列、字符串……</p>\n</li>\n<li><p>线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/8173e43ccc3b4901a5f1779b9dbde508.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red size=4>不同：</font></p>\n<ul>\n<li><p>顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。</p>\n</li>\n<li><p>链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/cb054e7f305b4483bb7af43e45ef557e.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>顺序表扩容一般是二倍扩，这势必会有空间浪费。而单链表非如此，你想增加一个节点，就向内存申请一个节点，想去掉一个节点，就释放返还这个节点给内存。这就体现了，在扩容方面，单链表比顺序表要优。</p>\n</li>\n<li><p>顺序表在头插头删或者在任意位置插入删除都需要挪动数组的数据，这必然会使效率下降，时间复杂度最多是<code>O(N^2)</code>。而单链表的这些操作，不需要挪动数据，最多也就<code>O(N)</code>。所以，在增删数据方面，单链表优于顺序表。</p>\n</li>\n<li><p>当然顺序表优于单链表的情况是访问数据操作，顺序表可以直接通过下标访问，为<code>O(1)</code>。而单链表需要从头开始依次寻找，为<code>O(N)</code>。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"单链表初始操作\"><a href=\"#单链表初始操作\" class=\"headerlink\" title=\"单链表初始操作\"></a>单链表初始操作</h1><ul>\n<li><p>同样的，这里也需要三个文件，一个是<code>SList.h（头文件）</code>，<code>SList.c（实现函数接口的文件）</code>，<code>test.c（测试文件）</code>。</p>\n</li>\n<li><p><code>SList.h</code>存放需要使用的库函数的头文件以及单链表节点结构体和接口函数声明。</p>\n</li>\n<li><p>分析单链表的结构，我们需要一个变量来存放数据，需要一个结构体指针来指向下一个节点进行连接，所以初始操作如下：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n&#x2F;&#x2F; malloc 所需头文件\n#include &lt;stdlib.h&gt;\n&#x2F;&#x2F; assert断言所需头文件\n#include &lt;assert.h&gt;\n\n&#x2F;&#x2F; 每个节点存放的数据的类型\ntypedef int SLTDataType;  &#x2F;&#x2F; 这里只需改变int就可以存放不同的数据\n&#x2F;&#x2F; 节点\ntypedef struct SListNode\n&#123;\n\tSLTDataType data;\n\t&#x2F;&#x2F; 存放下一个节点的地址，依此进行链接形成单链表\n\tstruct SListNode* next;\n&#125;SListNode;  &#x2F;&#x2F; typedef 重命名为 SListNode，后面写起来方便</code></pre>\n<p>对应的函数接口有：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 动态申请一个节点\nSListNode* BuySListNode(SLTDataType x);\n&#x2F;&#x2F; 单链表打印\nvoid SListPrint(SListNode* plist);\n\n&#x2F;&#x2F; 单链表尾插\nvoid SListPushBack(SListNode** pplist, SLTDataType x);\n&#x2F;&#x2F; 单链表的头插\nvoid SListPushFront(SListNode** pplist, SLTDataType x);\n&#x2F;&#x2F; 单链表的尾删\nvoid SListPopBack(SListNode** pplist);\n&#x2F;&#x2F; 单链表头删\nvoid SListPopFront(SListNode** pplist);\n\n&#x2F;&#x2F; 单链表查找\nSListNode* SListFind(SListNode* plist, SLTDataType x);\n&#x2F;&#x2F; 单链表修改节点的data\nvoid SListModify(SListNode* pos, SLTDataType NewData);\n\n&#x2F;&#x2F; 单链表在pos位置之后插入x\nvoid SListInsertAfter(SListNode* pos, SLTDataType x);\n&#x2F;&#x2F; 单链表在pos位置之前插入x\nvoid SListInsertBefore(SListNode** pplist, SListNode* pos, SLTDataType x);\n\n&#x2F;&#x2F; 单链表删除pos位置之后的值\nvoid SListEraseAfter(SListNode* pos);\n&#x2F;&#x2F; 单链表删除pos位置的值\nvoid SListErasePos(SListNode** pplist, SListNode* pos);\n&#x2F;&#x2F; 单链表删除pos位置之前的值\nvoid SListEraseBefore(SListNode** pplist, SListNode* pos);\n\n&#x2F;&#x2F; 单链表的销毁\nvoid SListDestroy(SListNode** pplist);</code></pre>\n<p><strong>我们只需要在<code>SList.c</code>与<code>test.c</code>文件开头包含<code>SList.h</code>,即可链接。</strong></p>\n<ul>\n<li>有了上述的初始操作，接下来只需将头文件里的函数接口一一实现即可。</li>\n</ul>\n<hr>\n<h1 id=\"得到一个节点\"><a href=\"#得到一个节点\" class=\"headerlink\" title=\"得到一个节点\"></a>得到一个节点</h1><ul>\n<li><p>单链表的每一个元素我们称之为节点，每个节点存放着相应的数据和下一个节点的地址</p>\n</li>\n<li><p>单链表从得到一个节点开始，由于后面的插入形式有多种，而在每个插入函数中都写得到一个节点的代码，未免有些麻烦，因此，这里将得到一个节点的功能单独拿出来作为一个函数，要插入直接调用这个函数获取节点即可。</p>\n</li>\n<li><p>每当获取一个节点的时候，节点内的结构体指针都指向<code>NULL</code>。</p>\n</li>\n<li><p>这里的节点是我们通过<code>malloc</code>在内存中申请的一段空间来存放的，并且每个节点之间的地址不连续（随机申请，可能相邻）。</p>\n</li>\n<li><p>当我们向内存申请了一个节点时，需要返回指向这个节点的指针，如果不返回的话，函数结束后，指向这个节点的指针会被销毁，此时这个节点就找不到了，也就出现了内存泄漏的问题，所以，一定要返回指向这个节点的指针。</p>\n</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 动态申请一个节点\nSListNode* BuySListNode(SLTDataType x)\n&#123;\n\tSListNode* newnode &#x3D; (SListNode*)malloc(sizeof(SListNode));\n\t&#x2F;&#x2F; 判断一下是否申请失败，malloc申请失败返回空指针\n\tassert(newnode);\n\t&#x2F;&#x2F; 存放相应数据\n\tnewnode-&gt;data &#x3D; x;\n\t&#x2F;&#x2F; 初始化NULL\n\tnewnode-&gt;next &#x3D; NULL;\n\n\t&#x2F;&#x2F; 返回指向这个节点的指针\n\treturn newnode;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"单链表的打印\"><a href=\"#单链表的打印\" class=\"headerlink\" title=\"单链表的打印\"></a>单链表的打印</h1><ul>\n<li><p>由于单链表是用指针相连的，因此也需要运用指针来遍历单链表。</p>\n</li>\n<li><p>我们只有单链表的头指针，运用这个头指针，依次向下找节点并打印相应的数据，直到这个指针为<code>NULL</code>结束。因此，遍历单链表的循环条件是这个指针不为<code>NULL</code>。</p>\n</li>\n<li><p>如果传递过来的头指针是空，也就说明这个单链表是空链表，此时循环不会进去，也就不会打印。</p>\n</li>\n<li><p>所以，该函数模块不需要<code>assert</code>来判断单链表是不是空链表。是空他就不打印嘛。</p>\n</li>\n<li><p>对于如何遍历，如果<code>phead</code>是指向头节点的指针，我们只需要<code>phead = phead-&gt;next;</code>即可使<code>phead</code>指向下一个节点。</p>\n</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表打印\nvoid SListPrint(SListNode* plist)\n&#123;\n\tSListNode* cur &#x3D; plist;\n\t&#x2F;&#x2F; 如果cur为NULL停止循环\n\twhile (cur)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, cur-&gt;data);\n\t\t&#x2F;&#x2F; 跳到下一个节点\n\t\tcur &#x3D; cur-&gt;next;\n\t&#125;\n\t&#x2F;&#x2F; 最后指向NULL，打印NULL\n\tprintf(&quot;NULL\\n&quot;);\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"单链表的销毁\"><a href=\"#单链表的销毁\" class=\"headerlink\" title=\"单链表的销毁\"></a>单链表的销毁</h1><ul>\n<li><p>由于单链表的每一个节点是用 &#x3D;&#x3D;malloc&#x3D;&#x3D; 在堆上申请的空间，因此，在程序运行的最后需要将这些空间返还给操作系统。</p>\n</li>\n<li><p>返还空间给操作系统使用的对应函数为&#x3D;&#x3D;free&#x3D;&#x3D; ，这里，我们不能天真的以为<code>free</code>指向头节点的指针就可以释放掉整个链表，因为每一个节点的空间分配是不连续的，所以这里也是要遍历一遍单链表，并依次释放每一个节点的空间。</p>\n</li>\n<li><p>由于又要释放节点，又要遍历单链表，因此这里需要两个指针来操控，一个指针用来释放指向对应的空间，一个指针用来存放下一个节点的地址。</p>\n</li>\n<li><p>我这里的销毁函数是传递一个<code>二级指针</code>的，也就是传递单链表的头指针的地址。当然，就将单链表的头指针传递过来也是可以的，我是为了能够释放完所有空间后将单链表的头指针置为<code>NULL</code>才这样做的（怕有人销毁完单链表后还用之前的单链表的头指针进行操作）。</p>\n</li>\n<li><p>当然，此函数需要<code>assert</code>断言判断传过来的二级指针是否是<code>NULL</code>指针。如果是空指针就不再进行后续的操作了。但是，单链表可以为空，因为他为空的话，解引用二级指针（单链表的头节点指针）就为空，此时循环就不会进去。</p>\n</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表的销毁\nvoid SListDestroy(SListNode** pplist)\n&#123;\n\tassert(pplist);\n\t\n\tSListNode* cur &#x3D; *pplist;\n\t&#x2F;&#x2F; cur为空的话while不执行\n\twhile (cur)\n\t&#123;\n\t\tSListNode* tmp &#x3D; cur;\n\t\tcur &#x3D; cur-&gt;next;\n\t\tfree(tmp);\n\t&#125;\n\t*pplist &#x3D; NULL;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"单链表的尾插\"><a href=\"#单链表的尾插\" class=\"headerlink\" title=\"单链表的尾插\"></a>单链表的尾插</h1><ul>\n<li><p>既然是插入，就需要获取一个节点，这时候就需要调用&#x3D;&#x3D;BuySListNode&#x3D;&#x3D;函数了。</p>\n</li>\n<li><p>单链表的尾插是比较简单的，通过循环利用指针依次寻找下一节点，直到找到最后一个节点为止，在将最后一个节点的节点指针<code>next</code>指向新的节点即可。</p>\n</li>\n<li><p>如果此时单链表为空，当然也是可以插入的，只不过这里就需要分两个情况了，就是单链表为空和不为空。</p>\n</li>\n<li><p>当单链表为空时插入，此时就是插入一个头节点，所以传过来的空指针要指向这个头节点，也就是节点指针需要改变。在调用函数时，一个指针的值需要改变，那就需要传递这个指针的地址，所以该函数需要使用二级指针来接受这个指针的地址。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/a5d67a5659534453bbedd2aeab2fb11c.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>由于是二级指针，因此这里需要<code>assert</code>断言一下这个二级指针，怕直接传递一个空指针过来或者传递一个一级指针。</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表尾插\n&#x2F;&#x2F; 二级指针接收一级指针的地址\nvoid SListPushBack(SListNode** pplist, SLTDataType x)\n&#123;\n\t&#x2F;&#x2F; 断言二级指针，截断二级指针为NULL的情况\n\tassert(pplist);\n\t\n\t&#x2F;&#x2F; 获取一个结点\n\tSListNode* newnode &#x3D; BuySListNode(x);\n\t&#x2F;&#x2F; 如果单链表为空，更新头节点即可\n\tif (*pplist &#x3D;&#x3D; NULL) *pplist &#x3D; newnode;\n\telse\n\t&#123;\n\t\tSListNode* cur &#x3D; *pplist;\n\t\t&#x2F;&#x2F; 遍历找尾节点，如果该节点的next为NULL，说明此节点就是尾节点，停止循环\n\t\twhile (cur-&gt;next) cur &#x3D; cur-&gt;next;\n\t\t&#x2F;&#x2F; 连接新的尾\n\t\tcur-&gt;next &#x3D; newnode;\n\t&#125;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"单链表的头插\"><a href=\"#单链表的头插\" class=\"headerlink\" title=\"单链表的头插\"></a>单链表的头插</h1><ul>\n<li><p>既然是插入，就需要获取一个节点，这时候就需要调用&#x3D;&#x3D;BuySListNode&#x3D;&#x3D;函数了。</p>\n</li>\n<li><p>单链表的头插不需要遍历单链表，只要将新节点的<code>next</code>指向此时单链表的头节点即可。当然单链表指向头节点的指针需要改变指向新的头节点。既然需要改变头指针，那么此时就需要用到二级指针来操作了。</p>\n</li>\n<li><p>如果此时单链表为空，也是一样，直接插入，更改头指针（二级指针操作）指向这个结点即可。</p>\n</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表的头插\nvoid SListPushFront(SListNode** pplist, SLTDataType x)\n&#123;\n\tassert(pplist);\n\n\tSListNode* newnode &#x3D; BuySListNode(x);\n\t&#x2F;&#x2F; 如果单链表为空，更新头节点即可\n\tif (*pplist &#x3D;&#x3D; NULL) *pplist &#x3D; newnode;\n\telse  &#x2F;&#x2F; 不为空则将newnode的next指向当前的头节点即可\n\t&#123;\n\t\tnewnode-&gt;next &#x3D; *pplist;\n\t\t&#x2F;&#x2F; 更新头节点\n\t\t*pplist &#x3D; newnode;\n\t&#125;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"单链表的尾删\"><a href=\"#单链表的尾删\" class=\"headerlink\" title=\"单链表的尾删\"></a>单链表的尾删</h1><ul>\n<li><p>尾删，既然是尾，那么就需要遍历单链表找尾，但要注意的是，我们还需要找到尾的前一个节点，因为删完尾后，新的尾的<code>next</code>需要置为<code>NULL</code>。</p>\n</li>\n<li><p>既然需要找到尾的前一个节点，那么循环内就需要两个指针来进行操作，如果说此时单链表只有一个节点，那么尾节点的前一个节点就不存在，因此此时对指向尾的前一个结点的指针进行操作就会出现问题，所以当单链表只有一个节点的时候，需要单独操作。</p>\n</li>\n<li><p>当只有一个节点的时候，我们直接<code>free</code>头节点即可。这里需要将指向头节点的指针置为<code>NULL</code>（避免后面对该指针进行不当的操作），因此，这里也是需要使用二级指针的。</p>\n</li>\n<li><p>当单链表为空的时候，是不可以删的，因此这里需要<code>assert</code>断言判断单链表是否为空，如果为空，直接暴力结束程序不给他删。</p>\n</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表的尾删\nvoid SListPopBack(SListNode** pplist)\n&#123;\n\t&#x2F;&#x2F; 断言判断pplist是否为NULL，判断链表是否为空（为空就不能删）\n\tassert(pplist &amp;&amp; *pplist);\n\t\n\t&#x2F;&#x2F; 如果此时单链表只有一个节点，直接free头节点，将指向头节点的指针置为空，此时需要二级指针来操作\n\tif (!(*pplist)-&gt;next) free(*pplist), * pplist &#x3D; NULL;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F; 找尾，和找尾的前一个节点，需要两个指针来操作\n\t\tSListNode* cur &#x3D; *pplist, * tmp &#x3D; NULL;\n\t\twhile (cur-&gt;next)  &#x2F;&#x2F; 判断条件找到尾就停止\n\t\t&#123;\n\t\t\ttmp &#x3D; cur;  &#x2F;&#x2F; 最终tmp会指向尾节点的前一个节点\n\t\t\tcur &#x3D; cur-&gt;next;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 释放尾节点\n\t\tfree(cur);\n\t\t&#x2F;&#x2F; 将尾节点的前一个节点置为NULL\n\t\ttmp-&gt;next &#x3D; NULL;\n\t&#125;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"单链表的头删\"><a href=\"#单链表的头删\" class=\"headerlink\" title=\"单链表的头删\"></a>单链表的头删</h1><ul>\n<li><p>头删不需要遍历单链表，只需释放头节点即可。</p>\n</li>\n<li><p>当然，删除前需要找到头节点的下一个节点，这是因为头节点删除后，单链表的头需要更新，而新的头也就是删除的那个头节点的下一个节点。</p>\n</li>\n<li><p>要更新新的头也就是需要改变头指针，因此这里也是需要用到二级指针的。</p>\n</li>\n<li><p>既然是删除，当然也要判断单链表是否为空。</p>\n</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表头删\nvoid SListPopFront(SListNode** pplist)\n&#123;\n\t&#x2F;&#x2F; 判断pplist是否为空指针，判断单链表是否为空\n\tassert(pplist &amp;&amp; *pplist);\n\t\n\t&#x2F;&#x2F; 先存放下一个节点\n\tSListNode* cur &#x3D; (*pplist)-&gt;next;\n\t&#x2F;&#x2F; 释放头节点\n\tfree(*pplist);\n\t&#x2F;&#x2F; 更新头节点\n\t*pplist &#x3D; cur;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"单链表的查找\"><a href=\"#单链表的查找\" class=\"headerlink\" title=\"单链表的查找\"></a>单链表的查找</h1><ul>\n<li><p>查找比较简单，就是遍历单链表看看<code>val</code>与那个节点的数据相等，相等则返回该节点的地址，如果遍历完单链表都没有找到，那么返回<code>NULL</code>。</p>\n</li>\n<li><p>查找函数不需要判断单链表是否为空，因为如果单链表为空的话，循环就不进去，直接返回空，就说明找不到，当然啦，空的单链表当然找不到啦。</p>\n</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表查找\nSListNode* SListFind(SListNode* plist, SLTDataType x)\n&#123;\n\tSListNode* cur &#x3D; plist;\n\t&#x2F;&#x2F; 当cur为空时结束循环\n\twhile (cur)\n\t&#123;\n\t\tif (cur-&gt;data &#x3D;&#x3D; x) return cur;\n\t\tcur &#x3D; cur-&gt;next;\n\t&#125;\n\t&#x2F;&#x2F; 如果没找到就返回NULL\n\treturn NULL;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"单链表节点数据的修改\"><a href=\"#单链表节点数据的修改\" class=\"headerlink\" title=\"单链表节点数据的修改\"></a>单链表节点数据的修改</h1><ul>\n<li><p>该函数是将你想修改的节点的数据改为你想要的值。</p>\n</li>\n<li><p>一般的，修改函数与查找函数是一起用的，因为有了前面的查找函数，我们可以先查找在修改。因此该函数的第一个参数为指向单链表节点的指针。</p>\n</li>\n<li><p>当然，这里需要判断一下节点指针是否合法，如果该指针为<code>NULL</code>，说明在查找的时候没有找到对应数据的节点，此时直接暴力结束。</p>\n</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表修改节点的data\nvoid SListModify(SListNode* pos, SLTDataType NewData)\n&#123;\n\t&#x2F;&#x2F; 一般以find的返回值作为pos参数\n\t&#x2F;&#x2F; 如果pos为空，说明没有这个节点，这里断言一下\n\tassert(pos);\n\t\n\tpos-&gt;data &#x3D; NewData;\n&#125;\n</code></pre>\n\n<hr>\n<h1 id=\"单链表在pos位置之后插入节点\"><a href=\"#单链表在pos位置之后插入节点\" class=\"headerlink\" title=\"单链表在pos位置之后插入节点\"></a>单链表在pos位置之后插入节点</h1><ul>\n<li><p>既然是<code>pos</code>位置之后，因此我们需要先利用查找函数来确定你想要的<code>pos</code>，然后再进行插入。</p>\n</li>\n<li><p>插入需要先获取一个节点，调用&#x3D;&#x3D;BuySListNode&#x3D;&#x3D;函数。</p>\n</li>\n<li><p>插入操作前，我们需要一个节点指针指向<code>pos</code>位置的下一个节点，这样是为了连接，然后插入操作<strong>如下图：</strong></p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/18399597ed294f1abf0e433ffd42f370.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>当然，这里也需要判断一下<code>pos</code>的合法性。</li>\n</ul>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表在pos位置之后插入x\nvoid SListInsertAfter(SListNode* pos, SLTDataType x)\n&#123;\n\t&#x2F;&#x2F; 判断pos就间接的判断了单链表是否为空的情况\n\tassert(pos);\n\n\tSListNode* newnode &#x3D; BuySListNode(x);\n\t&#x2F;&#x2F; 存放pos节点的下一个节点\n\tSListNode* tmp &#x3D; pos-&gt;next;\n\tpos-&gt;next &#x3D; newnode;\n\tnewnode-&gt;next &#x3D; tmp;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"单链表在pos位置之前插入节点\"><a href=\"#单链表在pos位置之前插入节点\" class=\"headerlink\" title=\"单链表在pos位置之前插入节点\"></a>单链表在pos位置之前插入节点</h1><ul>\n<li><p>既然是在<code>pos</code>位置之前插入，但单链表具有单向性，因此这里需要遍历单链表找到<code>pos</code>位置的前一个节点，然后再进行插入。</p>\n</li>\n<li><p>可以取巧的是，如果<code>pos</code>刚好指向头节点，此时直接调用头插。</p>\n</li>\n<li><p>由于这里调用了头插，而头插使用的是二级指针，因此该函数也是需要二级指针来操作的。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/56c3b8838cb94dbf86c41eb3e2ffe224.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表在pos位置之前插入x\nvoid SListInsertBefore(SListNode** pplist, SListNode* pos, SLTDataType x)\n&#123;\n\t&#x2F;&#x2F; 如果pos不合法，就说明要么再查找时没有该节点，要么单链表为空，因此这里间接判断了单链表是否为空的情况\n\tassert(pplist &amp;&amp; pos);\n\n\t&#x2F;&#x2F; 如果pos为第一个节点，直接调用前面的头插\n\tif (*pplist &#x3D;&#x3D; pos) SListPushFront(pplist, x);\n\telse\n\t&#123;\n\t\tSListNode* newnode &#x3D; BuySListNode(x);\n\t\tSListNode* cur &#x3D; *pplist;\n\t\t&#x2F;&#x2F; 找pos位置的前面一个节点\n\t\twhile (cur-&gt;next !&#x3D; pos)\n\t\t\tcur &#x3D; cur-&gt;next;\n\t\t&#x2F;&#x2F; 连接\n\t\tcur-&gt;next &#x3D; newnode;\n\t\tnewnode-&gt;next &#x3D; pos;\n\t&#125;\n&#125;</code></pre>\n\n\n\n<hr>\n<h1 id=\"单链表删除pos位置之后的节点\"><a href=\"#单链表删除pos位置之后的节点\" class=\"headerlink\" title=\"单链表删除pos位置之后的节点\"></a>单链表删除pos位置之后的节点</h1><ul>\n<li><p>由于是直接对<code>pos</code>节点后面的节点进行操作，因此不需要传递头节点。</p>\n</li>\n<li><p>对于<code>pos</code>，如果<code>pos</code>合法，就说明单链表一定不为空。</p>\n</li>\n<li><p>因此这里只需要判断<code>pos</code>的合法性，当然，如果<code>pos</code>恰好指向最后一个节点，此时就删不了了，所以这种情况也需要<code>assert</code>断言。</p>\n</li>\n<li><p>对于删除操作，首先需要找到<code>pos</code>的下一个节点的下一个节点，这是为了连接，然后再对<code>pos</code>的下一个节点进行删除。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/0b1f1b4d599b473184b38c5169130e95.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表删除pos位置之后的值\nvoid SListEraseAfter(SListNode* pos)\n&#123;\n\t&#x2F;&#x2F; 直接判断pos\n\tassert(pos &amp;&amp; pos-&gt;next);\n\n\t&#x2F;&#x2F; 存放pos下一个节点的下一个节点\n\tSListNode* tmp &#x3D; pos-&gt;next-&gt;next;\n\t&#x2F;&#x2F; 释放pos的下一个节点\n\tfree(pos-&gt;next);\n\t&#x2F;&#x2F; 连接\n\tpos-&gt;next &#x3D; tmp;\n&#125;</code></pre>\n\n\n\n<hr>\n<h1 id=\"单链表删除pos位置之前的节点\"><a href=\"#单链表删除pos位置之前的节点\" class=\"headerlink\" title=\"单链表删除pos位置之前的节点\"></a>单链表删除pos位置之前的节点</h1><ul>\n<li><p>在之前，同样的，需要遍历单链表，找到<code>pos</code>节点的前一个节点和<code>pos</code>节点的前一个节点的前一个节点。</p>\n</li>\n<li><p>如果<code>pos</code>刚好指向头节点，这是删不了的，会出问题，因此需要<code>assert</code>断言；如果<code>pos</code>刚好指向头节点的下一个节点，这里直接调用头删完成删除。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/17c1819a6f6648e9a19a36c404c102ae.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表删除pos位置之前的值\n&#x2F;&#x2F; 使用二级指针是因为调用头删函数需要传递二级指针，当然二级指针便于操作\nvoid SListEraseBefore(SListNode** pplist, SListNode* pos)\n&#123;\n\t&#x2F;&#x2F; pplist不能为NULL\n\t&#x2F;&#x2F; pos要合法，间接体现了单链表是否为空\n\t&#x2F;&#x2F; pos不能指向头节点，因为头节点的前面没有节点\n\tassert(pplist &amp;&amp; pos &amp;&amp; pos !&#x3D; *pplist);\n\n\t&#x2F;&#x2F; 如果pos指向头节点的下一个节点，直接调用头删函数完成删除\n\tif ((*pplist)-&gt;next &#x3D;&#x3D; pos) SListPopFront(pplist);\n\telse  &#x2F;&#x2F; 正常情况\n\t&#123;\n\t    &#x2F;&#x2F; cur最终要指向pos的前一个结点，tmp最终要指向pos的前一个节点的前一个节点\n\t\tSListNode* cur &#x3D; *pplist, * tmp &#x3D; NULL;\n\t\t&#x2F;&#x2F; 循环找位\n\t\twhile (cur-&gt;next !&#x3D; pos)\n\t\t&#123;\n\t\t\ttmp &#x3D; cur;\n\t\t\tcur &#x3D; cur-&gt;next;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 删除前一个结点\n\t\tfree(cur);\n\t\t&#x2F;&#x2F; 连接\n\t\ttmp-&gt;next &#x3D; pos;\n\t&#125;\n&#125;</code></pre>\n\n\n\n<hr>\n<h1 id=\"单链表删除pos位置的节点\"><a href=\"#单链表删除pos位置的节点\" class=\"headerlink\" title=\"单链表删除pos位置的节点\"></a>单链表删除pos位置的节点</h1><ul>\n<li><p>如果<code>pos</code>刚好指向头节点，直接调用头删；如果<code>pos</code>刚好指向尾节点（用<code>pos-&gt;next == NULL ?</code> 判断），直接调用尾删。</p>\n</li>\n<li><p>因为头删尾删都需要传递二级指针，因此该函数也运用二级指针，而且二级指针也便于操作。</p>\n</li>\n<li><p>一般情况，我们只需要遍历单链表找到<code>pos</code>节点的前一个结点和存放<code>pos</code>的后一个节点，然后将<code>pos</code>节点删除，连接<code>pos</code>的前一个节点和<code>pos</code>的后一个节点即可。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/504c07d1e83f46619108b4eecd9589ac.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red size=4>下面是相关接口函数的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 单链表删除pos位置的值\nvoid SListErasePos(SListNode** pplist, SListNode* pos)\n&#123;\n\tassert(pplist &amp;&amp; pos);\n\n\tif (*pplist &#x3D;&#x3D; pos) SListPopFront(pplist); &#x2F;&#x2F; 如果pos是指向头节点，直接复用头删\n\telse if (!pos-&gt;next) SListPopBack(pplist); &#x2F;&#x2F; 如果pos是指向尾节点，直接复用尾删\n\telse  &#x2F;&#x2F; 一般情况\n\t&#123;\n\t\t&#x2F;&#x2F; cur为pos的前一个结点\n\t\tSListNode* cur &#x3D; *pplist;\n\t\twhile (cur-&gt;next !&#x3D; pos) cur &#x3D; cur-&gt;next;\n\t\t&#x2F;&#x2F; tmp为pos的后一个结点\n\t\tSListNode* tmp &#x3D; pos-&gt;next;\n\t\t&#x2F;&#x2F; 删除pos结点\n\t\tfree(pos);\n\t\t&#x2F;&#x2F; 将pos的前一个节点与pos的后一个节点连接\n\t\tcur-&gt;next &#x3D; tmp;\n\t&#125;\n&#125;</code></pre>\n\n\n\n<hr>\n<h1 id=\"整体代码\"><a href=\"#整体代码\" class=\"headerlink\" title=\"整体代码\"></a>整体代码</h1><p><font color=red size=5>SList.h</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\ntypedef int SLTDataType;\ntypedef struct SListNode\n&#123;\n\tSLTDataType data;\n\tstruct SListNode* next;\n&#125;SListNode;\n\n&#x2F;&#x2F; 动态申请一个节点\nSListNode* BuySListNode(SLTDataType x);\n&#x2F;&#x2F; 单链表打印\nvoid SListPrint(SListNode* plist);\n\n&#x2F;&#x2F; 单链表尾插\nvoid SListPushBack(SListNode** pplist, SLTDataType x);\n&#x2F;&#x2F; 单链表的头插\nvoid SListPushFront(SListNode** pplist, SLTDataType x);\n&#x2F;&#x2F; 单链表的尾删\nvoid SListPopBack(SListNode** pplist);\n&#x2F;&#x2F; 单链表头删\nvoid SListPopFront(SListNode** pplist);\n\n&#x2F;&#x2F; 单链表查找\nSListNode* SListFind(SListNode* plist, SLTDataType x);\n&#x2F;&#x2F; 单链表修改节点的data\nvoid SListModify(SListNode* pos, SLTDataType NewData);\n\n&#x2F;&#x2F; 单链表在pos位置之后插入x\nvoid SListInsertAfter(SListNode* pos, SLTDataType x);\n&#x2F;&#x2F; 单链表在pos位置之前插入x\nvoid SListInsertBefore(SListNode** pplist, SListNode* pos, SLTDataType x);\n\n&#x2F;&#x2F; 单链表删除pos位置之后的值\nvoid SListEraseAfter(SListNode* pos);\n&#x2F;&#x2F; 单链表删除pos位置的值\nvoid SListErasePos(SListNode** pplist, SListNode* pos);\n&#x2F;&#x2F; 单链表删除pos位置之前的值\nvoid SListEraseBefore(SListNode** pplist, SListNode* pos);\n\n&#x2F;&#x2F; 单链表的销毁\nvoid SListDestroy(SListNode** pplist);</code></pre>\n\n<p><font color=red size=5>SList.c</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;SList.h&quot;\n\n&#x2F;&#x2F; 动态申请一个节点\nSListNode* BuySListNode(SLTDataType x)\n&#123;\n\tSListNode* newnode &#x3D; (SListNode*)malloc(sizeof(SListNode));\n\tassert(newnode);\n\tnewnode-&gt;data &#x3D; x;\n\tnewnode-&gt;next &#x3D; NULL;\n\n\treturn newnode;\n&#125;\n&#x2F;&#x2F; 单链表打印\nvoid SListPrint(SListNode* plist)\n&#123;\n\tSListNode* cur &#x3D; plist;\n\twhile (cur)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, cur-&gt;data);\n\t\tcur &#x3D; cur-&gt;next;\n\t&#125;\n\tprintf(&quot;NULL\\n&quot;);\n&#125;\n\n&#x2F;&#x2F; 单链表的销毁\nvoid SListDestroy(SListNode** pplist)\n&#123;\n\tassert(pplist);\n\t\n\tSListNode* cur &#x3D; *pplist;\n\twhile (cur)\n\t&#123;\n\t\tSListNode* tmp &#x3D; cur;\n\t\tcur &#x3D; cur-&gt;next;\n\t\tfree(tmp);\n\t&#125;\n\t*pplist &#x3D; NULL;\n&#125;\n\n&#x2F;&#x2F; 单链表尾插\nvoid SListPushBack(SListNode** pplist, SLTDataType x)\n&#123;\n\tassert(pplist);\n\n\tSListNode* newnode &#x3D; BuySListNode(x);\n\tif (*pplist &#x3D;&#x3D; NULL) *pplist &#x3D; newnode;\n\telse\n\t&#123;\n\t\tSListNode* cur &#x3D; *pplist;\n\t\twhile (cur-&gt;next) cur &#x3D; cur-&gt;next;\n\t\tcur-&gt;next &#x3D; newnode;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 单链表的头插\nvoid SListPushFront(SListNode** pplist, SLTDataType x)\n&#123;\n\tassert(pplist);\n\n\tSListNode* newnode &#x3D; BuySListNode(x);\n\tif (*pplist &#x3D;&#x3D; NULL) *pplist &#x3D; newnode;\n\telse\n\t&#123;\n\t\tnewnode-&gt;next &#x3D; *pplist;\n\t\t*pplist &#x3D; newnode;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 单链表的尾删\nvoid SListPopBack(SListNode** pplist)\n&#123;\n\tassert(pplist &amp;&amp; *pplist);\n\n\tif (!(*pplist)-&gt;next) free(*pplist), * pplist &#x3D; NULL;\n\telse\n\t&#123;\n\t\tSListNode* cur &#x3D; *pplist, * tmp &#x3D; NULL;\n\t\twhile (cur-&gt;next)\n\t\t&#123;\n\t\t\ttmp &#x3D; cur;\n\t\t\tcur &#x3D; cur-&gt;next;\n\t\t&#125;\n\t\tfree(cur);\n\t\ttmp-&gt;next &#x3D; NULL;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 单链表头删\nvoid SListPopFront(SListNode** pplist)\n&#123;\n\tassert(pplist &amp;&amp; *pplist);\n\n\tSListNode* cur &#x3D; (*pplist)-&gt;next;\n\tfree(*pplist);\n\t*pplist &#x3D; cur;\n&#125;\n\n&#x2F;&#x2F; 单链表查找\nSListNode* SListFind(SListNode* plist, SLTDataType x)\n&#123;\n\t&#x2F;&#x2F; 这里可以不断言，但建议断言，因为使用find返回NULL可能是单链表本身就是空的，\n\t&#x2F;&#x2F; 但一般是找不到才返回NULL\n\tassert(plist);\n\n\tSListNode* cur &#x3D; plist;\n\twhile (cur)\n\t&#123;\n\t\tif (cur-&gt;data &#x3D;&#x3D; x) return cur;\n\t\tcur &#x3D; cur-&gt;next;\n\t&#125;\n\treturn NULL;\n&#125;\n&#x2F;&#x2F; 单链表修改节点的data\nvoid SListModify(SListNode* pos, SLTDataType NewData)\n&#123;\n\t&#x2F;&#x2F; 一般以find的返回值作为pos参数\n\t&#x2F;&#x2F; 如果pos为空，说明没有这个节点，这里断言一下\n\tassert(pos);\n\n\tpos-&gt;data &#x3D; NewData;\n&#125;\n\n&#x2F;&#x2F; 单链表在pos位置之后插入x\nvoid SListInsertAfter(SListNode* pos, SLTDataType x)\n&#123;\n\tassert(pos);\n\n\tSListNode* newnode &#x3D; BuySListNode(x);\n\tSListNode* tmp &#x3D; pos-&gt;next;\n\tpos-&gt;next &#x3D; newnode;\n\tnewnode-&gt;next &#x3D; tmp;\n&#125;\n&#x2F;&#x2F; 单链表在pos位置之前插入x\nvoid SListInsertBefore(SListNode** pplist, SListNode* pos, SLTDataType x)\n&#123;\n\tassert(pplist &amp;&amp; pos);\n\n\tif (*pplist &#x3D;&#x3D; pos) SListPushFront(pplist, x);\n\telse\n\t&#123;\n\t\tSListNode* newnode &#x3D; BuySListNode(x);\n\t\tSListNode* cur &#x3D; *pplist;\n\t\twhile (cur-&gt;next !&#x3D; pos)\n\t\t\tcur &#x3D; cur-&gt;next;\n\t\tcur-&gt;next &#x3D; newnode;\n\t\tnewnode-&gt;next &#x3D; pos;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 单链表删除pos位置之后的值\nvoid SListEraseAfter(SListNode* pos)\n&#123;\n\tassert(pos &amp;&amp; pos-&gt;next);\n\n\tSListNode* tmp &#x3D; pos-&gt;next-&gt;next;\n\tfree(pos-&gt;next);\n\tpos-&gt;next &#x3D; tmp;\n&#125;\n&#x2F;&#x2F; 单链表删除pos位置的值\nvoid SListErasePos(SListNode** pplist, SListNode* pos)\n&#123;\n\tassert(pplist &amp;&amp; pos);\n\n\tif (*pplist &#x3D;&#x3D; pos) SListPopFront(pplist); &#x2F;&#x2F; 如果pos是指向头节点，直接复用头删\n\telse if (!pos-&gt;next) SListPopBack(pplist); &#x2F;&#x2F; 如果pos是指向尾节点，直接复用尾删\n\telse\n\t&#123;\n\t\tSListNode* cur &#x3D; *pplist;\n\t\twhile (cur-&gt;next !&#x3D; pos) cur &#x3D; cur-&gt;next;\n\t\tSListNode* tmp &#x3D; pos-&gt;next;\n\t\tfree(pos);\n\t\tcur-&gt;next &#x3D; tmp;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 单链表删除pos位置之前的值\nvoid SListEraseBefore(SListNode** pplist, SListNode* pos)\n&#123;\n\tassert(pplist &amp;&amp; pos &amp;&amp; pos !&#x3D; *pplist);\n\n\tif ((*pplist)-&gt;next &#x3D;&#x3D; pos) SListPopFront(pplist);\n\telse\n\t&#123;\n\t\tSListNode* cur &#x3D; *pplist, * tmp &#x3D; NULL;\n\t\twhile (cur-&gt;next !&#x3D; pos)\n\t\t&#123;\n\t\t\ttmp &#x3D; cur;\n\t\t\tcur &#x3D; cur-&gt;next;\n\t\t&#125;\n\t\tfree(cur);\n\t\ttmp-&gt;next &#x3D; pos;\n\t&#125;\n&#125;</code></pre>\n\n<p><font color=red size=5>test.c</font></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里有多个测试用例，可以自己捣鼓。</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;SList.h&quot;\n\nvoid TestList1()\n&#123;\n\tSListNode* plist &#x3D; NULL;\n\n\tSListPrint(plist);\n\tSListPushBack(&amp;plist, 1);\n\tSListPrint(plist);\n\tSListPushBack(&amp;plist, 2);\n\tSListPrint(plist);\n\tSListPushBack(&amp;plist, 3);\n\tSListPrint(plist);\n\tSListPushBack(&amp;plist, 4);\n\tSListPrint(plist);\n\tSListPushBack(&amp;plist, 5);\n\tSListPrint(plist);\n\tSListPushBack(&amp;plist, 6);\n\tSListPrint(plist);\n\n\tSListPopBack(&amp;plist);\n\tSListPrint(plist);\n\tSListPopBack(&amp;plist);\n\tSListPrint(plist);\n\tSListPopBack(&amp;plist);\n\tSListPrint(plist);\n\tSListPopBack(&amp;plist);\n\tSListPrint(plist);\n\tSListPopBack(&amp;plist);\n\tSListPrint(plist);\n\tSListPopBack(&amp;plist);\n\tSListPrint(plist);\n\n\tSListDestroy(&amp;plist);\n&#125;\n\nvoid TestList2()\n&#123;\n\tSListNode* plist &#x3D; NULL;\n\tSListPrint(plist);\n\n\tSListPushFront(&amp;plist, 1);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 2);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 3);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 4);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 5);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 6);\n\tSListPrint(plist);\n\n\tSListPopFront(&amp;plist);\n\tSListPrint(plist);\n\tSListPopFront(&amp;plist);\n\tSListPrint(plist);\n\tSListPopFront(&amp;plist);\n\tSListPrint(plist);\n\tSListPopFront(&amp;plist);\n\tSListPrint(plist);\n\tSListPopFront(&amp;plist);\n\tSListPrint(plist);\n\tSListPopFront(&amp;plist);\n\tSListPrint(plist);\n\n\tSListDestroy(&amp;plist);\n&#125;\n\nvoid TestList3()\n&#123;\n\tSListNode* plist &#x3D; NULL;\n\tSListPrint(plist);\n\n\tSListPushFront(&amp;plist, 1);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 2);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 3);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 4);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 5);\n\tSListPrint(plist);\n\tSListPushFront(&amp;plist, 6);\n\tSListPrint(plist);\n\n\tSListModify(SListFind(plist, 1), 99999);\n\tSListPrint(plist);\n\tSListModify(SListFind(plist, 2), 99999);\n\tSListPrint(plist);\n\tSListModify(SListFind(plist, 3), 99999);\n\tSListPrint(plist);\n\tSListModify(SListFind(plist, 4), 99999);\n\tSListPrint(plist);\n\tSListModify(SListFind(plist, 5), 99999);\n\tSListPrint(plist);\n\tSListModify(SListFind(plist, 6), 99999);\n\tSListPrint(plist);\n\n\tSListDestroy(&amp;plist);\n&#125;\n\nvoid TestList4()\n&#123;\n\tSListNode* plist &#x3D; NULL;\n\n\t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;    SListInsertAfter\n\tSListPushFront(&amp;plist, 1);\n\tSListPushFront(&amp;plist, 2);\n\tSListPushFront(&amp;plist, 3);\n\tSListPushFront(&amp;plist, 4);\n\tSListPushFront(&amp;plist, 5);\n\tSListPushFront(&amp;plist, 6);\n\tSListPrint(plist);\n\tSListInsertAfter(SListFind(plist, 1), 999999);\n\tSListPrint(plist);\n\tSListInsertAfter(SListFind(plist, 6), 999999);\n\tSListPrint(plist);\n\n\t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;      SListInsertBefore\n\tSListPushBack(&amp;plist, 1);\n\tSListPushBack(&amp;plist, 2);\n\tSListPushBack(&amp;plist, 3);\n\tSListPushBack(&amp;plist, 4);\n\tSListPushBack(&amp;plist, 5);\n\tSListPushBack(&amp;plist, 6);\n\tSListPrint(plist);\n\n\tSListInsertBefore(&amp;plist, SListFind(plist, 6), 999999);\n\tSListPrint(plist);\n\tSListInsertBefore(&amp;plist, SListFind(plist, 1), 999999);\n\tSListPrint(plist);\n\n\t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;       SListEraseAfter\n\tSListPushBack(&amp;plist, 1);\n\tSListPushBack(&amp;plist, 2);\n\tSListPushBack(&amp;plist, 3);\n\tSListPushBack(&amp;plist, 4);\n\tSListPushBack(&amp;plist, 5);\n\tSListPushBack(&amp;plist, 6);\n\tSListPrint(plist);\n\n\tSListEraseAfter(SListFind(plist, 1));\n\tSListPrint(plist);\n\tSListEraseAfter(SListFind(plist, 3));\n\tSListPrint(plist);\n\tSListEraseAfter(SListFind(plist, 5));\n\tSListPrint(plist);\n\t&#x2F;&#x2F; 传递最后一个节点位置会出问题\n\t&#x2F;&#x2F;SListEraseAfter(SListFind(plist, 5));\n\t&#x2F;&#x2F;SListPrint(plist);\n\n\t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;        SListErasePos\n\tSListPushBack(&amp;plist, 1);\n\tSListPushBack(&amp;plist, 2);\n\tSListPushBack(&amp;plist, 3);\n\tSListPushBack(&amp;plist, 4);\n\tSListPushBack(&amp;plist, 5);\n\tSListPushBack(&amp;plist, 6);\n\tSListPrint(plist);\n\n\tSListErasePos(&amp;plist, SListFind(plist, 1));\n\tSListPrint(plist);\n\tSListErasePos(&amp;plist, SListFind(plist, 6));\n\tSListPrint(plist);\n\tSListErasePos(&amp;plist, SListFind(plist, 2));\n\tSListPrint(plist);\n\tSListErasePos(&amp;plist, SListFind(plist, 3));\n\tSListPrint(plist);\n\tSListErasePos(&amp;plist, SListFind(plist, 4));\n\tSListPrint(plist);\n\tSListErasePos(&amp;plist, SListFind(plist, 5));\n\tSListPrint(plist);\n\n\t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;       SListEraseBefore\n\tSListPushBack(&amp;plist, 1);\n\tSListPushBack(&amp;plist, 2);\n\tSListPushBack(&amp;plist, 3);\n\tSListPushBack(&amp;plist, 4);\n\tSListPushBack(&amp;plist, 5);\n\tSListPushBack(&amp;plist, 6);\n\tSListPrint(plist);\n\n\tSListEraseBefore(&amp;plist, SListFind(plist, 6));\n\tSListPrint(plist);\n\tSListEraseBefore(&amp;plist, SListFind(plist, 6));\n\tSListPrint(plist);\n\tSListEraseBefore(&amp;plist, SListFind(plist, 6));\n\tSListPrint(plist);\n\tSListEraseBefore(&amp;plist, SListFind(plist, 6));\n\tSListPrint(plist);\n\t&#x2F;&#x2F;&#x2F;&#x2F; 不能传第一个节点的位置\n\t&#x2F;&#x2F;SListEraseBefore(&amp;plist, SListFind(plist, 1));\n\t&#x2F;&#x2F;SListPrint(plist);\n\tSListEraseBefore(&amp;plist, SListFind(plist, 6));\n\tSListPrint(plist);\n\n\tSListDestroy(&amp;plist);\n&#125;\n\nint main()\n&#123;\n\t&#x2F;&#x2F;TestList1();\n\t&#x2F;&#x2F;TestList2();\n\t&#x2F;&#x2F;TestList3();\n\tTestList4();\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><font color=red size=4><strong>对于单链表来说，其难度主要在于对指针的运用，能够自我实现单链表，对我们代码能力的提升有很大的帮助。当然，在后续的一些数据结构的学习当中，单链表的一些思想是能用上的。</strong></font></p></blockquote>\n<p><font color=blue size=4><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></font></p>\n","feature":true,"text":" 前言 在学习数据结构时，单链表可谓是第一个需要跨越的台阶。 从C语言到数据结构，单链表能够真正的反映我们C语言到底学的扎不扎实，那是因为，单链表对于C语言中的指针，结构体，以及函数模块的实现有较高的要求。因此，通过本章的学习，要是能够自我实现单链表，那你的C语言功底会厚实，你的...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"21 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">单链表与顺序表的比较</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%9D%E5%A7%8B%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">单链表初始操作</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">得到一个节点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0\"><span class=\"toc-text\">单链表的打印</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81\"><span class=\"toc-text\">单链表的销毁</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92\"><span class=\"toc-text\">单链表的尾插</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92\"><span class=\"toc-text\">单链表的头插</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E5%88%A0\"><span class=\"toc-text\">单链表的尾删</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E5%88%A0\"><span class=\"toc-text\">单链表的头删</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">单链表的查找</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%AE%E6%94%B9\"><span class=\"toc-text\">单链表节点数据的修改</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">单链表在pos位置之后插入节点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">单链表在pos位置之前插入节点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E7%9A%84%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">单链表删除pos位置之后的节点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E7%9A%84%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">单链表删除pos位置之前的节点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">单链表删除pos位置的节点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">整体代码</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"【基础算法】单链表的OJ练习(1)","uid":"7ca2e84fccf5532a68e25ef3af8a8b80","slug":"【基础算法】单链表的OJ练习-1-反转链表-合并两个有序链表","date":"2023-03-03T15:53:46.000Z","updated":"2023-03-03T15:57:14.395Z","comments":true,"path":"api/articles/【基础算法】单链表的OJ练习-1-反转链表-合并两个有序链表.json","keywords":null,"cover":"/photo/R-C (4).jpeg","text":"前言 上一章讲解了单链表 &#x3D;&#x3D;-&gt;&#x3D;&#x3D; 传送门 &#x3D;&#x3D;&lt;-&#x3D;&#x3D; ，后面几章就对单链表进行一些简单的题目练习，目的是为了更好的理解单链表的实现以及加深对某些函数接口的熟练度。 本章带来了两个题...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"【数据结构】顺序表","uid":"acb938686160e729bc4dce5cef8311df","slug":"【数据结构】顺序表","date":"2023-03-03T15:53:00.000Z","updated":"2023-03-03T15:55:09.846Z","comments":true,"path":"api/articles/【数据结构】顺序表.json","keywords":null,"cover":"/photo/屏幕截图_20230122_043538.png","text":"前言 顺序表作为数据结构中的小小弟，还是很好应付的。说到数据结构，顺序表是我们的向导，它让你明白数据结构到底是干啥的，为啥数据结构这么的重要。 实际上，通讯录的底层就是一个顺序表，里面的增添联系人，删除联系人等一系列操作，都是基于顺序表实现的，这也侧面拖出了数据结构的作用。所以，...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":null}}