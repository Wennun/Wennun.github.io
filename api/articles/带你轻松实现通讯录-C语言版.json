{"title":"带你轻松实现通讯录(C语言版)","uid":"d8d9f05eeb5cca634b8a4aa98273e85e","slug":"带你轻松实现通讯录-C语言版","date":"2023-03-03T15:50:40.000Z","updated":"2023-03-03T15:54:23.002Z","comments":true,"path":"api/articles/带你轻松实现通讯录-C语言版.json","keywords":null,"cover":"/photo/屏幕截图_20230218_121115.png","content":"<hr>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>学习&#x3D;&#x3D;C语言&#x3D;&#x3D;的小伙伴，相信都要经历实现通讯录这一关吧，接下来就带你手把手实现自己的通讯录！</strong></p></blockquote>\n<hr>\n<h1 id=\"通讯录初始化\"><a href=\"#通讯录初始化\" class=\"headerlink\" title=\"通讯录初始化\"></a>通讯录初始化</h1><ul>\n<li><p>整个程序我们需要分三个文件，一个是头文件：<code>Contacts.h：</code>用来存放宏，结构体以及函数声明，还有需要用的库函数。一个是<code>Contacts.c：</code>用来实现各个接口函数的功能，还有一个是<code>test.c:</code>用来布局功能的框架以及测试代码。 </p>\n</li>\n<li><p>首先我们需要两个结构体，一个表示联系人的信息，一个为通讯录的信息：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct PeoInfo\n&#123;\n\tchar name[NAME_MAX];   &#x2F;&#x2F; 名字\n\tint age;               &#x2F;&#x2F; 年龄\n\tchar sex[SEX_MAX];     &#x2F;&#x2F; 性别\n\tchar adds[ADDS_MAX];   &#x2F;&#x2F; 地址\n\tchar tele[TELE_MAX];   &#x2F;&#x2F; 电话\n&#125;Info;\n\ntypedef struct contact\n&#123;\n\tInfo* data;    &#x2F;&#x2F; data 为Info指针\n\tint size;      &#x2F;&#x2F; 存放联系人的个数\n\tint capacity;  &#x2F;&#x2F; 存放联系人的空间容量\n&#125;Con;</code></pre>\n\n<p>上面类似于<code>NAME_MAX</code>的东西为宏定义，表示一个联系人的名字最多占多少空间,下面为所有的宏定义：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define NAME_MAX 20  &#x2F;&#x2F; 名字的最大长度\n#define SEX_MAX 5  &#x2F;&#x2F; 性别的最大长度\n#define ADDS_MAX 20  &#x2F;&#x2F; 地址的最大长度 \n#define TELE_MAX 12  &#x2F;&#x2F; 电话号码的最大长度\n#define NEW_SIZE 4 &#x2F;&#x2F; 每次扩容增加的容量</code></pre>\n\n\n<ul>\n<li><p>对于初始化由于需要插入数据，牵扯到一个扩容的问题，所以我们先开几个空间，到时候满了再动态扩容，开空间使用<code>malloc</code>和<code>calloc</code>都可以，区别只在于一个没初始化，一个全部初始化<code>0</code>。</p>\n</li>\n<li><p>并且初始的<code>size</code>要为<code>0</code>，而<code>capacity</code>则为初始开辟的空间的大小<code>INIT_CAPACITY</code>,具体初始化代码如下：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 初始化\nvoid ConInit(Con* pc)\n&#123;\n\t&#x2F;&#x2F; 用calloc开辟空间，空间里的数据初始化为0\n\t&#x2F;&#x2F; 先开辟 NEW_SIZE 个 ， 后面会使用realloc动态增容\n\tInfo* tmp &#x3D; (Info*)calloc(NEW_SIZE, sizeof(Info));\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;calloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\tpc-&gt;data &#x3D; tmp;\n\tpc-&gt;size &#x3D; 0;\n\tpc-&gt;capacity &#x3D; NEW_SIZE;\n\n\t&#x2F;&#x2F; 拿之前保存的数据\n\tGetConData(pc);\n&#125;</code></pre>\n\n\n<p>当然<code>GetConData(pc)</code>这一步可以先不看，所以这整个代码就是对通讯录的一个初始化过程。</p>\n<ul>\n<li>宏定义，与结构体都是定义再在<code>Contacts.h</code>头文件当中，除此之外，还有各个函数的接口的声明，所以整个头文件的代码段如下：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define NAME_MAX 20  &#x2F;&#x2F; 名字的最大长度\n#define SEX_MAX 5  &#x2F;&#x2F; 性别的最大长度\n#define ADDS_MAX 20  &#x2F;&#x2F; 地址的最大长度 \n#define TELE_MAX 12  &#x2F;&#x2F; 电话号码的最大长度\n#define NEW_SIZE 4 &#x2F;&#x2F; 每次扩容增加的容量\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct PeoInfo\n&#123;\n\tchar name[NAME_MAX];   &#x2F;&#x2F; 名字\n\tint age;               &#x2F;&#x2F; 年龄\n\tchar sex[SEX_MAX];     &#x2F;&#x2F; 性别\n\tchar adds[ADDS_MAX];   &#x2F;&#x2F; 地址\n\tchar tele[TELE_MAX];   &#x2F;&#x2F; 电话\n&#125;Info;\n\ntypedef struct contact\n&#123;\n\tInfo* data;    \n\tint size;      &#x2F;&#x2F; 存放联系人的个数\n\tint capacity;  &#x2F;&#x2F; 存放联系人的空间容量\n&#125;Con;\n\n&#x2F;&#x2F; 初始化\nvoid ConInit(Con* pc);\n&#x2F;&#x2F; 初始化但是不拿之前的数据，销毁当中用\nvoid ConInitNoInfo(Con* pc);\n\n&#x2F;&#x2F; 展示通讯录\nvoid ConShow(Con* pc);\n\n&#x2F;&#x2F; 添加联系人\nvoid ConAdd(Con* pc);\n\n&#x2F;&#x2F; 删除联系人\nvoid ConDel(Con* pc);\n\n&#x2F;&#x2F; 查找联系人\nvoid ConFind(Con* pc);\n\n&#x2F;&#x2F; 修改联系人的信息\nvoid ConModify(Con* pc);\n\n&#x2F;&#x2F; 此时通讯录里联系人的个数\nint ConSize(Con* pc);\n\n&#x2F;&#x2F; 销毁通讯录\nvoid ConDestory(Con* pc);\n\n&#x2F;&#x2F; 排序\nvoid ConSort(Con* pc);\n\n&#x2F;&#x2F; 保存通讯录\nvoid SaveContact(Con* pc);\n\n&#x2F;&#x2F; 拿之前保存的通讯录数据\nvoid GetConData(Con* pc);</code></pre>\n\n\n\n<hr>\n<h1 id=\"通讯录运行的基本框架和菜单\"><a href=\"#通讯录运行的基本框架和菜单\" class=\"headerlink\" title=\"通讯录运行的基本框架和菜单\"></a>通讯录运行的基本框架和菜单</h1><ul>\n<li><p>有了头文件的接口，这里我们设计一个菜单，以便于我们在进行操作的时候以输入数字的方式就可以完成操作，这样很是方便。</p>\n</li>\n<li><p>首先，我们可以先通过枚举 &#x3D;&#x3D;（提高代码可读性）&#x3D;&#x3D; 来规定每一个接口运行的代号数字，整个定义如下：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">enum select\n&#123;\n\tEXIT, &#x2F;&#x2F; 0 退出\n\tADD, &#x2F;&#x2F; 1 增加\n\tDEL, &#x2F;&#x2F; 2 删除\n\tFIND, &#x2F;&#x2F; 3 查找\n\tMODIFY, &#x2F;&#x2F; 4 修改\n\tSORT, &#x2F;&#x2F; 5 排序\n\tSHOW, &#x2F;&#x2F; 6 展示通讯录\n\tCLEAR, &#x2F;&#x2F; 7 清屏\n\tCONSIZE, &#x2F;&#x2F; 8 通讯录联系人个数\n\tDESTORY &#x2F;&#x2F; 9 销毁通讯录（要释放）\n&#125;;</code></pre>\n\n<p>根据此枚举的名字以及对应的数字，我们可以设计这样的一个菜单：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void menu()\n&#123;\n\tprintf(&quot;***********************************************\\n&quot;);\n\tprintf(&quot;**********      1.add     2.del      **********\\n&quot;);\n\tprintf(&quot;**********      3.find    4.modify   **********\\n&quot;);\n\tprintf(&quot;**********      5.sort    6.show     **********\\n&quot;);\n\tprintf(&quot;**********      7.clear   8.ConSize  **********\\n&quot;);\n\tprintf(&quot;**********      9.destory 0.exit     **********\\n&quot;);\n\tprintf(&quot;***********************************************\\n&quot;);\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/9ff71e46ad4f4bd0b01fe2b0aad2570b.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>然后在<code>main</code>函数中使用<code>do while</code>循环来控制整个程序的运行，在<code>do while</code> 循环里使用<code>switch case</code>分支语句来控制接口的选项，这样整个框架就差不多了。下面是<code>test.c</code>文件对整个程序框架建立的代码：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;Contacts.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;***********************************************\\n&quot;);\n\tprintf(&quot;**********      1.add     2.del      **********\\n&quot;);\n\tprintf(&quot;**********      3.find    4.modify   **********\\n&quot;);\n\tprintf(&quot;**********      5.sort    6.show     **********\\n&quot;);\n\tprintf(&quot;**********      7.clear   8.ConSize  **********\\n&quot;);\n\tprintf(&quot;**********      9.destory 0.exit     **********\\n&quot;);\n\tprintf(&quot;***********************************************\\n&quot;);\n&#125;\n\nenum select\n&#123;\n\tEXIT, &#x2F;&#x2F; 0 退出\n\tADD, &#x2F;&#x2F; 1 增加\n\tDEL, &#x2F;&#x2F; 2 删除\n\tFIND, &#x2F;&#x2F; 3 查找\n\tMODIFY, &#x2F;&#x2F; 4 修改\n\tSORT, &#x2F;&#x2F; 5 排序\n\tSHOW, &#x2F;&#x2F; 6 展示通讯录\n\tCLEAR, &#x2F;&#x2F; 7 清屏\n\tCONSIZE, &#x2F;&#x2F; 8 通讯录联系人个数\n\tDESTORY &#x2F;&#x2F; 9 销毁通讯录（要释放）\n&#125;;\n\t\nint main()\n&#123;\n\tint input &#x3D; 0;\n\tCon con;\n\tConInit(&amp;con);\n\n\tdo\n\t&#123;\n\t    &#x2F;&#x2F; 每次根据菜单进行选择\n\t\tmenu();\n\t\tprintf(&quot;请选择：&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase EXIT: &#x2F;&#x2F; 0\n\t\t\tSaveContact(&amp;con);\n\t\t\tprintf(&quot;退出程序&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tcase ADD:  &#x2F;&#x2F; 1\n\t\t\tConAdd(&amp;con);\n\t\t\tbreak;\n\t\tcase DEL:  &#x2F;&#x2F; 2\n\t\t\tConDel(&amp;con);\n\t\t\tbreak;\n\t\tcase FIND:  &#x2F;&#x2F; 3\n\t\t\tConFind(&amp;con);\n\t\t\tbreak;\n\t\tcase MODIFY: &#x2F;&#x2F; 4\n\t\t\tConModify(&amp;con);\n\t\t\tbreak;\n\t\tcase SORT: &#x2F;&#x2F; 5\n\t\t\tConSort(&amp;con);\n\t\t\tbreak;\n\t\tcase SHOW: &#x2F;&#x2F; 6\n\t\t\tConShow(&amp;con);\n\t\t\tbreak;\n\t\tcase CLEAR: &#x2F;&#x2F; 7\n\t\t\tsystem(&quot;cls&quot;);\n\t\t\tbreak;\n\t\tcase CONSIZE:  &#x2F;&#x2F; 8\n\t\t\tprintf(&quot;现在通讯录里联系人的个数为：%d\\n&quot;, ConSize(&amp;con));\n\t\t\tbreak;\n\t\tcase DESTORY: &#x2F;&#x2F; 9\n\t\t\tConDestory(&amp;con);\n\n\t\t\tint n &#x3D; 0;\n\t\t\tprintf(&quot;是否需要重新初始化通讯录？\\n1.YES : 0.NO &gt;&gt;&gt; &quot;);\n\t\t\tscanf(&quot;%d&quot;, &amp;n);\n\n\t\t\tif (n)\n\t\t\t&#123;\n\t\t\t\tConInit(&amp;con);\n\t\t\t\tprintf(&quot;重新初始化成功&gt;\\n&quot;);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tinput &#x3D; 0;\n\t\t\t\tprintf(&quot;通讯录进程关闭，退出程序&gt;&gt;&gt;&gt;&gt;&gt; \\n&quot;);\n\t\t\t&#125;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误，请重新选择&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<p><strong>有了这样的框架来控制整个程序的运行，接下来，就是对每一个接口的功能的实现了。</strong></p>\n<hr>\n<h1 id=\"增添联系人\"><a href=\"#增添联系人\" class=\"headerlink\" title=\"增添联系人\"></a>增添联系人</h1><ul>\n<li><p>有了前面的铺垫，第一步当然就是添加联系人了。</p>\n</li>\n<li><p>添加之前还要进行的操作是看是否需要扩容，因为如果空间添加满了，在添加就会出现越界非法访问的问题了，因此这里要写个扩容函数，使用的是<code>realloc</code>，判断条件是如果联系人个数<code>（size）</code>等于容量<code>（capacity）</code>，就增加容量。</p>\n</li>\n<li><p>添加联系人是在末尾添加，并且要依次输入该联系人的各个信息。</p>\n</li>\n</ul>\n<p><font color=red>添加联系人接口代码如下：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 添加联系人\nvoid ConAdd(Con* pc)\n&#123;\n\tassert(pc);\n\n\t&#x2F;&#x2F; 需判断容量够不够用，不够则需要扩容\n\tJud_Exp(pc);\n\n\tprintf(&quot;请输入联系人的姓名：&quot;);\n\tscanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].name);\n\tprintf(&quot;请输入联系人的年龄：&quot;);\n\tscanf(&quot;%d&quot;, &amp;pc-&gt;data[pc-&gt;size].age);\n\tprintf(&quot;请输入联系人的性别：&quot;);\n\tscanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].sex);\n\tprintf(&quot;请输入联系人的地址：&quot;);\n\tscanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].adds);\n\tprintf(&quot;请输入联系人的电话：&quot;);\n\tscanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].tele);\n\n\tpc-&gt;size++;\n\tprintf(&quot;添加成功&gt;\\n&quot;);\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"删除联系人\"><a href=\"#删除联系人\" class=\"headerlink\" title=\"删除联系人\"></a>删除联系人</h1><ul>\n<li><p>有添加就有删除，删除当然是要指定删除哪位联系人，因此需要输入要删除的联系人的名字，然后再根据名字在通讯录里面找到该联系人，将他删除。</p>\n</li>\n<li><p>删除的方式是通过挪动数组来实现的，以覆盖的形式，依次将后一个联系人数据往前挪动一位（很容易发现，这里的效率不是很高），起到删除的效果，当然最后<code>size</code>要减一表示联系人少了一位 。</p>\n</li>\n<li><p>在删除之前也要考虑通讯录里面是否有数据的情况，如果通讯录是空的，那也就没有删的必要了，这里采用<code>assert</code>断言直接暴力毒打。</p>\n</li>\n<li><p>如果要删除的联系人在通讯录里面没有找到与之对应的，这时就打印删除失败，程序继续运行。</p>\n</li>\n</ul>\n<p><strong>首先是输入要删除的联系人的名字，通过这个名字查找该联系人是否在通讯录里面存在，如果存在，则执行删除操作，不存在则打印删除失败程序继续运行。由于删除，查找，修改这些接口都要用到查找联系人这个函数，因此这里将这个函数单独抽离出来，实现如下：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 查找名字\n&#x2F;&#x2F; 删除，修改，查找都要用到此功能，因此单独抽离出来实现一个函数\nint Find_Name(Con* pc, char* name)\n&#123;\n\tassert(name);\n\n\tfor (int i &#x3D; 0; i &lt; pc-&gt;size; i++)\n\t&#123;\n\t\tif (!strcmp(name, pc-&gt;data[i].name))\n\t\t\treturn i;  &#x2F;&#x2F; 返回找到的名字的下标\n\t&#125;\n\n\t&#x2F;&#x2F; 没有找到则返回-1\n\treturn -1;\n&#125;</code></pre>\n\n<p><font color=red><strong>那么整个删除联系人的接口的实现就很清楚了：</strong></font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 删除联系人\nvoid ConDel(Con* pc)\n&#123;\n\tassert(pc &amp;&amp; pc-&gt;size &gt; 0);\n\n\tchar name[NAME_MAX];\n\tprintf(&quot;请输入要删除的联系人信息的名字&gt; &quot;);\n\tscanf(&quot;%s&quot;, name);\n\n\tint pos &#x3D; Find_Name(pc, name);\n\tif (pos !&#x3D; -1)\n\t&#123;\n\t\tfor (int i &#x3D; pos; i &lt; pc-&gt;size - 1; i++)\n\t\t&#123;\n\t\t\tpc-&gt;data[i] &#x3D; pc-&gt;data[i + 1];\n\t\t&#125;\n\n\t\tpc-&gt;size--;\n\t\tprintf(&quot;删除成功&gt;\\n&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;要删除的联系人不存在&gt;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"查找联系人\"><a href=\"#查找联系人\" class=\"headerlink\" title=\"查找联系人\"></a>查找联系人</h1><ul>\n<li>查找联系人需要输入你要查找的联系人的名字，前面已经将查找的函数写了，这里只需要通过查找函数的返回值来判断是否找到即可，找到了就将其打印，没有则打印没找到。</li>\n</ul>\n<p><font color=red><strong>函数接口实现：</strong></font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 查找联系人\nvoid ConFind(Con* pc)\n&#123;\n\tassert(pc &amp;&amp; pc-&gt;size &gt; 0);\n\n\tchar name[NAME_MAX];\n\tprintf(&quot;请输入想要查找联系人的名字&gt; &quot;);\n\tscanf(&quot;%s&quot;, name);\n\n\tint pos &#x3D; Find_Name(pc, name);\n\n\tif (pos !&#x3D; -1)\n\t&#123;\n\t\tprintf(&quot;%-20s\\t%-4d\\t%-5s\\t%-20s\\t%-12s\\n&quot;, pc-&gt;data[pos].name,\n\t\t\tpc-&gt;data[pos].age,\n\t\t\tpc-&gt;data[pos].sex,\n\t\t\tpc-&gt;data[pos].adds,\n\t\t\tpc-&gt;data[pos].tele);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;没有找到此联系人&gt;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"修改联系人信息\"><a href=\"#修改联系人信息\" class=\"headerlink\" title=\"修改联系人信息\"></a>修改联系人信息</h1><ul>\n<li>有了前面的铺垫，要修改，那还不简单，直接输入要修改的联系人的名字，然后重新输入一遍到这个位置，就ok啦。直接上代码，相信大家一看就懂。</li>\n</ul>\n<p><font color=red><strong>函数接口实现：</strong></font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 修改联系人的信息\nvoid ConModify(Con* pc)\n&#123;\n\tassert(pc &amp;&amp; pc-&gt;size &gt; 0);\n\n\tchar name[NAME_MAX];\n\tprintf(&quot;请输入要修改的联系人的信息的名字&gt; &quot;);\n\tscanf(&quot;%s&quot;, name);\n\n\t&#x2F;&#x2F; 查找要修改的联系人所在通讯录里的位置\n\tint pos &#x3D; Find_Name(pc, name);\n\n\tif (pos !&#x3D; -1)\n\t&#123;\n\t\tprintf(&quot;请修改&gt;\\n&quot;);\n\n\t\tprintf(&quot;请输入联系人的姓名：&quot;);\n\t\tscanf(&quot;%s&quot;, pc-&gt;data[pos].name);\n\t\tprintf(&quot;请输入联系人的年龄：&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;pc-&gt;data[pos].age);\n\t\tprintf(&quot;请输入联系人的性别：&quot;);\n\t\tscanf(&quot;%s&quot;, pc-&gt;data[pos].sex);\n\t\tprintf(&quot;请输入联系人的地址：&quot;);\n\t\tscanf(&quot;%s&quot;, pc-&gt;data[pos].adds);\n\t\tprintf(&quot;请输入联系人的电话：&quot;);\n\t\tscanf(&quot;%s&quot;, pc-&gt;data[pos].tele);\n\n\t\tprintf(&quot;修改成功&gt;\\n&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;要修改信息的联系人不存在&gt;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"展示通讯录\"><a href=\"#展示通讯录\" class=\"headerlink\" title=\"展示通讯录\"></a>展示通讯录</h1><ul>\n<li><p>展示通讯录就不用多说了吧，直接上代码！</p>\n<p><font color=red><strong>函数接口实现：</strong></font></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 展示通讯录\nvoid ConShow(Con* pc)\n&#123;\n\tassert(pc);\n\n\tif (!pc-&gt;size)\n\t&#123;\n\t\tprintf(&quot;通讯录为空&gt;\\n&quot;);\n\t\treturn;\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;%-20s\\t%-4s\\t%-5s\\t%-20s\\t%-12s\\n&quot;, &quot;名字&quot;, &quot;年龄&quot;, &quot;性别&quot;, &quot;地址&quot;, &quot;电话&quot;);\n\t\tfor (int i &#x3D; 0; i &lt; pc-&gt;size; i++)\n\t\t&#123;\n\t\t\tprintf(&quot;%-20s\\t%-4d\\t%-5s\\t%-20s\\t%-12s\\n&quot;, pc-&gt;data[i].name,\n\t\t\t\tpc-&gt;data[i].age,\n\t\t\t\tpc-&gt;data[i].sex,\n\t\t\t\tpc-&gt;data[i].adds,\n\t\t\t\tpc-&gt;data[i].tele);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"通讯录联系人个数\"><a href=\"#通讯录联系人个数\" class=\"headerlink\" title=\"通讯录联系人个数\"></a>通讯录联系人个数</h1><p>直接上代码！</p>\n<p>  <font color=red><strong>函数接口实现：</strong></font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 此时通讯录里联系人的个数\nint ConSize(Con* pc)\n&#123;\n\tassert(pc);\n\n\treturn pc-&gt;size;\n&#125;</code></pre>\n\n\n\n<hr>\n<h1 id=\"排序通讯录\"><a href=\"#排序通讯录\" class=\"headerlink\" title=\"排序通讯录\"></a>排序通讯录</h1><ul>\n<li><p>排序通讯录这里稍微麻烦一些，我们可以直接用库函数里的<code>qsort</code>来进行排序，这时我们只需要按自己的需求，写出对应的<code>cmp</code>函数即可。例如按年龄排序，年龄排序又分两种，升序和降序。或者按名字排序，通过比较ASCLL码值来进行排序，也分为升序和降序，不过要注意的是，名字是字符串，需要使用<code>strcmp函数</code>来进行比较。</p>\n</li>\n<li><p>这里我们自己实现一个排序接口来对通讯录进行排序，底层为冒泡排序模板（哈哈哈哈效率低了）。由于是对一个个结构体进行排序，所以在排序的时候，交换数据需要一个字节一个字节的交换。</p>\n</li>\n</ul>\n<p><strong>下面是自我实现的排序代码：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 交换的时候一个字节一个字节的换，因为不知道排序的是什么类型的数据\nvoid swap(char* buf1, char* buf2, size_t width)\n&#123;\n\tassert(buf1 &amp;&amp; buf2);\n\n\twhile (width--)\n\t&#123;\n\t\tchar tmp &#x3D; *buf1;\n\t\t*buf1 &#x3D; *buf2;\n\t\t*buf2 &#x3D; tmp;\n\t\tbuf1++;\n\t\tbuf2++;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 排序， 以冒泡排序为框架\nvoid Bubble_Sort(void* bese, size_t num, size_t width, int (*cmp)(const void*, const void*))\n&#123;\n\tassert(bese);\n\n\tfor (size_t i &#x3D; 0; i &lt; num - 1; ++i)\n\t&#123;\n\t\tfor (size_t j &#x3D; 0; j &lt; num - 1 - i; ++j)\n\t\t&#123;\n\t\t\tif (cmp((char*)bese + j * width, (char*)bese + (j + 1) * width) &gt; 0)\n\t\t\t&#123;\n\t\t\t\tswap((char*)bese + j * width, (char*)bese + (j + 1) * width, width);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<ul>\n<li>有了这个排序，可以根据自己的需求来写<code>cmp</code>函数，若以名字和年龄排序，那么一共有四种情况，下面是对应四种情况的代码：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 按名字从小到大排序\nint cmp_con_name1(const void* a, const void* b)\n&#123;\n\treturn strcmp(((Info*)a)-&gt;name, ((Info*)b)-&gt;name);\n&#125;\n&#x2F;&#x2F; 按名字从大到小排序\nint cmp_con_name2(const void* a, const void* b)\n&#123;\n\treturn strcmp(((Info*)b)-&gt;name, ((Info*)a)-&gt;name);\n&#125;\n\n&#x2F;&#x2F; 按年龄从小到大排序\nint cmp_con_age1(const void* a, const void* b)\n&#123;\n\treturn ((Info*)a)-&gt;age - ((Info*)b)-&gt;age;\n&#125;\n\n&#x2F;&#x2F; 按年龄从大到小排序\nint cmp_con_age2(const void* a, const void* b)\n&#123;\n\treturn ((Info*)b)-&gt;age - ((Info*)a)-&gt;age;\n&#125;</code></pre>\n\n\n\n<ul>\n<li>排序代码ok后，接下来就是对排序的选择进行一个梳理与排版，以下是该该功能的接口函数的代码实现：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 排序\nvoid ConSort(Con* pc)\n&#123;\n\tassert(pc);\n\n\tprintf(&quot;请选择何种方式排序：\\n&quot;);\n\tprintf(&quot;1.按名字排序：\\n2.按年龄排序：\\n&quot;);\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tif (n !&#x3D; 1 &amp;&amp; n !&#x3D; 2)\n\t&#123;\n\t\tprintf(&quot;选择错误,退出排序&gt;\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tif (n &#x3D;&#x3D; 1)\n\t&#123;\n\t\tint k &#x3D; 0;\n\t\tprintf(&quot;请选择如何排序：\\n&quot;);\n\t\tprintf(&quot;1.升序\\n2.降序\\n&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;k);\n\n\t\tif (k &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_name1);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse if (k &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_name2);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;选择错误&gt;\\n&quot;);\n\t\t&#125;\n\n\t&#125;\n\telse if (n &#x3D;&#x3D; 2)\n\t&#123;\n\t\tint k &#x3D; 0;\n\t\tprintf(&quot;请选择如何排序：\\n&quot;);\n\t\tprintf(&quot;1.升序\\n2.降序\\n&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;k);\n\n\t\tif (k &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_age1);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse if (k &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_age2);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;选择错误&gt;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p><font color=red>这里测试一下：</font></p>\n<p>一开始通讯录列表为：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8b00340a62a84647a6a4459ef168aa17.png\" alt=\"在这里插入图片描述\"><br>我们按年龄从小到大排序为：<br><img src=\"https://img-blog.csdnimg.cn/62ea00268eb944c6bd5a6164635cc8d3.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/302e53fdab89428c9e3d7fe0f1a65120.png\" alt=\"在这里插入图片描述\"><br>可以看到，此时的确排序成功！</p>\n<p><font color=red size=4><strong>整体的函数接口实现为：</strong></font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 按名字从小到大排序\nint cmp_con_name1(const void* a, const void* b)\n&#123;\n\treturn strcmp(((Info*)a)-&gt;name, ((Info*)b)-&gt;name);\n&#125;\n&#x2F;&#x2F; 按名字从大到小排序\nint cmp_con_name2(const void* a, const void* b)\n&#123;\n\treturn strcmp(((Info*)b)-&gt;name, ((Info*)a)-&gt;name);\n&#125;\n\n&#x2F;&#x2F; 按年龄从小到大排序\nint cmp_con_age1(const void* a, const void* b)\n&#123;\n\treturn ((Info*)a)-&gt;age - ((Info*)b)-&gt;age;\n&#125;\n\n&#x2F;&#x2F; 按年龄从大到小排序\nint cmp_con_age2(const void* a, const void* b)\n&#123;\n\treturn ((Info*)b)-&gt;age - ((Info*)a)-&gt;age;\n&#125;\n\n&#x2F;&#x2F; 交换的时候一个字节一个字节的换，因为不知道排序的是什么类型的数据\nvoid swap(char* buf1, char* buf2, size_t width)\n&#123;\n\tassert(buf1 &amp;&amp; buf2);\n\n\twhile (width--)\n\t&#123;\n\t\tchar tmp &#x3D; *buf1;\n\t\t*buf1 &#x3D; *buf2;\n\t\t*buf2 &#x3D; tmp;\n\t\tbuf1++;\n\t\tbuf2++;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 排序， 以冒泡排序为框架\nvoid Bubble_Sort(void* bese, size_t num, size_t width, int (*cmp)(const void*, const void*))\n&#123;\n\tassert(bese);\n\n\tfor (size_t i &#x3D; 0; i &lt; num - 1; ++i)\n\t&#123;\n\t\tfor (size_t j &#x3D; 0; j &lt; num - 1 - i; ++j)\n\t\t&#123;\n\t\t\tif (cmp((char*)bese + j * width, (char*)bese + (j + 1) * width) &gt; 0)\n\t\t\t&#123;\n\t\t\t\tswap((char*)bese + j * width, (char*)bese + (j + 1) * width, width);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 排序\nvoid ConSort(Con* pc)\n&#123;\n\tassert(pc);\n\n\tprintf(&quot;请选择何种方式排序：\\n&quot;);\n\tprintf(&quot;1.按名字排序：\\n2.按年龄排序：\\n&quot;);\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tif (n !&#x3D; 1 &amp;&amp; n !&#x3D; 2)\n\t&#123;\n\t\tprintf(&quot;选择错误,退出排序&gt;\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tif (n &#x3D;&#x3D; 1)\n\t&#123;\n\t\tint k &#x3D; 0;\n\t\tprintf(&quot;请选择如何排序：\\n&quot;);\n\t\tprintf(&quot;1.升序\\n2.降序\\n&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;k);\n\n\t\tif (k &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_name1);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse if (k &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_name2);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;选择错误&gt;\\n&quot;);\n\t\t&#125;\n\n\t&#125;\n\telse if (n &#x3D;&#x3D; 2)\n\t&#123;\n\t\tint k &#x3D; 0;\n\t\tprintf(&quot;请选择如何排序：\\n&quot;);\n\t\tprintf(&quot;1.升序\\n2.降序\\n&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;k);\n\n\t\tif (k &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_age1);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse if (k &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_age2);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;选择错误&gt;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n\n\n<hr>\n<h1 id=\"文件操作储存通讯录信息\"><a href=\"#文件操作储存通讯录信息\" class=\"headerlink\" title=\"文件操作储存通讯录信息\"></a>文件操作储存通讯录信息</h1><ul>\n<li><p>对文件操作不熟悉的同志可以先看下这篇博客：<a href=\"https://blog.csdn.net/Wennytime/article/details/128694528\">文件操作</a>。</p>\n</li>\n<li><p>文件操作就是将我们进行一系列操作最终定型的通讯录信息存放在文件当中，且下一次运行程序时，可以将信息从文件拿出来。</p>\n</li>\n<li><p>一共有两个步骤：&#x3D;&#x3D;存和取&#x3D;&#x3D;  ，以二进制方式存，以二进制方式取。</p>\n</li>\n<li><p>存的时候可以在退出程序的那最后一步自动存，也可以多设置一个选项随时存。</p>\n</li>\n<li><p>取的时候在通讯录初始化的时候就自动去文件中寻找信息并取。</p>\n</li>\n</ul>\n<p><font color=red size=4><strong>分别的函数接口实现为：</strong></font></p>\n<p><font color=blue size=4><strong>存：</strong></font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 保存通讯录\nvoid SaveContact(Con* pc)\n&#123;\n\tassert(pc);\n\n\t&#x2F;&#x2F; 将信息以二进制形式保存在Contacts.txt文本文档中\n\tFILE* pf &#x3D; fopen(&quot;Contact.txt&quot;, &quot;wb&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;Save Con fail&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; pc-&gt;size; i++)\n\t\t&#123;\n\t\t\tfwrite(pc-&gt;data + i, sizeof(Info), 1, pf);\n\t\t&#125;\n\n\t\tfclose(pf);\n\t\tpf &#x3D; NULL;\n\n\t\tprintf(&quot;保存通讯录数据成功&gt;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n\n\n<p><font color=blue size=4><strong>取：</strong></font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 拿之前保存的通讯录数据\nvoid GetConData(Con* pc)\n&#123;\n\tassert(pc);\n\n\tFILE* pf &#x3D; fopen(&quot;Contact.txt&quot;, &quot;rb&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;Get data fail&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tInfo tmp &#x3D; &#123; 0 &#125;;\n\n\t\tint i &#x3D; 0;\n\t\twhile (fread(&amp;tmp, sizeof(Info), 1, pf))\n\t\t&#123;\n\t\t\tJud_Exp(pc);        &#x2F;&#x2F; 判断是否要扩容\n\t\t\tpc-&gt;data[i] &#x3D; tmp;  &#x2F;&#x2F; 每拿一个联系人的信息就放入通讯录\n\t\t\tpc-&gt;size++;         &#x2F;&#x2F; 每get一个计数一次\n\t\t\ti++;                          \n\t\t&#125;\n\n\t\tfclose(pf);  &#x2F;&#x2F; get完后关闭文件\n\t\tpf &#x3D; NULL;\n\n\t\tprintf(&quot;获取之前的通讯录数据成功&gt;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"销毁通讯录\"><a href=\"#销毁通讯录\" class=\"headerlink\" title=\"销毁通讯录\"></a>销毁通讯录</h1><ul>\n<li><p>销毁通讯录相当于是将通讯录里面的信息全部清空，当然我们在销毁过后也可以选择是否初始化通讯录，如果不选则退出程序。</p>\n</li>\n<li><p>注意这里的初始化要单独写一个接口，实际上相当于复制一个，只不过说没有从文件中取数据的那一步（纯纯初始化）。</p>\n</li>\n</ul>\n<p><font color=red size=4><strong>函数接口代码实现：</strong></font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 销毁通讯录\nvoid ConDestory(Con* pc)\n&#123;\n\tassert(pc);\n\n\tfree(pc-&gt;data);\n\tpc-&gt;data &#x3D; NULL;\n\tpc-&gt;capacity &#x3D; 0;\n\tpc-&gt;size &#x3D; 0;\n\n\tprintf(&quot;销毁成功&gt;\\n&quot;);\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"整体代码\"><a href=\"#整体代码\" class=\"headerlink\" title=\"整体代码\"></a>整体代码</h1><h2 id=\"Contacts-h\"><a href=\"#Contacts-h\" class=\"headerlink\" title=\"Contacts.h\"></a>Contacts.h</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define NAME_MAX 20  &#x2F;&#x2F; 名字的最大长度\n#define SEX_MAX 5  &#x2F;&#x2F; 性别的最大长度\n#define ADDS_MAX 20  &#x2F;&#x2F; 地址的最大长度 \n#define TELE_MAX 12  &#x2F;&#x2F; 电话号码的最大长度\n#define NEW_SIZE 4 &#x2F;&#x2F; 每次扩容增加的容量\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct PeoInfo\n&#123;\n\tchar name[NAME_MAX];   &#x2F;&#x2F; 名字\n\tint age;               &#x2F;&#x2F; 年龄\n\tchar sex[SEX_MAX];     &#x2F;&#x2F; 性别\n\tchar adds[ADDS_MAX];   &#x2F;&#x2F; 地址\n\tchar tele[TELE_MAX];   &#x2F;&#x2F; 电话\n&#125;Info;\n\ntypedef struct contact\n&#123;\n\tInfo* data;    \n\tint size;      &#x2F;&#x2F; 存放联系人的个数\n\tint capacity;  &#x2F;&#x2F; 存放联系人的空间容量\n&#125;Con;\n\n&#x2F;&#x2F; 初始化\nvoid ConInit(Con* pc);\n&#x2F;&#x2F; 初始化但是不拿之前的数据\nvoid ConInitNoInfo(Con* pc);\n\n\n&#x2F;&#x2F; 展示通讯录\nvoid ConShow(Con* pc);\n\n&#x2F;&#x2F; 添加联系人\nvoid ConAdd(Con* pc);\n\n&#x2F;&#x2F; 删除联系人\nvoid ConDel(Con* pc);\n\n&#x2F;&#x2F; 查找联系人\nvoid ConFind(Con* pc);\n\n&#x2F;&#x2F; 修改联系人的信息\nvoid ConModify(Con* pc);\n\n&#x2F;&#x2F; 此时通讯录里联系人的个数\nint ConSize(Con* pc);\n\n&#x2F;&#x2F; 销毁通讯录\nvoid ConDestory(Con* pc);\n\n&#x2F;&#x2F; 排序\nvoid ConSort(Con* pc);\n\n&#x2F;&#x2F; 保存通讯录\nvoid SaveContact(Con* pc);\n\n&#x2F;&#x2F; 拿之前保存的通讯录数据\nvoid GetConData(Con* pc);</code></pre>\n\n\n\n\n<h2 id=\"Contacts-c\"><a href=\"#Contacts-c\" class=\"headerlink\" title=\"Contacts.c\"></a>Contacts.c</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;Contacts.h&quot;\n\n&#x2F;&#x2F; 初始化\nvoid ConInit(Con* pc)\n&#123;\n\t&#x2F;&#x2F; 用calloc开辟空间，空间里的数据初始化为0\n\t&#x2F;&#x2F; 先开辟 NEW_SIZE 个 ， 后面会使用realloc动态增容\n\tInfo* tmp &#x3D; (Info*)calloc(NEW_SIZE, sizeof(Info));\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;calloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\tpc-&gt;data &#x3D; tmp;\n\tpc-&gt;size &#x3D; 0;\n\tpc-&gt;capacity &#x3D; NEW_SIZE;\n\n\t&#x2F;&#x2F; 拿之前保存的数据\n\tGetConData(pc);\n&#125;\n\n&#x2F;&#x2F; 初始化但是不拿之前的数据\nvoid ConInitNoInfo(Con* pc)\n&#123;\n\t&#x2F;&#x2F; 用calloc开辟空间，空间里的数据初始化为0\n\t&#x2F;&#x2F; 先开辟 NEW_SIZE 个 ， 后面会使用realloc动态增容\n\tInfo* tmp &#x3D; (Info*)calloc(NEW_SIZE, sizeof(Info));\n\tif (tmp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;calloc fail&quot;);\n\t\texit(-1);\n\t&#125;\n\n\tpc-&gt;data &#x3D; tmp;\n\tpc-&gt;size &#x3D; 0;\n\tpc-&gt;capacity &#x3D; NEW_SIZE;\n&#125;\n\n&#x2F;&#x2F; 展示通讯录\nvoid ConShow(Con* pc)\n&#123;\n\tassert(pc);\n\n\tif (!pc-&gt;size)\n\t&#123;\n\t\tprintf(&quot;通讯录为空&gt;\\n&quot;);\n\t\treturn;\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;%-20s\\t%-4s\\t%-5s\\t%-20s\\t%-12s\\n&quot;, &quot;名字&quot;, &quot;年龄&quot;, &quot;性别&quot;, &quot;地址&quot;, &quot;电话&quot;);\n\t\tfor (int i &#x3D; 0; i &lt; pc-&gt;size; i++)\n\t\t&#123;\n\t\t\tprintf(&quot;%-20s\\t%-4d\\t%-5s\\t%-20s\\t%-12s\\n&quot;, pc-&gt;data[i].name,\n\t\t\t\tpc-&gt;data[i].age,\n\t\t\t\tpc-&gt;data[i].sex,\n\t\t\t\tpc-&gt;data[i].adds,\n\t\t\t\tpc-&gt;data[i].tele);\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 判断是否要扩容\nvoid Jud_Exp(Con* pc)\n&#123;\n\tif (pc-&gt;capacity &#x3D;&#x3D; pc-&gt;size)\n\t&#123;\n\t\tInfo* tmp &#x3D; realloc(pc-&gt;data, sizeof(Info) * (pc-&gt;capacity + NEW_SIZE));\n\t\tif (tmp &#x3D;&#x3D; NULL)\n\t\t&#123;\n\t\t\tperror(&quot;realloc fail&quot;);\n\t\t\texit(-1);\n\t\t&#125;\n\n\t\tpc-&gt;data &#x3D; tmp;\n\t\tpc-&gt;capacity &#x3D; pc-&gt;capacity + NEW_SIZE;\n\t\tprintf(&quot;增容成功&gt;\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 添加联系人\nvoid ConAdd(Con* pc)\n&#123;\n\tassert(pc);\n\n\t&#x2F;&#x2F; 需判断容量够不够用，不够则需要扩容\n\tJud_Exp(pc);\n\n\tprintf(&quot;请输入联系人的姓名：&quot;);\n\tscanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].name);\n\tprintf(&quot;请输入联系人的年龄：&quot;);\n\tscanf(&quot;%d&quot;, &amp;pc-&gt;data[pc-&gt;size].age);\n\tprintf(&quot;请输入联系人的性别：&quot;);\n\tscanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].sex);\n\tprintf(&quot;请输入联系人的地址：&quot;);\n\tscanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].adds);\n\tprintf(&quot;请输入联系人的电话：&quot;);\n\tscanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].tele);\n\n\tpc-&gt;size++;\n\tprintf(&quot;添加成功&gt;\\n&quot;);\n&#125;\n\n&#x2F;&#x2F; 查找名字\n&#x2F;&#x2F; 删除，修改，查找都要用到此功能，因此单独抽离出来实现一个函数\nint Find_Name(Con* pc, char* name)\n&#123;\n\tassert(name);\n\n\tfor (int i &#x3D; 0; i &lt; pc-&gt;size; i++)\n\t&#123;\n\t\tif (!strcmp(name, pc-&gt;data[i].name))\n\t\t\treturn i;  &#x2F;&#x2F; 返回找到的名字的下标\n\t&#125;\n\n\t&#x2F;&#x2F; 没有找到则返回-1\n\treturn -1;\n&#125;\n\n&#x2F;&#x2F; 删除联系人\nvoid ConDel(Con* pc)\n&#123;\n\tassert(pc &amp;&amp; pc-&gt;size &gt; 0);\n\n\tchar name[NAME_MAX];\n\tprintf(&quot;请输入要删除的联系人信息的名字&gt; &quot;);\n\tscanf(&quot;%s&quot;, name);\n\n\tint pos &#x3D; Find_Name(pc, name);\n\tif (pos !&#x3D; -1)\n\t&#123;\n\t\tfor (int i &#x3D; pos; i &lt; pc-&gt;size - 1; i++)\n\t\t&#123;\n\t\t\tpc-&gt;data[i] &#x3D; pc-&gt;data[i + 1];\n\t\t&#125;\n\n\t\tpc-&gt;size--;\n\t\tprintf(&quot;删除成功&gt;\\n&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;要删除的联系人不存在&gt;\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 查找联系人\nvoid ConFind(Con* pc)\n&#123;\n\tassert(pc &amp;&amp; pc-&gt;size &gt; 0);\n\n\tchar name[NAME_MAX];\n\tprintf(&quot;请输入想要查找联系人的名字&gt; &quot;);\n\tscanf(&quot;%s&quot;, name);\n\n\tint pos &#x3D; Find_Name(pc, name);\n\n\tif (pos !&#x3D; -1)\n\t&#123;\n\t\tprintf(&quot;%-20s\\t%-4d\\t%-5s\\t%-20s\\t%-12s\\n&quot;, pc-&gt;data[pos].name,\n\t\t\tpc-&gt;data[pos].age,\n\t\t\tpc-&gt;data[pos].sex,\n\t\t\tpc-&gt;data[pos].adds,\n\t\t\tpc-&gt;data[pos].tele);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;没有找到此联系人&gt;\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 修改联系人的信息\nvoid ConModify(Con* pc)\n&#123;\n\tassert(pc &amp;&amp; pc-&gt;size &gt; 0);\n\n\tchar name[NAME_MAX];\n\tprintf(&quot;请输入要修改的联系人的信息的名字&gt; &quot;);\n\tscanf(&quot;%s&quot;, name);\n\n\tint pos &#x3D; Find_Name(pc, name);\n\n\tif (pos !&#x3D; -1)\n\t&#123;\n\t\tprintf(&quot;请修改&gt;\\n&quot;);\n\n\t\tprintf(&quot;请输入联系人的姓名：&quot;);\n\t\tscanf(&quot;%s&quot;, pc-&gt;data[pos].name);\n\t\tprintf(&quot;请输入联系人的年龄：&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;pc-&gt;data[pos].age);\n\t\tprintf(&quot;请输入联系人的性别：&quot;);\n\t\tscanf(&quot;%s&quot;, pc-&gt;data[pos].sex);\n\t\tprintf(&quot;请输入联系人的地址：&quot;);\n\t\tscanf(&quot;%s&quot;, pc-&gt;data[pos].adds);\n\t\tprintf(&quot;请输入联系人的电话：&quot;);\n\t\tscanf(&quot;%s&quot;, pc-&gt;data[pos].tele);\n\n\t\tprintf(&quot;修改成功&gt;\\n&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;要修改信息的联系人不存在&gt;\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 此时通讯录里联系人的个数\nint ConSize(Con* pc)\n&#123;\n\tassert(pc);\n\n\treturn pc-&gt;size;\n&#125;\n\n&#x2F;&#x2F; 销毁通讯录\nvoid ConDestory(Con* pc)\n&#123;\n\tassert(pc);\n\n\tfree(pc-&gt;data);\n\tpc-&gt;data &#x3D; NULL;\n\tpc-&gt;capacity &#x3D; 0;\n\tpc-&gt;size &#x3D; 0;\n\n\tprintf(&quot;销毁成功&gt;\\n&quot;);\n&#125;\n\n\n&#x2F;&#x2F; 按名字从小到大排序\nint cmp_con_name1(const void* a, const void* b)\n&#123;\n\treturn strcmp(((Info*)a)-&gt;name, ((Info*)b)-&gt;name);\n&#125;\n&#x2F;&#x2F; 按名字从大到小排序\nint cmp_con_name2(const void* a, const void* b)\n&#123;\n\treturn strcmp(((Info*)b)-&gt;name, ((Info*)a)-&gt;name);\n&#125;\n\n&#x2F;&#x2F; 按年龄从小到大排序\nint cmp_con_age1(const void* a, const void* b)\n&#123;\n\treturn ((Info*)a)-&gt;age - ((Info*)b)-&gt;age;\n&#125;\n\n&#x2F;&#x2F; 按年龄从大到小排序\nint cmp_con_age2(const void* a, const void* b)\n&#123;\n\treturn ((Info*)b)-&gt;age - ((Info*)a)-&gt;age;\n&#125;\n\n&#x2F;&#x2F; 交换的时候一个字节一个字节的换，因为不知道排序的是什么类型的数据\nvoid swap(char* buf1, char* buf2, size_t width)\n&#123;\n\tassert(buf1 &amp;&amp; buf2);\n\n\twhile (width--)\n\t&#123;\n\t\tchar tmp &#x3D; *buf1;\n\t\t*buf1 &#x3D; *buf2;\n\t\t*buf2 &#x3D; tmp;\n\t\tbuf1++;\n\t\tbuf2++;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 排序， 以冒泡排序为框架\nvoid Bubble_Sort(void* bese, size_t num, size_t width, int (*cmp)(const void*, const void*))\n&#123;\n\tassert(bese);\n\n\tfor (size_t i &#x3D; 0; i &lt; num - 1; ++i)\n\t&#123;\n\t\tfor (size_t j &#x3D; 0; j &lt; num - 1 - i; ++j)\n\t\t&#123;\n\t\t\tif (cmp((char*)bese + j * width, (char*)bese + (j + 1) * width) &gt; 0)\n\t\t\t&#123;\n\t\t\t\tswap((char*)bese + j * width, (char*)bese + (j + 1) * width, width);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 排序\nvoid ConSort(Con* pc)\n&#123;\n\tassert(pc);\n\n\tprintf(&quot;请选择何种方式排序：\\n&quot;);\n\tprintf(&quot;1.按名字排序：\\n2.按年龄排序：\\n&quot;);\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tif (n !&#x3D; 1 &amp;&amp; n !&#x3D; 2)\n\t&#123;\n\t\tprintf(&quot;选择错误,退出排序&gt;\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tif (n &#x3D;&#x3D; 1)\n\t&#123;\n\t\tint k &#x3D; 0;\n\t\tprintf(&quot;请选择如何排序：\\n&quot;);\n\t\tprintf(&quot;1.升序\\n2.降序\\n&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;k);\n\n\t\tif (k &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_name1);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse if (k &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_name2);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;选择错误&gt;\\n&quot;);\n\t\t&#125;\n\n\t&#125;\n\telse if (n &#x3D;&#x3D; 2)\n\t&#123;\n\t\tint k &#x3D; 0;\n\t\tprintf(&quot;请选择如何排序：\\n&quot;);\n\t\tprintf(&quot;1.升序\\n2.降序\\n&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;k);\n\n\t\tif (k &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_age1);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse if (k &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tBubble_Sort(pc-&gt;data, pc-&gt;size, sizeof(pc-&gt;data[0]), cmp_con_age2);\n\t\t\tprintf(&quot;排序成功&gt;\\n&quot;);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;选择错误&gt;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 保存通讯录\nvoid SaveContact(Con* pc)\n&#123;\n\tassert(pc);\n\n\t&#x2F;&#x2F; 将信息以二进制形式保存在Contacts.txt文本文档中\n\tFILE* pf &#x3D; fopen(&quot;Contact.txt&quot;, &quot;wb&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;Save Con fail&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; pc-&gt;size; i++)\n\t\t&#123;\n\t\t\tfwrite(pc-&gt;data + i, sizeof(Info), 1, pf);\n\t\t&#125;\n\n\t\tfclose(pf);\n\t\tpf &#x3D; NULL;\n\n\t\tprintf(&quot;保存通讯录数据成功&gt;\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 拿之前保存的通讯录数据\nvoid GetConData(Con* pc)\n&#123;\n\tassert(pc);\n\n\tFILE* pf &#x3D; fopen(&quot;Contact.txt&quot;, &quot;rb&quot;);\n\tif (pf &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tperror(&quot;Get data fail&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\tInfo tmp &#x3D; &#123; 0 &#125;;\n\n\t\tint i &#x3D; 0;\n\t\twhile (fread(&amp;tmp, sizeof(Info), 1, pf))\n\t\t&#123;\n\t\t\tJud_Exp(pc);        &#x2F;&#x2F; 判断是否要扩容\n\t\t\tpc-&gt;data[i] &#x3D; tmp;  &#x2F;&#x2F; 每拿一个联系人的信息就放入通讯录\n\t\t\tpc-&gt;size++;         &#x2F;&#x2F; 每get一个计数一次\n\t\t\ti++;                          \n\t\t&#125;\n\n\t\tfclose(pf);  &#x2F;&#x2F; get完后关闭文件\n\t\tpf &#x3D; NULL;\n\n\t\tprintf(&quot;获取之前的通讯录数据成功&gt;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n\n<h2 id=\"test-c\"><a href=\"#test-c\" class=\"headerlink\" title=\"test.c\"></a>test.c</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;Contacts.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;***********************************************\\n&quot;);\n\tprintf(&quot;**********      1.add     2.del      **********\\n&quot;);\n\tprintf(&quot;**********      3.find    4.modify   **********\\n&quot;);\n\tprintf(&quot;**********      5.sort    6.show     **********\\n&quot;);\n\tprintf(&quot;**********      7.clear   8.ConSize  **********\\n&quot;);\n\tprintf(&quot;**********      9.destory 0.exit     **********\\n&quot;);\n\tprintf(&quot;***********************************************\\n&quot;);\n&#125;\n\nenum select\n&#123;\n\tEXIT, &#x2F;&#x2F; 0 退出\n\tADD, &#x2F;&#x2F; 1 增加\n\tDEL, &#x2F;&#x2F; 2 删除\n\tFIND, &#x2F;&#x2F; 3 查找\n\tMODIFY, &#x2F;&#x2F; 4 修改\n\tSORT, &#x2F;&#x2F; 5 排序\n\tSHOW, &#x2F;&#x2F; 6 展示通讯录\n\tCLEAR, &#x2F;&#x2F; 7 清屏\n\tCONSIZE, &#x2F;&#x2F; 8 通讯录联系人个数\n\tDESTORY &#x2F;&#x2F; 9 销毁通讯录（要释放）\n&#125;;\n\t\nint main()\n&#123;\n\tint input &#x3D; 0;\n\tCon con;\n\tConInit(&amp;con);\n\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase EXIT:\n\t\t\tSaveContact(&amp;con);\n\t\t\tprintf(&quot;退出程序&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tcase ADD:\n\t\t\tConAdd(&amp;con);\n\t\t\tbreak;\n\t\tcase DEL:\n\t\t\tConDel(&amp;con);\n\t\t\tbreak;\n\t\tcase FIND:\n\t\t\tConFind(&amp;con);\n\t\t\tbreak;\n\t\tcase MODIFY:\n\t\t\tConModify(&amp;con);\n\t\t\tbreak;\n\t\tcase SORT:\n\t\t\tConSort(&amp;con);\n\t\t\tbreak;\n\t\tcase SHOW:\n\t\t\tConShow(&amp;con);\n\t\t\tbreak;\n\t\tcase CLEAR:\n\t\t\tsystem(&quot;cls&quot;);\n\t\t\tbreak;\n\t\tcase CONSIZE:\n\t\t\tprintf(&quot;现在通讯录里联系人的个数为：%d\\n&quot;, ConSize(&amp;con));\n\t\t\tbreak;\n\t\tcase DESTORY:\n\t\t\tConDestory(&amp;con);\n\t\t\tint n &#x3D; 0;\n\t\t\tprintf(&quot;是否需要重新初始化通讯录？\\n1.YES : 0.NO &gt;&gt;&gt; &quot;);\n\t\t\tscanf(&quot;%d&quot;, &amp;n);\n\t\t\tif (n)\n\t\t\t&#123;\n\t\t\t\tConInitNoInfo(&amp;con);\n\t\t\t\tprintf(&quot;重新初始化成功&gt;\\n&quot;);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tinput &#x3D; 0;\n\t\t\t\tprintf(&quot;通讯录进程关闭，退出程序&gt;&gt;&gt;&gt;&gt;&gt; \\n&quot;);\n\t\t\t&#125;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误，请重新选择&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>到了这里，一个简简单单的通讯录就完成了！如果还不能自我实现，那可要好好的练习了！</p></blockquote>\n<p><font color=blue size=4><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></font></p>\n","text":" 前言 学习&#x3D;&#x3D;C语言&#x3D;&#x3D;的小伙伴，相信都要经历实现通讯录这一关吧，接下来就带你手把手实现自己的通讯录！ 通讯录初始化 整个程序我们需要分三个文件，一个是头文件：Contacts.h：用来存放宏，结构体以及函数声明，还有需要用的库函数。一个...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":23,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":23,"path":"api/tags/C语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">通讯录初始化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%AE%AF%E5%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%92%8C%E8%8F%9C%E5%8D%95\"><span class=\"toc-text\">通讯录运行的基本框架和菜单</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E6%B7%BB%E8%81%94%E7%B3%BB%E4%BA%BA\"><span class=\"toc-text\">增添联系人</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E8%81%94%E7%B3%BB%E4%BA%BA\"><span class=\"toc-text\">删除联系人</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE%E8%81%94%E7%B3%BB%E4%BA%BA\"><span class=\"toc-text\">查找联系人</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">修改联系人信息</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B1%95%E7%A4%BA%E9%80%9A%E8%AE%AF%E5%BD%95\"><span class=\"toc-text\">展示通讯录</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%AE%AF%E5%BD%95%E8%81%94%E7%B3%BB%E4%BA%BA%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">通讯录联系人个数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E9%80%9A%E8%AE%AF%E5%BD%95\"><span class=\"toc-text\">排序通讯录</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%82%A8%E5%AD%98%E9%80%9A%E8%AE%AF%E5%BD%95%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">文件操作储存通讯录信息</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%94%80%E6%AF%81%E9%80%9A%E8%AE%AF%E5%BD%95\"><span class=\"toc-text\">销毁通讯录</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">整体代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Contacts-h\"><span class=\"toc-text\">Contacts.h</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Contacts-c\"><span class=\"toc-text\">Contacts.c</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#test-c\"><span class=\"toc-text\">test.c</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"【数据结构】顺序表","uid":"acb938686160e729bc4dce5cef8311df","slug":"【数据结构】顺序表","date":"2023-03-03T15:53:00.000Z","updated":"2023-03-03T15:55:09.846Z","comments":true,"path":"api/articles/【数据结构】顺序表.json","keywords":null,"cover":"/photo/屏幕截图_20230122_043538.png","text":"前言 顺序表作为数据结构中的小小弟，还是很好应付的。说到数据结构，顺序表是我们的向导，它让你明白数据结构到底是干啥的，为啥数据结构这么的重要。 实际上，通讯录的底层就是一个顺序表，里面的增添联系人，删除联系人等一系列操作，都是基于顺序表实现的，这也侧面拖出了数据结构的作用。所以，...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"【基础算法】关于高精度计算的问题【很高位数数据的加减乘除(相关代码用C++实现)】","uid":"48de73fbd4a7bbcd1c473c6c29503249","slug":"【基础算法】关于高精度计算的问题【很高位数数据的加减乘除-相关代码用C-实现-】","date":"2023-03-03T15:49:06.000Z","updated":"2023-03-03T15:50:14.498Z","comments":true,"path":"api/articles/【基础算法】关于高精度计算的问题【很高位数数据的加减乘除-相关代码用C-实现-】.json","keywords":null,"cover":"/photo/R-C (6).jpeg","text":"前言 当我们在利用计算机进行一些计算时，可能会遇到这类问题 ： 有些计算要求精度高，希望计算的数的位数可达几十位甚至几百位，虽然计算机的计算精度也算较高了，但因受到硬件的限制，往往达不到实际问题所要求的精度。 这时我们就可以通过程序设计来解决这类问题，例如：创建一个数组，通过数组...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":null}}