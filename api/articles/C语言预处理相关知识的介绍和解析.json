{"title":"C语言预处理相关知识的介绍和解析","uid":"10386f8dcb44ec1bbe05b4072762a00e","slug":"C语言预处理相关知识的介绍和解析","date":"2023-02-18T06:43:28.000Z","updated":"2023-02-18T06:44:33.501Z","comments":true,"path":"api/articles/C语言预处理相关知识的介绍和解析.json","keywords":null,"cover":"屏幕截图_20230122_044157.png","content":"<p><img src=\"https://img-blog.csdnimg.cn/b6ca9a4a366e454a8ffdf836c7ed8dbc.png#pic_center\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/img_convert/5fc844a3f599dc7e4fe059e8106a1420.jpeg#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><hr>\n<p><strong>上篇文章介绍了一个程序运行的 <a href=\"https://blog.csdn.net/Wennytime/article/details/128943129\">编译与链接</a> ，其中编译阶段有个预处理，他会对一些预处理指令进行处理，本章就对这些预处理相关的指令，操作符等等进行探讨。</strong></p>\n<hr>\n<h1 id=\"预定义符号介绍\"><a href=\"#预定义符号介绍\" class=\"headerlink\" title=\"预定义符号介绍\"></a>预定义符号介绍</h1><p> 这里介绍一些可能会常用到的符号：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__FILE__      &#x2F;&#x2F;进行编译的源文件\n__LINE__     &#x2F;&#x2F;文件当前的行号\n__DATE__    &#x2F;&#x2F;文件被编译的日期\n__TIME__    &#x2F;&#x2F;文件被编译的时间\n__STDC__    &#x2F;&#x2F;如果编译器遵循ANSI C，其值为1，否则未定义</code></pre>\n\n<p>这些预定义符号都是语言内置的，都已经为其设定了特有的值，下面来看看个别的值是啥呢：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tprintf(&quot;%s\\n&quot;, __FILE__);\n\tprintf(&quot;%d\\n&quot;, __LINE__);\n\tprintf(&quot;%s\\n&quot;, __DATE__);\n\tprintf(&quot;%s\\n&quot;, __TIME__);\n\n\t&#x2F;&#x2F; 下面的_STDC_在vs上是未定义的，编译就会报错\n\t&#x2F;&#x2F;printf(&quot;%d\\n&quot;, __STDC__); \n\n\treturn 0;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/d4846f92e017425280ec900bb6ac46d4.png\" alt=\"在这里插入图片描述\"><br><strong>有了这些预定义符号，我们可以随时随地的知道此时的时间和文件所在位置啦。</strong></p>\n<h1 id=\"预处理指令-define\"><a href=\"#预处理指令-define\" class=\"headerlink\" title=\"预处理指令#define\"></a>预处理指令<font color=red>#define</font></h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在Ｃ或C++语言源程序中允许用一个标识符来表示一个字符串，称为“宏”。被定义为“宏”的标识符称为“宏名”。在编译预处理时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换，这称为“宏代换”或“宏展开”。宏定义是由源程序中的宏定义命令完成的。宏代换是由预处理程序自动完成的。</p></blockquote>\n<ul>\n<li><p>&#x3D;&#x3D;#define&#x3D;&#x3D; 和 &#x3D;&#x3D;#include&#x3D;&#x3D; 一样，也是以“&#x3D;&#x3D;#&#x3D;&#x3D;”开头的。凡是以“#”开头的均为预处理指令，&#x3D;&#x3D;#define&#x3D;&#x3D;也不例外。</p>\n</li>\n<li><p>&#x3D;&#x3D;#define&#x3D;&#x3D;又称宏定义，标识符为所定义的宏名，简称宏。标识符的命名规则与前面讲的变量的命名规则是一样的。&#x3D;&#x3D;#define&#x3D;&#x3D; 的功能是将标识符定义为其后的常量。一经定义，程序中就可以直接用标识符来表示这个常量。是不是与定义变量类似？但是要区分开！变量名表示的是一个变量，但宏名表示的是一个常量。可以给变量赋值，但绝不能给常量赋值。</p>\n</li>\n<li><p>宏定义 &#x3D;&#x3D;#define&#x3D;&#x3D; 一般都写在函数外面，与 &#x3D;&#x3D;#include&#x3D;&#x3D; 写在一起。当然，写在函数里面也没有语法错误，但通常不那么写。&#x3D;&#x3D;#define&#x3D;&#x3D; 的作用域为自 &#x3D;&#x3D;#define&#x3D;&#x3D; 那一行起到源程序结束。如果要终止其作用域可以使用 &#x3D;&#x3D;#undef&#x3D;&#x3D; 命令，下面会介绍。</p>\n</li>\n</ul>\n<hr>\n<p>还需详细了解 &#x3D;&#x3D;#define&#x3D;&#x3D;， 可以<a href=\"http://c.biancheng.net/view/187.html\">点此链接</a>观摩大佬解析。</p>\n<hr>\n<p><strong>语法：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define name stuff</code></pre>\n\n<p><strong>举些个栗子：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define MAX 100\n#define FOREVER for(;;)\n#define reg register</code></pre>\n\n<ul>\n<li><p>可以看到宏的命名习惯都是大写，这样更能区别。</p>\n</li>\n<li><p>标识符的定义与常量是以空格隔开的。</p>\n</li>\n<li><p>第一个定义了一个标识符 &#x3D;&#x3D;MAX&#x3D;&#x3D; ,它是常量 <code>100</code>,当我们在用这个标识符时，在预处理阶段，&#x3D;&#x3D;MAX&#x3D;&#x3D; 将会被替换成<code>100</code>。</p>\n</li>\n<li><p>第二个是用更形象的符号来替换一种实现， &#x3D;&#x3D;for( ; ; )&#x3D;&#x3D; 相当于死循环，这里用 &#x3D;&#x3D;FOREVER&#x3D;&#x3D; 来形象的表示它。</p>\n</li>\n<li><p>第三个是为 &#x3D;&#x3D;register&#x3D;&#x3D;这个关键字，创建一个简短的名字。</p>\n</li>\n</ul>\n<p>那么我们在<font color=blue>define</font> 定义标识符的时候，要不要在最后加上 <code>;</code> ？</p>\n<p>比如：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define MAX 100;</code></pre>\n<p><strong>建议不要加上</strong>，因为当我们写C语言程序时，都会习惯在后面加上分号，如果是一个变量等于这个&#x3D;&#x3D;MAX&#x3D;&#x3D;（<font color=red>int max &#x3D; MAX；</font>），这时预处理阶段，会把这个 &#x3D;&#x3D;MAX&#x3D;&#x3D; 替换，变成<font color=red> int max &#x3D; 100;; </font>，此时有两个分号，这就出现了语法问题。</p>\n<hr>\n<p><strong>#define 定义宏：#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。</strong></p>\n<p>下面是宏的申明方式：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define name( parament-list ) stuff</code></pre>\n<p>其中的 <code>parament-list</code> 是一个由逗号隔开的符号表，它们可能出现在stuff中。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>参数列表的左括号必须与<code>name</code>紧邻。</li>\n<li>如果两者之间有任何空白存在，参数列表就会被解释为<code>stuff</code>的一部分。</li>\n</ol>\n<p>如：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define SQUARE(x)  x * x</code></pre>\n<p>这个宏接收一个参数 <code>x</code> ，如果在上述声明后，有以下写法：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">SQUARE(5);\nSQUARE(2 + 3);</code></pre>\n\n<p>第一种预处理阶段被替换后表达式变为：&#x3D;&#x3D;5 * 5&#x3D;&#x3D;；（计算结果为<code>25</code>）<br>第二种预处理阶段被替换后表达式变为：&#x3D;&#x3D;2 + 3 * 2 + 3&#x3D;&#x3D;；（计算结果为<code>11</code>）</p>\n<p><strong>可以看出，第二种并不是我们想要的结果，所以这种定义宏的方式有问题</strong></p>\n<p>那如果这样子使用呢：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">SQUARE((2 + 3));</code></pre>\n<p>替换后表达式变为：&#x3D;&#x3D;(2 + 3) * (2 + 3)&#x3D;&#x3D;；<strong>这样子是可以的，但是这样治标不治本，而且写的代码还不好看，所以我们直接在定义宏处加上括号，这样就更好了。</strong></p>\n<p>更新之后：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define SQUARE(x)  (x) * (x)</code></pre>\n<p>那么这样子是否还会有问题呢？实际上还是有的。</p>\n<p>如果是一下定义的宏：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define SQUARE(x)  (x) + (x)</code></pre>\n\n<p>有了上面的声明后，进行一下操作：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int a &#x3D; 5 * SQUARE(5);</code></pre>\n\n<p>替换后表达式为：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int a &#x3D; 5 * 5 + 5;</code></pre>\n<p>计算结果为：<code>30</code>，这也与我们想要的值不符。</p>\n<p><strong>所以我们在定义时要给整体也加上一个括号，这样才不会出错</strong></p>\n<p>正确规范定义：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define SQUARE(x)  ((x) + (x))</code></pre>\n\n<p><strong>所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间产生的不可预料的相互作用。</strong></p>\n<hr>\n<h2 id=\"define替换规则\"><a href=\"#define替换规则\" class=\"headerlink\" title=\"#define替换规则\"></a><font color=red>#define</font>替换规则</h2><p>在程序中扩展 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义符号和宏时，需要涉及几个步骤。</p>\n<ol>\n<li>在调用宏时，首先对参数进行检查，看看是否包含任何由 &#x3D;&#x3D;#define&#x3D;&#x3D;定义的符号。如果是，它们首先<br>被替换。</li>\n<li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。</li>\n<li>最后，再次对结果文件进行扫描，看看它是否包含任何由 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义的符号。如果是，就重复上<br>述处理过程。</li>\n</ol>\n<p><strong>注意：</strong><br>4. 宏参数和 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义中可以出现其他 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义的符号。但是对于宏，不能出现递归。<br>5. 当预处理器搜索 &#x3D;&#x3D;#define&#x3D;&#x3D; 定义的符号的时候，字符串常量的内容并不被搜索。</p>\n<hr>\n<h1 id=\"预处理指令-undef\"><a href=\"#预处理指令-undef\" class=\"headerlink\" title=\"预处理指令 #undef\"></a>预处理指令 <font color=red>#undef</font></h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>这条指令用于移除一个宏定义。</strong></p></blockquote>\n<p>在一个程序块中用完宏定义后，为防止后面标识符冲突需要取消其宏定义。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define MAX 100\nint a &#x3D; 100;\n#undef MAX</code></pre>\n<p><strong>这里第三行就取消了<code>MAX</code>的红定义，在下面还可以继续定义以<code>MAX</code>为标识符的宏。</strong></p>\n<hr>\n<h1 id=\"宏和函数的对比\"><a href=\"#宏和函数的对比\" class=\"headerlink\" title=\"宏和函数的对比\"></a>宏和函数的对比</h1><p>宏通常被应用于执行简单的运算，比如在两个数中找出较大的一个：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define MAX(a, b) ((a)&gt;(b)?(a):(b))</code></pre>\n\n\n<p><strong>那为什么不用函数来完成这个任务呢？</strong></p>\n<p><strong>原因有两点：</strong></p>\n<ol>\n<li>用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多（也就是函数调用和函数返回的栈帧的创建和销毁可能比实际的代码功能运行时间还要长）。所以宏比函数在程序的规模和速度方面更胜一筹。</li>\n<li>更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏可以适用于整形、长整型、浮点型等可以用<code>&gt;</code>来比较的类型。宏是类型无关的。</li>\n</ol>\n<p><strong>当然宏跟函数比较，也有其缺点：</strong></p>\n<ol>\n<li>每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。</li>\n<li>宏是没法调试的（<strong>不可以调试可能程序怎么出错的都不知道</strong>）。</li>\n<li>宏由于类型无关，也就不够严谨。</li>\n<li>宏可能会带来<strong>运算符优先级</strong>的问题，导致程容易出现错。</li>\n</ol>\n<p> 根据宏的优点举个栗子（宏的参数可以出现类型，但是函数做不到）：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define MALLOC(num, type) (type *)malloc(num * sizeof(type))\n...\n&#x2F;&#x2F;使用\nMALLOC(10, int);  &#x2F;&#x2F;类型作为参数\n\n&#x2F;&#x2F;预处理器替换之后：\n(int *)malloc(10 * sizeof(int));</code></pre>\n\n\n<h2 id=\"宏和函数的对比图\"><a href=\"#宏和函数的对比图\" class=\"headerlink\" title=\"宏和函数的对比图\"></a>宏和函数的对比图</h2><p><img src=\"https://img-blog.csdnimg.cn/c8976167e14b4f23bb03e5745ce3fde1.png\" alt=\"在这里插入图片描述\"></p>\n<hr>\n<h2 id=\"命名约定\"><a href=\"#命名约定\" class=\"headerlink\" title=\"命名约定\"></a>命名约定</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一般来讲函数和宏的语法很相似。所以语法本身没法帮我们区分二者。</p></blockquote>\n<p><strong>那我们平时的一个习惯是：</strong></p>\n<ul>\n<li>把宏名全部大写</li>\n<li>函数名不要全部大写</li>\n</ul>\n<hr>\n<h1 id=\"命令行定义\"><a href=\"#命令行定义\" class=\"headerlink\" title=\"命令行定义\"></a>命令行定义</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。</p></blockquote>\n<p><strong>例如：</strong></p>\n<ul>\n<li>当我们根据同一个源文件要编译出一个程序的不同版本的时候，这个特性有点用处（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大些，我们需要一个数组能够大些）。</li>\n</ul>\n<p>如有下面的代码（在<code>linux</code>中）：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\nint main()\n&#123;\n    int array [ARRAY_SIZE];\n    int i &#x3D; 0;\n    \n    for(i &#x3D; 0; i &lt; ARRAY_SIZE; i++)\n    &#123;\n        array[i] &#x3D; i;\n    &#125;\n    \n    for(i &#x3D; 0; i &lt; ARRAY_SIZE; i++)\n    &#123;\n        printf(&quot;%d &quot; ,array[i]);\n    &#125;\n    printf(&quot;\\n&quot; );\n    \n    return 0;\n&#125;</code></pre>\n<p>可以看到，上面的 &#x3D;&#x3D;ARRAY_SIZE&#x3D;&#x3D;是未定义的，但是我们可以通过以下指令对其赋值：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>linux</code> 环境演示<br>指令： &#x3D;&#x3D;gcc -D ARRAY_SIZE&#x3D;10 programe.c&#x3D;&#x3D;</p></blockquote>\n<p><strong>这样也可以灵活的控制数组大小啦。</strong></p>\n<hr>\n<h1 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h1><p><strong>在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。</strong></p>\n<p>比如说：</p>\n<p><strong>调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译。</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\n#define __DEBUG__\n\nint main()\n&#123;\n\t int i &#x3D; 0;\n\t int arr[10] &#x3D; &#123;0&#125;;\n\t \n\t for(i&#x3D;0; i&lt;10; i++)\n\t &#123;\n\t     arr[i] &#x3D; i;\n\t     \n\t     #ifdef __DEBUG__\n\t     printf(&quot;%d\\n&quot;, arr[i]);    &#x2F;&#x2F;为了观察数组是否赋值成功。 \n\t     #endif     &#x2F;&#x2F;__DEBUG__\n     &#125;\n \n return 0;\n&#125;</code></pre>\n<p><strong>&#x3D;&#x3D;#ifdef&#x3D;&#x3D; 是如果定义了就干嘛干嘛，&#x3D;&#x3D;#endif&#x3D;&#x3D; 是截断 &#x3D;&#x3D;#ifdef&#x3D;&#x3D;的作用继续往下延伸。</strong></p>\n<p><strong>可以看到，前面定义了<code>_DEBUG_</code>,所以后面的 <code>printf(&quot;%d\\n&quot;, arr[i]);</code> 这条语句将会被编译执行。</strong></p>\n<ul>\n<li><strong>常见的条件编译指令：</strong></li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">1.\n#if 常量表达式\n &#x2F;&#x2F;...\n#endif\n&#x2F;&#x2F;常量表达式由预处理器求值。\n如：\n#define __DEBUG__ 1\n#if __DEBUG__\n &#x2F;&#x2F;..\n#endif\n\n2.多个分支的条件编译\n#if 常量表达式\n &#x2F;&#x2F;...\n#elif 常量表达式\n &#x2F;&#x2F;...\n#else\n &#x2F;&#x2F;...\n#endif\n\n3.判断是否被定义\n#if defined(symbol)\n#ifdef symbol\n#if !defined(symbol)\n#ifndef symbol\n\n4.嵌套指令\n#if defined(OS_UNIX)\n   #ifdef OPTION1\n      unix_version_option1();\n   #endif\n   #ifdef OPTION2\n      unix_version_option2();\n   #endif\n#elif defined(OS_MSDOS)\n   #ifdef OPTION2\n      msdos_version_option2();\n   #endif\n#endif</code></pre>\n\n\n\n\n\n\n\n\n\n<hr>\n<h1 id=\"预处理指令-include\"><a href=\"#预处理指令-include\" class=\"headerlink\" title=\"预处理指令 #include\"></a>预处理指令 <font color=red>#include</font></h1><p><strong><code>#include</code></strong> 可以说是再熟悉不过了，我们已经知道， <strong><code>#include</code></strong> 指令可以使另外一个文件被编译。就像它实际出现于 <strong><code>#include</code></strong> 指令的地方一样。</p>\n<p>这种替换的方式很简单：</p>\n<ol>\n<li>预处理器先删除这条指令，并用包含文件的内容替换。</li>\n<li>这样一个源文件被包含10次，那就实际被编译10次。</li>\n</ol>\n<p><strong>而头文件的包含方式有两种：</strong></p>\n<ul>\n<li>一种是本地文件包含：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;filename&quot;</code></pre>\n\n<p><strong>查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。如果找不到就提示编译错误。</strong></p>\n<hr>\n<p>&#x3D;&#x3D;Linux环境的标准头文件的路径：&#x3D;&#x3D;</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;usr&#x2F;include</code></pre>\n<p>&#x3D;&#x3D;VS环境的标准头文件的路径：&#x3D;&#x3D;</p>\n<p><strong>注意：</strong> 不同编译器可能放在不同地方，要按照自己的安装路径去找。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include</code></pre>\n\n<hr>\n<ul>\n<li>一种是库文件包含</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;filename.h&gt;</code></pre>\n\n\n<p>查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。这样是不是可以说，对于库文件也可以使用<code> “ ”</code> 的形式包含？<strong>答案是肯定的，可以。</strong>   <font color=green size=4>但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了。</font></p>\n<h2 id=\"嵌套文件包含\"><a href=\"#嵌套文件包含\" class=\"headerlink\" title=\"嵌套文件包含\"></a>嵌套文件包含</h2><p>如果出现这样的场景：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6d8e63b06de245aba8e7342e80c8aed7.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">comm.h和comm.c是公共模块。\ntest1.h和test1.c使用了公共模块。\ntest2.h和test2.c使用了公共模块。\ntest.h和test.c使用了test1模块和test2模块。\n这样最终程序中就会出现两份comm.h的内容。这样就造成了文件内容的重复。</code></pre>\n\n\n<p><strong>那么如何解决这样的问题呢？</strong> 答案是：<strong>条件编译</strong>。</p>\n<p>每个头文件的开头写：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#ifndef __TEST_H__\n#define __TEST_H__\n&#x2F;&#x2F;头文件的内容\n#endif  &#x2F;&#x2F; __TEST_H__</code></pre>\n<p>或者：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#pragma once</code></pre>\n\n\n<p><strong>就可以避免头文件的重复引入。</strong></p>\n<p><font color=red size=5>注：</p>\n<p>推荐 &#x3D;&#x3D;《高质量C&#x2F;C++编程指南》&#x3D;&#x3D; 中附录的考试试卷（很重要）。</p>\n<p><strong>笔试题：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">1. 头文件中的 ifndef&#x2F;define&#x2F;endif是干什么用的?\n2. #include &lt;filename.h&gt; 和 #include &quot;filename.h&quot;有什么区别?</code></pre>\n\n\n\n\n<h1 id=\"其他预处理指令\"><a href=\"#其他预处理指令\" class=\"headerlink\" title=\"其他预处理指令\"></a>其他预处理指令</h1><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#error\n#pragma\n#line\n...</code></pre>\n\n<p><strong>这里就不一一做介绍，可以自己去了解。 &#x3D;&#x3D;#pragma pack()&#x3D;&#x3D; 在 <a href=\"https://blog.csdn.net/Wennytime/article/details/128666730\">结构体一章</a> 介绍了，可以去看噢。</strong></p>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>C语言阶段的知识学到这里，差不多就结束了呢，一路过来还是学到了非常多的知识，这也让我更加认清了自己的路还长着呢，接下来我会继续更新 &#x3D;&#x3D;基本数据结构&#x3D;&#x3D; 阶段的相关知识。</p></blockquote>\n<p><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></p>\n","feature":true,"text":" 前言 上篇文章介绍了一个程序运行的 编译与链接 ，其中编译阶段有个预处理，他会对一些预处理指令进行处理，本章就对这些预处理相关的指令，操作符等等进行探讨。 预定义符号介绍 这里介绍一些可能会常用到的符号： __FILE__ &#x2F;&#x2F;进行编译的源文件 __LINE...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":22,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":22,"path":"api/tags/C语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">预定义符号介绍</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4-define\"><span class=\"toc-text\">预处理指令#define</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#define%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99\"><span class=\"toc-text\">#define替换规则</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4-undef\"><span class=\"toc-text\">预处理指令 #undef</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">宏和函数的对比</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E6%AF%94%E5%9B%BE\"><span class=\"toc-text\">宏和函数的对比图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A\"><span class=\"toc-text\">命名约定</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">命令行定义</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">条件编译</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4-include\"><span class=\"toc-text\">预处理指令 #include</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B5%8C%E5%A5%97%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB\"><span class=\"toc-text\">嵌套文件包含</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">其他预处理指令</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"关于常引用的问题","uid":"53f3e274c7bda3bde7e9b295614179bc","slug":"关于常引用的问题-什么是权限放大？权限放小？隐式或强制转换居然还有这一步？","date":"2023-02-18T06:45:14.000Z","updated":"2023-02-18T06:46:59.735Z","comments":true,"path":"api/articles/关于常引用的问题-什么是权限放大？权限放小？隐式或强制转换居然还有这一步？.json","keywords":null,"cover":"屏幕截图_20230122_040600.png","text":"前言 引用在c++中的使用非常常见，可以说是很重要的，引用的常引用相关的问题让很多人稍不留神就出错了，这里我们就来谈谈常引用的问题。 关于权限 关于权限有权限缩小和权限放大的问题，比如一个文件，当初它只有读的权限，而现在你给它再加个写的权限，这就是权限放大；又或当初它读，写的权限...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"C++阶段相关知识点与问题的深度解析","slug":"C-阶段相关知识点与问题的深度解析","count":1,"path":"api/categories/C-阶段相关知识点与问题的深度解析.json"}],"tags":[{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"关于C语言非常重要的动态内存管理函数的解析和使用","uid":"a34c5dd4aef1e7a0fbf034a166eaf417","slug":"关于C语言非常重要的动态内存管理函数的解析和使用","date":"2023-02-18T06:14:44.000Z","updated":"2023-02-18T06:16:57.263Z","comments":true,"path":"api/articles/关于C语言非常重要的动态内存管理函数的解析和使用.json","keywords":null,"cover":"/photo/屏幕截图_20230122_041251.png","text":"前言 动态内存管理函数可以说很好用，但是有些小危险。 所谓动态内存分配，就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。 动态内存分配不像 数组 等 静态内存 分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":22,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":22,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":true}}