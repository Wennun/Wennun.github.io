{"title":"C语言函数篇（全）","uid":"a49297b33fb7686d3c6c056b10f0d94d","slug":"C语言函数篇（全）","date":"2023-02-17T14:04:16.000Z","updated":"2023-02-17T14:04:56.613Z","comments":true,"path":"api/articles/C语言函数篇（全）.json","keywords":null,"cover":[],"content":"<p>@[TOC]</p>\n<h1 id=\"一-前言\"><a href=\"#一-前言\" class=\"headerlink\" title=\"一.前言\"></a>一.前言</h1><p>本章为个人所学所理解的C语言中函数篇的相关知识，定有不足，还望大家多多指教。</p>\n<h1 id=\"二-什么是函数？\"><a href=\"#二-什么是函数？\" class=\"headerlink\" title=\"二.什么是函数？\"></a>二.什么是函数？</h1><p>函数是一段可以重复使用的代码，用来独立地完成某个功能。</p>\n<h1 id=\"三-函数的分类：\"><a href=\"#三-函数的分类：\" class=\"headerlink\" title=\"三.函数的分类：\"></a>三.函数的分类：</h1><p>函数可以分为库函数和自定义函数。</p>\n<h2 id=\"1-库函数\"><a href=\"#1-库函数\" class=\"headerlink\" title=\"1.库函数\"></a>1.库函数</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在说库函数之前，先给大家推荐一个网站，这个网站可以搜索到所有C语言中的库函数，它包含了这些函数的信息和如何使用的场景介绍，下面是它的网址：<br>[cplusplus]<a href=\"https://legacy.cplusplus.com/\">https://legacy.cplusplus.com/</a><br><img src=\"https://img-blog.csdnimg.cn/4764511e995a4f82836a3a8a8d21939f.png#pic_center\" alt=\"在这里插入图片描述\"></p></blockquote>\n<p>介绍：C语言在发布时已经为我们封装好了很多函数，它们被分门别类地放到了不同的头文件中（暂时先这样认为），使用这些函数时引入对应的头文件即可。这些函数是已经被编写的且效率极高，因此，为了某些功能的实现，引入库函数是首选。<br>比如：<br>strlen  strcpy  memcet</p>\n<h3 id=\"1-1-strlen的作用为求字符串长度\"><a href=\"#1-1-strlen的作用为求字符串长度\" class=\"headerlink\" title=\"1.1 strlen的作用为求字符串长度\"></a>1.1 strlen的作用为求字符串长度</h3><p><img src=\"https://img-blog.csdnimg.cn/268a465dde16443ea53770f3d10c144e.png#pic_center\" alt=\"在这里插入图片描述\"><br>这里放段代码展示其作用</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; &#x2F;&#x2F;引入包含strlen函数的头文件\n\nint main()\n&#123;\n\tchar arr[] &#x3D; &quot;hello&quot;;\n\n\tint ret &#x3D; strlen(arr);  &#x2F;&#x2F; 将求出的字符串返回值用整型变量接受\n\n\tprintf(&quot;%d\\n&quot;, ret);\n\n\treturn 0;\n&#125;</code></pre>\n<p>下面是运行结果<br><img src=\"https://img-blog.csdnimg.cn/4add3307f0ae4078ae8c56d68131c23d.png#pic_center\" alt=\"在这里插入图片描述\"><br>很明显strlen求出的值的确是“hello”的长度值。</p>\n<h3 id=\"1-2strcpy与memset函数的使用\"><a href=\"#1-2strcpy与memset函数的使用\" class=\"headerlink\" title=\"1.2strcpy与memset函数的使用\"></a>1.2strcpy与memset函数的使用</h3><p>可以说strcpy与memset有相似之处，在某些场景，这两个函数都能将其实现</p>\n<h4 id=\"1-2-1strcpy\"><a href=\"#1-2-1strcpy\" class=\"headerlink\" title=\"1.2.1strcpy\"></a>1.2.1strcpy</h4><p><img src=\"https://img-blog.csdnimg.cn/8545c1a461a34917b25eb365201afb4d.png#pic_center\" alt=\"在这里插入图片描述\"><br>通俗来说，strcpy是将一个字符串里的内容拷贝到另一个字符串里，值得注意的是，当一个字符串拷贝到另一个字符串里时，其第一个字符串里的字符串结束标志 “\\0” 也被拷贝进第二个字符串里，这时第二个字符串里原有的内容就会被两个“\\0”包围，从而打印第二个字符串时为第一个字符串的内容。</p>\n<p>代码实现：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;******&quot;;\n\tchar arr2[] &#x3D; &quot;abc&quot;;\n\n\tstrcpy(arr1, arr2);  &#x2F;&#x2F;&#x2F; 将arr2打印到目的地arr1中\n\n\tprintf(&quot;%s\\n&quot;, arr1);\n\n\treturn 0;\n&#125;</code></pre>\n<p>运行结果<br><img src=\"https://img-blog.csdnimg.cn/775cd98c8ce0441a9b8bcbaee5b66363.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"1-2-2-memset\"><a href=\"#1-2-2-memset\" class=\"headerlink\" title=\"1.2.2 memset\"></a>1.2.2 memset</h4><p><img src=\"https://img-blog.csdnimg.cn/7d534d5cbbc345ffb868b17afd825776.png#pic_center\" alt=\"在这里插入图片描述\"><br>C 库函数 void *memset(void *ptr, int value, size_t num) 复制字符 value（一个无符号字符）到参数 ptr 所指向的字符串的前 num 个字符。</p>\n<p>代码实现：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; &#x2F;&#x2F;  用 memset 对应头文件\n\nint main()\n&#123;\n\tchar arr1[] &#x3D; &quot;########&quot;;\n\n\tmemset(arr1, &#39;*&#39;, 4);   &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  将4个‘*’字符复制到arr1当中\n\n\tprintf(&quot;%s\\n&quot;, arr1);\n\n\treturn 0;\n&#125;</code></pre>\n<p>运行结果：<br><img src=\"https://img-blog.csdnimg.cn/9d12ba03f5c1443f9b3023915904dc8e.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>库函数还有很多，这里只是举的几个例子，如果要多的了解，可以访问上面给的网站。</p>\n<h2 id=\"2-自定义函数\"><a href=\"#2-自定义函数\" class=\"headerlink\" title=\"2. 自定义函数\"></a>2. 自定义函数</h2><p>自定义函数是自己实现的为了完成整个程序某个功能所设置的，他能多次调用，服务于整个程序，并且自定义函数各模块之间尽量功能独立。</p>\n<h3 id=\"2-1-为什么要有自定义函数？\"><a href=\"#2-1-为什么要有自定义函数？\" class=\"headerlink\" title=\"2.1 为什么要有自定义函数？\"></a>2.1 为什么要有自定义函数？</h3><p>大家想想，如果所有的功能库函数都为你提供了，那还关程序员啥事？<br>自定义函数在某种程度上更高于库函数，他能体现一个程序员的水平如何。</p>\n<h3 id=\"2-2-自定义函数的组成与例子\"><a href=\"#2-2-自定义函数的组成与例子\" class=\"headerlink\" title=\"2.2 自定义函数的组成与例子\"></a>2.2 自定义函数的组成与例子</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">ret_type function_name(para, *)\n&#123;\n\t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  函数体\n&#125;\nret_type &#x2F;&#x2F;返回类型\nfunction_name &#x2F;&#x2F; 函数名\npara &#x2F;&#x2F; 函数参数\n* &#x2F;&#x2F; 另一个参数 ，待定义</code></pre>\n<p>例如：1.（计算两个整型变量的和）（Add）</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\n&#x2F;&#x2F; 这里返回值为整型\nint Add(int a, int b)  &#x2F;&#x2F;&#x2F;  用两个整型值接受传来的 a b ，这里可以重名\n&#123;\n\treturn (a + b);\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\t&#x2F;&#x2F; ret 接受返回值\n\tint ret &#x3D; Add(a, b); &#x2F;&#x2F; 传参 求和\n\n\tprintf(&quot;%d\\n&quot;, ret); &#x2F;&#x2F; 打印和值\n\n\treturn 0;\n&#125;</code></pre>\n<p>运行结果：<br><img src=\"https://img-blog.csdnimg.cn/b62f047bd9314a60bc369d7d1d6dbb7c.png#pic_center\" alt=\"在这里插入图片描述\"><br>例 2. 求一个整数的位数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint fun(int n)\n&#123;\n\tint count &#x3D; 0;\n\n\twhile (n &gt; 0)\n\t&#123;\n\t\tn &#x3D; n &#x2F; 10;\n\t\tcount++;\n\t&#125;\n\n\treturn count;\n&#125;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tint ret &#x3D; fun(n);\n\n\tprintf(&quot;%d\\n&quot;, ret);\n\n\treturn 0;\n&#125;</code></pre>\n<p>运行结果：<br><img src=\"https://img-blog.csdnimg.cn/c5c6f44287fc464cb5843f7369456c69.png#pic_center\" alt=\"在这里插入图片描述\"><br>这里函数名最好是取与功能相关的名字，这样更具可读性。</p>\n<h3 id=\"2-3-void说明：\"><a href=\"#2-3-void说明：\" class=\"headerlink\" title=\"2.3 void说明：\"></a>2.3 void说明：</h3><p>如果一个函数的返回类型为void，表示这个函数没有返回值，一般这样使用可能是为了打印某个东西，也可能是将某个整型变量或者数组元素改变。<br>例如：这里将数组元素改变。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nvoid ecg(int arr[], int sz)\n&#123;\n\tint i &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tarr[i] &#x3D; 0;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tint arr[3] &#x3D; &#123; 1,2,3 &#125;;\n\tint sz &#x3D; sizeof(arr) &#x2F; sizeof(arr[0]);  &#x2F;&#x2F; 求数组 长度&#x2F;元素个数\n\n\tecg(arr, sz); &#x2F;&#x2F;&#x2F;&#x2F; 这里我们将arr数组内容全改为0\n\n\tint i &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; sz; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, arr[i]);\n\t&#125;\n\n\treturn 0;\n&#125;</code></pre>\n<p>运行结果：<br><img src=\"https://img-blog.csdnimg.cn/68551d457f8e4180ad6a1c57c16ac0bc.png#pic_center\" alt=\"在这里插入图片描述\"><br>这里我们将整型数组的内容全部改为 0 。</p>\n<h1 id=\"四-函数的参数\"><a href=\"#四-函数的参数\" class=\"headerlink\" title=\"四. 函数的参数\"></a>四. 函数的参数</h1><h2 id=\"1-实际参数（实参）\"><a href=\"#1-实际参数（实参）\" class=\"headerlink\" title=\"1. 实际参数（实参）\"></a>1. 实际参数（实参）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>实参为传递给函数的参数，它可以是常量，表达式，函数（这里实参作为另一个函数的返回值）等。在实参传递时，他必须要有确定的值以便于形参接受。</p></blockquote>\n<h2 id=\"2-形式参数（形参）\"><a href=\"#2-形式参数（形参）\" class=\"headerlink\" title=\"2.形式参数（形参）\"></a>2.形式参数（形参）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>形参是实参的一份临时拷贝，当一个函数被调用时，形参才被实例化，当函数结束时，形参也相继被释放。</p></blockquote>\n<h1 id=\"五-函数的调用\"><a href=\"#五-函数的调用\" class=\"headerlink\" title=\"五. 函数的调用\"></a>五. 函数的调用</h1><h2 id=\"1-传值调用\"><a href=\"#1-传值调用\" class=\"headerlink\" title=\"1.传值调用\"></a>1.传值调用</h2><p>例如：求两个数的最大值</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint Max(int a, int b)\n&#123;\n\treturn (a &gt; b ? a : b);\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\n\tint ret &#x3D; Max(a, b); &#x2F;&#x2F;&#x2F;&#x2F; 这里传递的是 a b 的值\n\n\tprintf(&quot;MAX &#x3D; %d&quot;, ret);\n\n\treturn 0;\n&#125;</code></pre>\n<p>运行结果：<br><img src=\"https://img-blog.csdnimg.cn/7b2f70b057fb4061a606fbd5fcf85151.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-传址调用\"><a href=\"#2-传址调用\" class=\"headerlink\" title=\"2. 传址调用\"></a>2. 传址调用</h2><p>当我们调用函数想要改变实参的值，这是我们应该使用传址调用，因为形参接受实参值时会开辟另外的空间来存放，这时想要通过改变形参来达到改变实参的目的，就不会实现，因为地址不同，所以我们要传地址。<br>例如：交换两个整型值</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nvoid ecg(int* a, int* b)\n&#123;\n\tint tmp &#x3D; *a;\n\t*a &#x3D; *b;\n\t*b &#x3D; tmp;\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\tprintf(&quot;交换前：%d %d\\n&quot;, a, b);\n\n\tecg(&amp;a, &amp;b);\n\n\tprintf(&quot;交换后：%d %d\\n&quot;, a, b);\n\n\treturn 0;\n&#125;</code></pre>\n<p>运行结果：<br><img src=\"https://img-blog.csdnimg.cn/31c8ccbd0cff47f0abc80ae08462b89a.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"六-函数的嵌套调用和链式访问\"><a href=\"#六-函数的嵌套调用和链式访问\" class=\"headerlink\" title=\"六. 函数的嵌套调用和链式访问\"></a>六. 函数的嵌套调用和链式访问</h1><h2 id=\"1-函数的嵌套调用\"><a href=\"#1-函数的嵌套调用\" class=\"headerlink\" title=\"1.函数的嵌套调用\"></a>1.函数的嵌套调用</h2><p>这里用代码来展现：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint ADD(int c) &#123;\n\treturn 2 * c;\n&#125;\n\nint doubleAdd(int a, int b)  \n&#123;\n\tint c &#x3D; a + b;\n\n\tint rets &#x3D; ADD(c);  &#x2F;&#x2F;&#x2F;&#x2F;  调用 2*实参 的函数\n\n\treturn rets;\n&#125;\n\nint main()\n&#123;\n\tint a &#x3D; 0;\n\tint b &#x3D; 0;\n\tscanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\n\tint ret &#x3D; doubleAdd(a, b);  &#x2F;&#x2F;&#x2F;&#x2F;  调用函数\n\n\tprintf(&quot;%d\\n&quot;, ret);\n\n\treturn 0;\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/63a835eef15347dfaaef2f60598629cf.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-函数的链式访问\"><a href=\"#2-函数的链式访问\" class=\"headerlink\" title=\"2. 函数的链式访问\"></a>2. 函数的链式访问</h2><p>把一个函数的返回值作为另一个函数的参数<br>这里用一段典型代码来表示：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tprintf(&quot;%d&quot;, printf(&quot;%d&quot;, printf(&quot;%d&quot;, 43)));\n\n\treturn 0;\n&#125;</code></pre>\n<p>补充：printf函数返回值是一个数的位数 ，也就是有几个数。<br><img src=\"https://img-blog.csdnimg.cn/5d0734a52c8c44138c41030474784493.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"七-函数的声明和定义\"><a href=\"#七-函数的声明和定义\" class=\"headerlink\" title=\"七. 函数的声明和定义\"></a>七. 函数的声明和定义</h1><h2 id=\"1-函数的声明\"><a href=\"#1-函数的声明\" class=\"headerlink\" title=\"1. 函数的声明\"></a>1. 函数的声明</h2><p>（1）在一个项目中声明一般在头文件里，定义与使用一般在不同的 .C 文件中。</p>\n<p>（2）函数的使用一定要先定义后声明后使用，如果一个自定义函数模块放在main函数后面，那么在main函数前一定要声明，不然当你在main函数中使用定义的函数时，编译器从上至下编译你的代码不会先编译你的函数定义的内容，这时就会报某某未定义错误。<br>（3）声明就是告诉编译器函数叫什么，参数是什么，返回类型是什么。</p>\n<h2 id=\"2-函数的定义\"><a href=\"#2-函数的定义\" class=\"headerlink\" title=\"2. 函数的定义\"></a>2. 函数的定义</h2><p>定义就是函数功能的实现，使它能够完成项目的某个模块。<br>前面有定义的例子，这里就不举例了。</p>\n<h1 id=\"八-函数的递归\"><a href=\"#八-函数的递归\" class=\"headerlink\" title=\"八. 函数的递归\"></a>八. 函数的递归</h1><h2 id=\"1-什么是递归？\"><a href=\"#1-什么是递归？\" class=\"headerlink\" title=\"1. 什么是递归？\"></a>1. 什么是递归？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>递归实际上就是程序自己调用自己，它常常可以把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，这可以大大减少代码量，所以递归的主要思考方式在于：把大事化小。</p></blockquote>\n<h2 id=\"2-递归必要的两个条件\"><a href=\"#2-递归必要的两个条件\" class=\"headerlink\" title=\"2. 递归必要的两个条件\"></a>2. 递归必要的两个条件</h2><p> 1.存在限制条件，当满足这个限制条件后，递归便不再进行。<br> 2.每次递归第调用都要越来越接近这个限制条件。</p>\n<h2 id=\"3-递归练习\"><a href=\"#3-递归练习\" class=\"headerlink\" title=\"3. 递归练习\"></a>3. 递归练习</h2><h3 id=\"1-求n的阶乘\"><a href=\"#1-求n的阶乘\" class=\"headerlink\" title=\"1.求n的阶乘\"></a>1.求n的阶乘</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint jc(int n)\n&#123;\n\tint i &#x3D; 0;\n\n\tif (n &lt;&#x3D; 1)\n\t&#123;\n\t\treturn 1;\n\t&#125;\n\telse\n\t&#123;\n\t\treturn n * jc(n - 1);\n \t&#125;\n&#125;\n&#x2F;&#x2F;递归\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tint ret &#x3D; jc(n);\n\n\tprintf(&quot;%d&quot;, ret);\n\n\treturn 0;\n&#125;</code></pre>\n<h3 id=\"2-正序打印一个整型值的每一位\"><a href=\"#2-正序打印一个整型值的每一位\" class=\"headerlink\" title=\"2.正序打印一个整型值的每一位\"></a>2.正序打印一个整型值的每一位</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nvoid Print(int n)\n&#123;\n\tif (n &gt; 0)\n\t&#123;\n\t\tPrint(n &#x2F; 10);\n\t&#125;\n\telse\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\tprintf(&quot;%d &quot;, n % 10);\n&#125;\n\nint main()\n&#123;\n\tint n &#x3D; 0;\n\tscanf(&quot;%d&quot;, &amp;n);\n\n\tPrint(n);&#x2F;&#x2F; 正序打印一个整数的每一位  \n\n\treturn 0;\n&#125;</code></pre>\n\n<h3 id=\"3-递归实现strlen求字符串长度\"><a href=\"#3-递归实现strlen求字符串长度\" class=\"headerlink\" title=\"3. 递归实现strlen求字符串长度\"></a>3. 递归实现strlen求字符串长度</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint my_strlen(char* str)\n&#123;\n\tif (*str !&#x3D; &#39;\\0&#39;)\n\t&#123;\n\t\treturn 1 + my_strlen(str + 1);\n\t&#125;\n\telse\n\t&#123;\n\t\treturn 0;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tchar arr[] &#x3D; &quot;hello&quot;;\n\n\tint len &#x3D; my_strlen(arr);\n\tprintf(&quot;%d&quot;, len);\n\n\treturn 0;\n&#125;</code></pre>\n\n<h2 id=\"4-递归的局限性\"><a href=\"#4-递归的局限性\" class=\"headerlink\" title=\"4. 递归的局限性\"></a>4. 递归的局限性</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>值得注意的是：因为递归有以上良好的功能，所以其思考难度较大。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>有时，递归使代码量大大减少的同时也增加了程序的运行难度（运行效率大大降低，如：求第n个斐波那契数)，并且其可读性没有非递归那么好，所以递归也要好好思考来选择。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果递归使用不当，就会出现栈溢出（“Stack overflow”）现象，这是因为每次函数调用都会在内存的栈区开辟一个自己的空间，如果递归过多导致内存栈空间开辟过多，这时就会出现溢出现象。</p></blockquote>\n<h1 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九. 总结\"></a>九. 总结</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总的来说，函数在C语言中具有相当高的地位，它的存在使得一个项目更具模块化，便捷化，实效性和可读性，因此，我们在学习C语言当中，应养成函数定义这一习惯，并将使用函数的思维融会贯通。</p></blockquote>\n","feature":true,"text":"@[TOC] 一.前言本章为个人所学所理解的C语言中函数篇的相关知识，定有不足，还望大家多多指教。 二.什么是函数？函数是一段可以重复使用的代码，用来独立地完成某个功能。 三.函数的分类：函数可以分为库函数和自定义函数。 1.库函数 在说库函数之前，先给大家推荐一个网站，这个网站...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">一.前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">二.什么是函数？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89-%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A\"><span class=\"toc-text\">三.函数的分类：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%BA%93%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">1.库函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-strlen%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%BA%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">1.1 strlen的作用为求字符串长度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2strcpy%E4%B8%8Ememset%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.2strcpy与memset函数的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-1strcpy\"><span class=\"toc-text\">1.2.1strcpy</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-2-memset\"><span class=\"toc-text\">1.2.2 memset</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2. 自定义函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">2.1 为什么要有自定义函数？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">2.2 自定义函数的组成与例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-void%E8%AF%B4%E6%98%8E%EF%BC%9A\"><span class=\"toc-text\">2.3 void说明：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">四. 函数的参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%EF%BC%88%E5%AE%9E%E5%8F%82%EF%BC%89\"><span class=\"toc-text\">1. 实际参数（实参）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%EF%BC%88%E5%BD%A2%E5%8F%82%EF%BC%89\"><span class=\"toc-text\">2.形式参数（形参）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">五. 函数的调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BC%A0%E5%80%BC%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">1.传值调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%BC%A0%E5%9D%80%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2. 传址调用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AD-%E5%87%BD%E6%95%B0%E7%9A%84%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">六. 函数的嵌套调用和链式访问</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">1.函数的嵌套调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%87%BD%E6%95%B0%E7%9A%84%E9%93%BE%E5%BC%8F%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">2. 函数的链式访问</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%83-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">七. 函数的声明和定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">1. 函数的声明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">2. 函数的定义</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AB-%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92\"><span class=\"toc-text\">八. 函数的递归</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92%EF%BC%9F\"><span class=\"toc-text\">1. 什么是递归？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E9%80%92%E5%BD%92%E5%BF%85%E8%A6%81%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">2. 递归必要的两个条件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%80%92%E5%BD%92%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">3. 递归练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%B1%82n%E7%9A%84%E9%98%B6%E4%B9%98\"><span class=\"toc-text\">1.求n的阶乘</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%AD%A3%E5%BA%8F%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B%E5%80%BC%E7%9A%84%E6%AF%8F%E4%B8%80%E4%BD%8D\"><span class=\"toc-text\">2.正序打印一个整型值的每一位</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0strlen%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">3. 递归实现strlen求字符串长度</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E9%80%92%E5%BD%92%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7\"><span class=\"toc-text\">4. 递归的局限性</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B9%9D-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">九. 总结</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C语言实现初级三子棋","uid":"d5a6879e81b57b97e13538ee2b9c1dd3","slug":"C语言实现初级三子棋","date":"2023-02-17T14:07:06.000Z","updated":"2023-02-17T14:07:19.267Z","comments":true,"path":"api/articles/C语言实现初级三子棋.json","keywords":null,"cover":[],"text":"@[TOC] 一. 前言 本章我们用C语言来实现一个初级的三子棋小游戏，三子棋想必大家都玩过，只要每一行或每一列或对角线三个棋相同，那么便获得胜利，由此我们分析下棋的步骤与获胜判断，来构建一个C语言三子棋的代码框架。 游戏实现我们分装两个 .c （代码主函数与函数定义源代码）后缀...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":true},"next_post":{}}