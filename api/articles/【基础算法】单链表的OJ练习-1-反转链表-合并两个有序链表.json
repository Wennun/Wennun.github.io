{"title":"【基础算法】单链表的OJ练习(1)","uid":"7ca2e84fccf5532a68e25ef3af8a8b80","slug":"【基础算法】单链表的OJ练习-1-反转链表-合并两个有序链表","date":"2023-03-03T15:53:46.000Z","updated":"2023-03-03T15:57:14.395Z","comments":true,"path":"api/articles/【基础算法】单链表的OJ练习-1-反转链表-合并两个有序链表.json","keywords":null,"cover":"/photo/R-C (4).jpeg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><ul>\n<li><p>上一章讲解了单链表 &#x3D;&#x3D;-&gt;&#x3D;&#x3D; <a href=\"https://blog.csdn.net/Wennytime/article/details/129167171\">传送门</a>  &#x3D;&#x3D;&lt;-&#x3D;&#x3D; ，后面几章就对单链表进行一些简单的题目练习，目的是为了更好的理解单链表的实现以及加深对某些函数接口的熟练度。</p>\n</li>\n<li><p>本章带来了两个题目。一是<font color=red>反转链表</font>，二是<font color=red>合并两个有序链表</font>，整体难度不大，但要理清解题思路。</p>\n</li>\n</ul>\n<h1 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h1><p> 题目链接 &#x3D;&#x3D;-&gt;&#x3D;&#x3D; <a href=\"https://leetcode.cn/problems/reverse-linked-list/\">传送门</a> &#x3D;&#x3D;&lt;-&#x3D;&#x3D;</p>\n<ul>\n<li>该题目的意思是将一个单链表反转过来，单链表的尾节点变成新的头节点，头节点变成新的尾节点：</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/277063c0541a44c88515f422e76bd773.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>题目描述是，给你一个单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>\n</li>\n<li><p>返回反转后的链表也就是返回反转后的链表的头节点。</p>\n</li>\n</ul>\n<p><font color=red size=4>思路一：</font></p>\n<ul>\n<li>创建一个新的链表，取原链表的元素依次&#x3D;&#x3D;头插&#x3D;&#x3D;即可，最后返回这个新的链表的头节点。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/09abe150ae004246856b571ecc00caf4.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red size=4>思路二：</font></p>\n<ul>\n<li><p>直接修改原链表，返回原链表的尾节点（反转后的头节点）即可。</p>\n</li>\n<li><p>定义三个指针遍历原链表，三个指针 &#x3D;&#x3D;（prev，cur，tail）&#x3D;&#x3D; <code>prev</code>开始指向<code>NULL，cur</code>指向头节点，<code>tail</code>指向<code>cur</code> 的下一个节点(为了找到下一个)。具体操作就是<code>cur-&gt;next = prev</code>（将指针改变指向），然后<code>prev = cur，cur = tail</code>，<code>tail = cur-&gt;next</code>(该语句在循环的开头)。这样又是三个指针指向不同的节点，然后再将<code>cur</code>的指针指向前一个<code>prev</code>，整个过程其实就是一个循环。</p>\n</li>\n<li><p>循环的条件是<code>cur</code>不为<code>NULL</code>就继续，当<code>cur</code>为空，也就是最后一步<code>cur = tail</code>，此时cur，<code>tail</code>都为空，而<code>prev</code>刚好指向原链表的最后一个节点，所以最后返回<code>prev</code>就可以了。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/fc463a3f6ade4c3380ec2eaa6e31a191.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><font color=blue size=4>这里采用思路二进行代码实现：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct ListNode* reverseList(struct ListNode* head)&#123;\n    struct ListNode* cur &#x3D; head;\n    struct ListNode* prev &#x3D;  NULL;\n    while (cur)\n    &#123;\n        struct ListNode* tail &#x3D; cur-&gt;next;\n        cur-&gt;next &#x3D; prev;\n        prev &#x3D; cur;\n        cur &#x3D; tail;\n    &#125;\n\n    return prev;\n&#125;</code></pre>\n\n\n\n<h1 id=\"合并两个有序链表\"><a href=\"#合并两个有序链表\" class=\"headerlink\" title=\"合并两个有序链表\"></a>合并两个有序链表</h1><p> 题目链接 &#x3D;&#x3D;-&gt;&#x3D;&#x3D; <a href=\"https://leetcode.cn/problems/merge-two-sorted-lists/\">传送门</a> &#x3D;&#x3D;&lt;-&#x3D;&#x3D;。</p>\n<ul>\n<li>题目描述：<strong>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</strong></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/2e0af2a8cb834b5f89bc3b4be45d8f47.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>该题与归并排序的排序思路差不多。本题需要创建一个新链表。之后采用双指针分别遍历上下两个链表，那个节点的数据较小，就在新的链表中尾插该节点，然后指向该节点的指针向后移动一位。整体来说就是一个循环，循环结束的条件就是两个指针都指向了<code>NULL</code>或者其中一个指针指向了<code>NULL</code>。</p>\n</li>\n<li><p>注意，我们这里的新链表是不带哨兵位的，当然带哨兵位可能更加方便，最后需要返回哨兵位的下一个节点的指针。</p>\n</li>\n<li><p>如果循环结束后，有一个指针没有指向<code>NULL</code>，那么在后面还需要将剩余的节点依次尾插，直到两个指针都为<code>NULL</code>合并成功。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/0cc20fe4278343be8ed6dbf37f863011.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><font color=blue size=4>代码实现：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) &#123;\n    struct ListNode* l1 &#x3D; list1, * l2 &#x3D; list2;  &#x2F;&#x2F; 两个指针分别指向两个链表的头\n    struct ListNode* head &#x3D; NULL, * cur &#x3D; NULL;  &#x2F;&#x2F; 新链表的头和进行操作的指针cur\n    while (l1 &amp;&amp; l2)   &#x2F;&#x2F; 有一个指向空就结束\n    &#123;\n        if (l1-&gt;val &lt; l2-&gt;val)  &#x2F;&#x2F; 比较数据值\n        &#123;\n            if (!head) head &#x3D; cur &#x3D; l1;   &#x2F;&#x2F; 这个if是如果新链表为空，就将该节点作为头节点\n            else cur-&gt;next &#x3D; l1, cur &#x3D; cur-&gt;next;\n            l1 &#x3D; l1-&gt;next;\n        &#125;\n        else\n        &#123;\n            if (!head) head &#x3D; cur &#x3D; l2;\n            else cur-&gt;next &#x3D; l2, cur &#x3D; cur-&gt;next;\n            l2 &#x3D; l2-&gt;next;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 如果l1不为空说明l1还有节点没有尾插完，需继续尾插\n    while (l1)\n    &#123;\n        if (!head) head &#x3D; cur &#x3D; l1;\n        else cur-&gt;next &#x3D; l1, cur &#x3D; cur-&gt;next;\n        l1 &#x3D; l1-&gt;next;\n    &#125;\n    &#x2F;&#x2F; 如果l2不为空说明l2还有节点没有尾插完，需继续尾插\n    while (l2)\n    &#123;\n        if (!head) head &#x3D; cur &#x3D; l2;\n        else cur-&gt;next &#x3D; l2, cur &#x3D; cur-&gt;next;\n        l2 &#x3D; l2-&gt;next;\n    &#125;\n\t\n\t&#x2F;&#x2F; 最后返回新链表的头节点\n    return head;\n&#125;</code></pre>\n\n\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><font color=red size=4><strong>对于单链表的题目练习，最重要的是思路，我们在数据结构阶段要养成画图的习惯，因为它能帮助我们更好的理解。后续还会有单链表相关的题目练习。</strong></font></p></blockquote>\n<p><font color=blue size=4><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></font></p>\n","feature":null,"text":"前言 上一章讲解了单链表 &#x3D;&#x3D;-&gt;&#x3D;&#x3D; 传送门 &#x3D;&#x3D;&lt;-&#x3D;&#x3D; ，后面几章就对单链表进行一些简单的题目练习，目的是为了更好的理解单链表的实现以及加深对某些函数接口的熟练度。 本章带来了两个题...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">反转链表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">合并两个有序链表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C语言常用内存函数的深度解析与自我实现","uid":"f270be882af30c8038e39539db2e9228","slug":"C语言常用内存函数的深度解析与自我实现","date":"2023-02-18T04:05:03.000Z","updated":"2023-02-18T06:55:07.991Z","comments":true,"path":"api/articles/C语言常用内存函数的深度解析与自我实现.json","keywords":null,"cover":"/photo/R-C.jpeg","text":"前言 内存函数的使用广泛度大于常用字符串函数的使用广泛度，因为字符串函数只适用于与字符相关的，而内存函数适用于各个类型，因为他是从内存出发，对内存进行修改，因此，学会内存函数，可谓收获满满呀。 这些内存函数的头文件是&lt;string.h&gt; memcpy 该函数的功能是内...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":23,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":23,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"【数据结构】单链表","uid":"bfad240cf4f429ffe303cb01324aaae0","slug":"【数据结构】单链表","date":"2023-03-03T15:53:13.000Z","updated":"2023-03-03T15:56:22.300Z","comments":true,"path":"api/articles/【数据结构】单链表.json","keywords":null,"cover":"/photo/v2-99dff3d20928f72a1edd7aa1bebc4a21_r.jpg","text":" 前言 在学习数据结构时，单链表可谓是第一个需要跨越的台阶。 从C语言到数据结构，单链表能够真正的反映我们C语言到底学的扎不扎实，那是因为，单链表对于C语言中的指针，结构体，以及函数模块的实现有较高的要求。因此，通过本章的学习，要是能够自我实现单链表，那你的C语言功底会厚实，你的...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"21 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":null}}