{"title":"使用C语言实现初级扫雷小游戏","uid":"fc86da1651adc032c38c6b773ee69698","slug":"使用C语言实现初级扫雷小游戏","date":"2023-02-17T14:37:11.000Z","updated":"2023-02-18T02:58:01.288Z","comments":true,"path":"api/articles/使用C语言实现初级扫雷小游戏.json","keywords":null,"cover":"/photo/p3.png","content":"<h1 id=\"一-前言\"><a href=\"#一-前言\" class=\"headerlink\" title=\"一. 前言\"></a>一. 前言</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>本章我们用C语言简单实现一个9×9雷阵的扫雷小游戏。</li>\n<li>说到扫雷想必大家都不陌生，开始我们点击一个小方块，那么这个小方块上会显示它周围八个小方块里雷的个数，凭借这个数值，在判断下一个要扫的位置（当然可能前面两步需要我们的幸运成分了），当我们除雷外的所有小方块都已经显示完了，那么扫雷成功。</li>\n<li>这里我们分框架（框架代码在主函数中）展示游戏的实现。</li>\n<li>游戏实现我们分装两个 .c （代码主函数与函数定义源代码）后缀的文件和一个 .h 的文件（头文件，函数声明）</li>\n<li>.h : game.h<br>.c : test.c (主函数体文件) |||||| game.c (函数定义文件)</li>\n</ul></blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/45fb0283a37841cb92b4fcded09291f9.png#pic_center\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/f412e0066cf9407e9563a939190b2db2.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>这里我们先把头文件里的库函数，函数声明和定义的全局常量以及主函数的函数调用结构展示出来，以便后面有迹可循：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 9\n#define COL 9\n#define ROWS ROW + 2\n#define COLS COL + 2\n#define MINE_COUNT 10\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret);\n\nvoid print_board(char board[ROWS][COLS], int row, int col);\n\nvoid add_mine(char board[ROWS][COLS], int row, int col);\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n\n&#x2F;&#x2F; 1.初始化雷盘与扫雷盘\n&#x2F;&#x2F; 2.打印盘\n&#x2F;&#x2F; 3.布置雷\n&#x2F;&#x2F; 4.扫雷\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  1.PLAY  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  0.EXIT  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar mine[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\tchar show[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F; 初始化盘\n\tinit_board(mine, ROWS, COLS, &#39;0&#39;);\n\tinit_board(show, ROWS, COLS, &#39;*&#39;);\n\t&#x2F;&#x2F; print_board(mine, ROW, COL);\n\tprint_board(show, ROW, COL);\n\t&#x2F;&#x2F; 布置雷\n\tadd_mine(mine, ROW, COL);\n\tprint_board(mine, ROW, COL);\n\n\t&#x2F;&#x2F; 扫雷\n\tdown_mine(mine, show, ROW, COL);\n&#125;\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入扫雷游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tprintf(&quot;游戏结束：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tSleep(1000);\n\t\t\tsystem(&quot;cls&quot;);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<ul>\n<li>只要我们分别在另外两个 .c 文件（一个是主函数体一个是函数定义）中引入（#include “game.h”） 那么三个文件就相互作用了。</li>\n</ul>\n<h1 id=\"二-游戏版面与开始游戏的构建\"><a href=\"#二-游戏版面与开始游戏的构建\" class=\"headerlink\" title=\"二. 游戏版面与开始游戏的构建\"></a>二. 游戏版面与开始游戏的构建</h1><ul>\n<li>我们首先要打印一个菜单供玩家选择&lt;输入1&gt;则进入游戏，&lt;输入0&gt;则退出游戏，&lt;输入其它的数&gt;则输入错误，然后继续输入判断。为了一开始就让用户先选择，再判断输入的值然后判断是否再次输入，这里我们采用do-while循环结构，无论如何用户先选择一次，然后do-while里头采用switch-case来判断输入的值，而菜单我们调用一个menu（）函数来打印，下面是在主函数里的代码实现：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  1.PLAY  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  0.EXIT  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n&#125;\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入扫雷游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tprintf(&quot;游戏结束：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<p><img src=\"https://img-blog.csdnimg.cn/02506d47a9564f16a76b8278380fcdb4.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>我们可以看到， 这样简易的游戏初始菜单就制作好啦。</li>\n</ul>\n<h1 id=\"三-扫雷初始化思路\"><a href=\"#三-扫雷初始化思路\" class=\"headerlink\" title=\"三. 扫雷初始化思路\"></a>三. 扫雷初始化思路</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>由上方雷盘可以看到是一个9×9的格子，但是我们在写程序时，如何能够判断9×9边边格子的周围八个格子雷的个数？如果我们定义一个二维数组只给它9行9列这样一个起始雷盘，当我们在扫边边格子的雷的时候，我们可能会需要一些复杂的计算来完成相关的程序，所以，为了更好的简易化以及能够精确判断每个格子周围的雷，我们在雷盘两边再加上两行两列，也就是说，我们定义的二维数组他应该是要11行11列这样的起始雷盘。</li>\n<li>我们游戏的雷盘是9×9的，但我们定义的二维数组是11×11的，所以，当我们在玩游戏时，被扫的雷盘的打印应该少去上下两行和左右两列。</li>\n<li>对于程序来说，我们是否能够将布置雷盘与扫雷放在一个盘里实现呢？答案是不能的，所以这里我们要定义两个二维数组，一个用来放雷的盘不打印，另一个用来排查雷的盘要打印，并且，这两个盘之间一定要能通过某种联系来相互作用（雷盘传雷位置，扫雷盘接受，扫时能够准确定位周围雷的个数）。</li>\n<li>这里我们设定，雷用字符 ‘1’ 来表示，其余地方为字符 ‘0’ ，刚开始初始化盘时，要布置雷的盘先全部元素放 ‘0’ ，用来扫雷的盘全部元素放字符 ‘ * ’ ，但是我们打印时，只打印9×9那块的区域（游戏版面设定）。</li>\n</ul></blockquote>\n<h1 id=\"四-雷阵与扫雷盘初始化\"><a href=\"#四-雷阵与扫雷盘初始化\" class=\"headerlink\" title=\"四. 雷阵与扫雷盘初始化\"></a>四. 雷阵与扫雷盘初始化</h1><p>*由上说到，雷阵我们先全部放入字符 ‘0’ 初始化，扫雷盘全初始化字符 ‘ * ’，由于两个盘的数组大小相同，为了减少代码量，这里写个初始化函数调用两次（雷阵初始化的调用和扫雷盘初始化的调用），所以我们需要传参每个盘的初始化内容（字符）。<br>以下是代码实现：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">init_board(mine, ROWS, COLS, &#39;0&#39;); &#x2F;&#x2F; 雷阵的初始化\ninit_board(show, ROWS, COLS, &#39;*&#39;); &#x2F;&#x2F; 扫雷盘的初始化</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void init_board(char board[ROWS][COLS], int rows, int cols, char ret) &#x2F;&#x2F; 接收传来的初始化字符\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; rows; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; cols; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; ret; &#x2F;&#x2F; 初始化\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"五-打印扫雷盘\"><a href=\"#五-打印扫雷盘\" class=\"headerlink\" title=\"五. 打印扫雷盘\"></a>五. 打印扫雷盘</h1><ul>\n<li>在我们玩扫雷游戏中，其显示的是9×9的格子，所以我们打印的扫雷盘也是要9×9的格子（尽管初始化二维数组为11×11，那是因为便于计算扫的周围那个格子周围的雷数），但是为了玩家更好的看清楚想要扫的格子的坐标，这里在打印的每行每列开头都标上序号，这样就不用去数格子了。</li>\n<li>以下是打印出来的效果：<br><img src=\"https://img-blog.csdnimg.cn/bd92f89ef783488eaee3c9fe5e3f587b.png#pic_center\" alt=\"在这里插入图片描述\"><br>以下是代码实现：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">print_board(show, ROW, COL); &#x2F;&#x2F; ROW &#x3D; 9 ； COL &#x3D; 9</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void print_board(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (j &#x3D; 0; j &lt;&#x3D; row; j++) &#x2F;&#x2F; 打印列的序号\n\t&#123;\n\t\tprintf(&quot;%d &quot;, j);\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\tfor (i &#x3D; 1; i &lt;&#x3D; row; i++)\n\t&#123;\n\t\tprintf(&quot;%d&quot;, i); &#x2F;&#x2F; 每打印一行初始化打印对应行数的序号\n\t\tfor (j &#x3D; 1; j &lt;&#x3D; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot; %c&quot;, board[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"六-布置雷\"><a href=\"#六-布置雷\" class=\"headerlink\" title=\"六. 布置雷\"></a>六. 布置雷</h1><ul>\n<li>布置雷这一步骤需要在雷阵实现，这里规定布置十个雷，由于我们每一把游戏的雷的位置是不同的（随机的），所以布置雷这一步骤需要电脑的随机性来布置，相应函数的使用为 rand，srand（为了使rand随机化需要用到的），time（时间戳），具体的介绍在上一节”C语言实现初级三子棋“有说到，所以这里便不再详细道来。</li>\n<li>由于是坐标定位，所以这里我们定义两个变量来接受电脑产生的随机值以作为二维数组的坐标来放置雷。</li>\n<li>电脑随机布置时，我们应该使用循环让电脑不断布置，当选中的格子是 ‘0’ ，便放雷，这样的动作做十次，但如果有重复就会另外找位置布置，所以实际上循环可能不止十次。</li>\n<li>每随机布置一个雷，我们便在初始化为字符 ‘0’ 的雷阵并且随机选中布置雷的格子上放上字符 ‘1’ ，这样我们便能分清楚雷与不是雷的区别，这样也有益于后面扫雷阶段的实现。</li>\n<li>由于是在9×9的范围来布置雷，所以这里我们需要限定电脑随机产生值的范围。</li>\n<li>当然如果想要看看布置雷的效果，在布置完后可以打印一下雷阵，但最终我们是不会打印的。<br>以下是代码实现（代码展现是本模块的全部代码实现的展现，与其他功能的结构组合须看全代码）（也就是这三段代码是分开的）：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">add_mine(mine, ROW, COL); </code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">srand((unsigned int)time(NULL));</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void add_mine(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint count &#x3D; 0;\n\n\twhile (count &lt; MINE_COUNT) &#x2F;&#x2F; MINE_COUNT  &#x3D; 10（雷的个数） \n\t&#123;\n\t\tint x &#x3D; rand() % row + 1;\n\t\tint y &#x3D; rand() % col + 1;\n\n\t\tif (board[x][y] &#x3D;&#x3D; &#39;0&#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;1&#39;;\n\t\t\tcount++; &#x2F;&#x2F; 每布置一个计数一次\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"七-扫雷\"><a href=\"#七-扫雷\" class=\"headerlink\" title=\"七. 扫雷\"></a>七. 扫雷</h1><ul>\n<li>我们通过坐标选择需要扫的格子，当格子里的字符不是 ’1‘ 时，计算周围八个格子的雷数，值得注意的是，我们的选择和计算判断过程都是需要在雷阵盘上完成，但是我们展现出来的是这个格子周围的雷数，这就需要扫雷盘和雷盘建立起联系，一个计算分析判断，另一个接受展示，所以我们在写这么一个扫雷的函数时，两个盘的相关消息都要传递过去，这样便于两盘之间的相互联系，从而达到扫雷效果。<br>下面是代码展示：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">down_mine(mine, show, ROW, COL); &#x2F;&#x2F; 一个盘计算判断，另一个接受展示</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int around_mine(char mine[ROWS][COLS], int x, int y)\n&#123;\n\treturn (mine[x][y + 1] + mine[x][y - 1] + mine[x + 1][y] + mine[x - 1][y] + mine[x - 1][y - 1] + mine[x + 1][y + 1] + mine[x - 1][y + 1] + mine[x + 1][y - 1] - 8 * &#39;0&#39;);\n&#125;\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\tint count &#x3D; 0;\n\n\twhile (1)\n\t&#123;\n\t\tprintf(&quot;请输入要扫雷的坐标：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col)\n\t\t&#123;\n\t\t\tif (mine[x][y] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;很遗憾，你被炸死了！\\n&quot;);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tint ret &#x3D; around_mine(mine, x, y);\n\t\t\t\tshow[x][y] &#x3D; ret + &#39;0&#39;;\n\t\t\t\tcount++;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标不合法，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\n\t\tif (count &#x3D;&#x3D; ((row * col) - MINE_COUNT))\n\t\t&#123;\n\t\t\tprintf(&quot;扫雷成功！\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n<p>可以看到，这里面又使用了一次函数定义调用，这次定义调用是为了计算周围的雷数，而我们扫雷盘上放的是字符，那么雷数如何转化到字符，这需要字符与整型数字之间的转化关系来完成。具体可看ASCLL码表。</p>\n<h1 id=\"八-整个程序的代码实现：\"><a href=\"#八-整个程序的代码实现：\" class=\"headerlink\" title=\"八. 整个程序的代码实现：\"></a>八. 整个程序的代码实现：</h1><ul>\n<li>game.h：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 9\n#define COL 9\n#define ROWS ROW + 2\n#define COLS COL + 2\n#define MINE_COUNT 10\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret);\n\nvoid print_board(char board[ROWS][COLS], int row, int col);\n\nvoid add_mine(char board[ROWS][COLS], int row, int col);\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);</code></pre>\n<ul>\n<li>test.c(主函数)（框架结构）：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n\n&#x2F;&#x2F; 1.初始化雷盘与扫雷盘\n&#x2F;&#x2F; 2.打印盘\n&#x2F;&#x2F; 3.布置雷\n&#x2F;&#x2F; 4.扫雷\n\n#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  1.PLAY  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;&gt;  0.EXIT  &lt;&lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n\tprintf(&quot;****************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar mine[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\tchar show[ROWS][COLS] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F; 初始化盘\n\tinit_board(mine, ROWS, COLS, &#39;0&#39;);\n\tinit_board(show, ROWS, COLS, &#39;*&#39;);\n\t&#x2F;&#x2F; print_board(mine, ROW, COL);\n\tprint_board(show, ROW, COL);\n\t&#x2F;&#x2F; 布置雷\n\tadd_mine(mine, ROW, COL);\n\t&#x2F;&#x2F; print_board(mine, ROW, COL);\n\n\t&#x2F;&#x2F; 扫雷\n\tdown_mine(mine, show, ROW, COL);\n&#125;\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入扫雷游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tprintf(&quot;游戏结束：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tSleep(1000);\n\t\t\tsystem(&quot;cls&quot;);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;</code></pre>\n<ul>\n<li>game.c(函数的定义：模块功能的实现)：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n\n#include &quot;game.h&quot;\n\nvoid init_board(char board[ROWS][COLS], int rows, int cols, char ret)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; rows; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; cols; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; ret;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid print_board(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (j &#x3D; 0; j &lt;&#x3D; row; j++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, j);\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\tfor (i &#x3D; 1; i &lt;&#x3D; row; i++)\n\t&#123;\n\t\tprintf(&quot;%d&quot;, i);\n\t\tfor (j &#x3D; 1; j &lt;&#x3D; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot; %c&quot;, board[i][j]);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nvoid add_mine(char board[ROWS][COLS], int row, int col)\n&#123;\n\tint count &#x3D; 0;\n\n\twhile (count &lt; MINE_COUNT)\n\t&#123;\n\t\tint x &#x3D; rand() % row + 1;\n\t\tint y &#x3D; rand() % col + 1;\n\n\t\tif (board[x][y] &#x3D;&#x3D; &#39;0&#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;1&#39;;\n\t\t\tcount++;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint around_mine(char mine[ROWS][COLS], int x, int y)\n&#123;\n\treturn (mine[x][y + 1] + mine[x][y - 1] + mine[x + 1][y] + mine[x - 1][y] + mine[x - 1][y - 1] + mine[x + 1][y + 1] + mine[x - 1][y + 1] + mine[x + 1][y - 1] - 8 * &#39;0&#39;);\n&#125;\n\nvoid down_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\tint count &#x3D; 0;\n\n\twhile (1)\n\t&#123;\n\t\tprintf(&quot;请输入要扫雷的坐标：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col)\n\t\t&#123;\n\t\t\tif (mine[x][y] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;很遗憾，你被炸死了！\\n&quot;);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tint ret &#x3D; around_mine(mine, x, y);\n\t\t\t\tshow[x][y] &#x3D; ret + &#39;0&#39;;\n\t\t\t\tcount++;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标不合法，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\n\t\tif (count &#x3D;&#x3D; ((row * col) - MINE_COUNT))\n\t\t&#123;\n\t\t\tprintf(&quot;扫雷成功！\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九. 总结\"></a>九. 总结</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>咱们这里实现的扫雷只是初级的，游戏里点击一个格子它可能扫出一大块，这需要更复杂的算法来实现，所以扫雷小游戏值得我们继续研究，这可以提高我们的思维和能力。</li>\n<li>经过扫雷和三子棋两个小游戏的对比，我们可以发现其相同点和不同点，其算法的差异和框架的异同，独自完成这两个简易的小游戏可以大大提高我们的思维能力和代码的敏感性，建议大家能够独自完成。</li>\n</ul></blockquote>\n<ul>\n<li>本章到此结束，谢谢大家。</li>\n</ul>\n","text":"一. 前言 本章我们用C语言简单实现一个9×9雷阵的扫雷小游戏。 说到扫雷想必大家都不陌生，开始我们点击一个小方块，那么这个小方块上会显示它周围八个小方块里雷的个数，凭借这个数值，在判断下一个要扫的位置（当然可能前面两步需要我们的幸运成分了），当我们除雷外的所有小方块都已经显示完...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":14,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":14,"path":"api/tags/C语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">一. 前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E6%B8%B8%E6%88%8F%E7%89%88%E9%9D%A2%E4%B8%8E%E5%BC%80%E5%A7%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%9E%84%E5%BB%BA\"><span class=\"toc-text\">二. 游戏版面与开始游戏的构建</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89-%E6%89%AB%E9%9B%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">三. 扫雷初始化思路</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E9%9B%B7%E9%98%B5%E4%B8%8E%E6%89%AB%E9%9B%B7%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">四. 雷阵与扫雷盘初始化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94-%E6%89%93%E5%8D%B0%E6%89%AB%E9%9B%B7%E7%9B%98\"><span class=\"toc-text\">五. 打印扫雷盘</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AD-%E5%B8%83%E7%BD%AE%E9%9B%B7\"><span class=\"toc-text\">六. 布置雷</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%83-%E6%89%AB%E9%9B%B7\"><span class=\"toc-text\">七. 扫雷</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AB-%E6%95%B4%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">八. 整个程序的代码实现：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B9%9D-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">九. 总结</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"一文带你灵活使用C语言的数组","uid":"b82bfb4a02f130e6ce0f96366fdc8a1f","slug":"一文带你灵活使用C语言的数组","date":"2023-02-17T14:38:44.000Z","updated":"2023-02-18T02:57:53.229Z","comments":true,"path":"api/articles/一文带你灵活使用C语言的数组.json","keywords":null,"cover":[],"text":"一. 什么是数组？ 数组是由数据类型相同的一系列元素组成的。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确的创建数组。普通变量可以使用的类型，数组元素都可以使用。 二. 一维数组1. 一维数组的创建和初始化1.1. 一维数组的创建...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":14,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":14,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}}},"next_post":{"title":"C语言的分支与循环#熟练使用，出手就有#","uid":"e0b663ff8593ec90044339189f2bc842","slug":"C语言的分支与循环-熟练使用，出手就有","date":"2023-02-17T14:08:48.000Z","updated":"2023-02-18T02:58:41.363Z","comments":true,"path":"api/articles/C语言的分支与循环-熟练使用，出手就有.json","keywords":null,"cover":[],"text":"一. 前言 分支和循环在C语言中几乎无处不在，作为重要的一部分，精确掌握其语法和运用逻辑，是继续向下学习的“地基”。 二. 分支语句1. if 分支语句if 就是如果，如果怎么怎么样就干嘛干嘛，在C语言中，其表达效果也是如此。 if (表达式) &#x2F;&#x2F; 表达式为...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":14,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":14,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}}}}