{"title":"【数据结构与算法】算法的时间复杂度和空间复杂度","uid":"73ff783753dfb9187579f115eb370182","slug":"【数据结构与算法】算法的时间复杂度和空间复杂度","date":"2023-03-03T15:45:47.000Z","updated":"2023-03-03T15:48:47.845Z","comments":true,"path":"api/articles/【数据结构与算法】算法的时间复杂度和空间复杂度.json","keywords":null,"cover":"/photo/屏幕截图_20230122_043306.png","content":"<hr>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/482466d9c360ed28cda1a31e21ac16db.jpeg#pic_center\" alt=\"在这里插入图片描述\"></p>\n<hr>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>关于时空复杂度的分析，是每一个程序员的必备技能，本文将带你了解什么是时空复杂度？熟知怎样去计算一个算法的<code>时间复杂度</code>和<code>空间复杂度</code>。</strong></p></blockquote>\n<hr>\n<h1 id=\"1-算法效率\"><a href=\"#1-算法效率\" class=\"headerlink\" title=\"1.算法效率\"></a>1.算法效率</h1><h2 id=\"1-1-如何衡量一个算法的好坏\"><a href=\"#1-1-如何衡量一个算法的好坏\" class=\"headerlink\" title=\"1.1.如何衡量一个算法的好坏\"></a>1.1.如何衡量一个算法的好坏</h2><p>如何衡量一个算法的好坏呢？我们先看一段代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int Fib(int N)\n&#123;\n    if(N &lt; 3)\n        return 1;\n      \n    return Fib(N-1) + Fib(N-2);\n&#125;</code></pre>\n\n<ul>\n<li><p>这段代码是计算第<code>N</code>个斐波那契数列的数是多少，可以看到，此算法采用的是递归，代码简洁，但简洁一定就好么？那么我们又该如何衡量其好坏呢？</p>\n</li>\n<li><p>我们可以通过对代码的复杂度进行分析，从而得出其时间效率和空间效率，依此来衡量其好坏。</p>\n</li>\n</ul>\n<h2 id=\"1-2-算法的复杂度\"><a href=\"#1-2-算法的复杂度\" class=\"headerlink\" title=\"1.2.算法的复杂度\"></a>1.2.算法的复杂度</h2><ul>\n<li><p>算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即<font color=red size=4>时间复杂度</font>和<font color=red size=4>空间复杂度</font>。</p>\n</li>\n<li><p>时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。</p>\n</li>\n<li><p>一般的，越复杂的代码，我们越难去计算其时间复杂度和空间复杂度， 这就需要我们长期的练习来增强我们对复杂度的敏感度以及对一个题目如何找出最优解的思想。</p>\n</li>\n<li><p>可能我们在平时写代码的时候，难以体会到复杂度好坏对程序的影响，但如果是一个大型项目，复杂度的好坏就显得尤为重要，这直接关乎到用户体验感的好坏，因此，一个程序复杂度的好坏是很重要的 。</p>\n</li>\n</ul>\n<h1 id=\"2-时间复杂度\"><a href=\"#2-时间复杂度\" class=\"headerlink\" title=\"2.时间复杂度\"></a>2.时间复杂度</h1><h2 id=\"2-1-时间复杂度的概念\"><a href=\"#2-1-时间复杂度的概念\" class=\"headerlink\" title=\"2.1.时间复杂度的概念\"></a>2.1.时间复杂度的概念</h2><p><strong><font color=red>时间复杂度的定义</font>：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。<font color=blue size=4>一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。</strong></p>\n<p><strong><font color=red size=4>即</font>：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。</strong></p>\n<p>&#x3D;&#x3D;例如&#x3D;&#x3D;：<br>&lt;请计算一下<code>Func1</code>中<code>++count</code>语句总共执行了多少次？&gt;</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void Func1(int N)\n&#123;\n\tint count &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; N ; ++ i)\n\t&#123;\n \t\tfor (int j &#x3D; 0; j &lt; N ; ++ j)\n \t\t&#123;\n \t\t\t++count;\n \t\t&#125;\n\t&#125;\n \n\tfor (int k &#x3D; 0; k &lt; 2 * N ; ++ k)\n\t&#123;\n \t\t++count;\n\t&#125;\n\tint M &#x3D; 10;\n\twhile (M--)\n\t&#123;\n \t\t++count;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;, count);\n&#125;</code></pre>\n\n\n<p><code>Func1</code> 执行的基本操作次数 ：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7f942cab6cb94336aa98e3ff55d9c8e9.png\" alt=\"在这里插入图片描述\"><br><strong>当<code>N</code>为不同值时，对应的次数：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">N &#x3D; 10    F(N) &#x3D; 130\nN &#x3D; 100   F(N) &#x3D; 10210\nN &#x3D; 1000  F(N) &#x3D; 1002010</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>但是，实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要&#x3D;&#x3D;大概执行次数&#x3D;&#x3D;，那么这里我们使用&#x3D;&#x3D;大O的渐进表示法&#x3D;&#x3D;。</p></blockquote>\n<h2 id=\"2-2-大O的渐进表示法\"><a href=\"#2-2-大O的渐进表示法\" class=\"headerlink\" title=\"2.2.大O的渐进表示法\"></a>2.2.大O的渐进表示法</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><font size=4><strong>大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。</strong></p></blockquote>\n<p><strong>推导大O阶方法：</strong></p>\n<ol>\n<li>用常数<code>1</code>取代运行时间中的所有加法常数。</li>\n<li>在修改后的运行次数函数中，只<strong>保留最高阶项</strong>。</li>\n<li>如果最高阶项存在且不是<code>1</code>，则<strong>去除与这个项目相乘的常数</strong>。得到的结果就是大O阶。</li>\n</ol>\n<p>使用大O的渐进表示法以后，<code>Func1</code>的时间复杂度为:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">N &#x3D; 10    F(N) &#x3D; 100\nN &#x3D; 100   F(N) &#x3D; 10000\nN &#x3D; 1000  F(N) &#x3D; 1000000</code></pre>\n\n\n<p>通过上面我们会发现大<code>O</code>的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。另外有些算法的时间复杂度存在<code>最好</code>、<code>平均</code>和<code>最坏</code>情况：</p>\n<ul>\n<li>最坏情况：任意输入规模的最大运行次数(上界)</li>\n<li>平均情况：任意输入规模的期望运行次数</li>\n<li>最好情况：任意输入规模的最小运行次数(下界)</li>\n</ul>\n<p><font color=red>例如</font>：在一个长度为<code>N</code>数组中搜索一个数据<code>x</code></p>\n<ol>\n<li>最好情况：<code>1</code>次找到</li>\n<li>最坏情况：<code>N</code>次找到</li>\n<li>平均情况：<code>N/2</code>次找到</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><font size=4><strong>在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)</strong></p></blockquote>\n<h2 id=\"2-3-常见时间复杂度计算举例\"><a href=\"#2-3-常见时间复杂度计算举例\" class=\"headerlink\" title=\"2.3.常见时间复杂度计算举例\"></a>2.3.常见时间复杂度计算举例</h2><p><font color=red>实例1</font>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void Func2(int N)\n&#123;\n\t int count &#x3D; 0;\n\t for (int k &#x3D; 0; k &lt; 2 * N ; ++ k)\n\t &#123;\n\t \t++count;\n\t &#125;\n\t int M &#x3D; 10;\n\t while (M--)\n\t &#123;\n\t \t++count;\n\t &#125;\n\t printf(&quot;%d\\n&quot;, count);\n&#125;</code></pre>\n\n\n<p><img src=\"https://img-blog.csdnimg.cn/2c70a457f4914c599309af4aac4d85a2.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red>实例2</font>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void Func3(int N, int M)\n&#123;\n\t int count &#x3D; 0;\n\t for (int k &#x3D; 0; k &lt; M; ++ k)\n\t &#123;\n\t \t++count;\n\t &#125;\n\t for (int k &#x3D; 0; k &lt; N ; ++ k)\n\t &#123;\n\t \t++count;\n\t &#125;\n\t printf(&quot;%d\\n&quot;, count);\n&#125;</code></pre>\n\n\n<p><img src=\"https://img-blog.csdnimg.cn/67693eb1562c4497aaeb3f3d05c8614c.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red>实例3</font>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void Func4(int N)\n&#123;\n\t int count &#x3D; 0;\n\t for (int k &#x3D; 0; k &lt; 100; ++ k)\n\t &#123;\n\t \t++count;\n\t &#125;\n\t printf(&quot;%d\\n&quot;, count);\n&#125;</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>这里<code>count</code>只加了<code>100</code>次，对于是常数次的情况，一律为<code>O(1)</code>;</strong></p></blockquote>\n<p><font color=red>实例4</font>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 计算strchr的时间复杂度？\nconst char * strchr ( const char * str, int character );</code></pre>\n\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>该例子基本操作执行最好<code>1</code>次，最坏<code>N</code>次，时间复杂度一般看最坏，时间复杂度为 O(N)</strong></p></blockquote>\n<p><font color=red>实例5</font>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 计算BubbleSort的时间复杂度？\nvoid BubbleSort(int* a, int n)\n&#123;\n\t assert(a);\n\t for (size_t end &#x3D; n; end &gt; 0; --end)\n\t &#123;\n\t \tint exchange &#x3D; 0;\n\t \tfor (size_t i &#x3D; 1; i &lt; end; ++i)\n\t \t&#123;\n\t \t\tif (a[i-1] &gt; a[i])\n\t \t\t&#123;\n\t \t\t\tSwap(&amp;a[i-1], &amp;a[i]);\n\t \t\t\texchange &#x3D; 1;\n\t \t\t&#125;\n\t \t&#125;\n\t \tif (exchange &#x3D;&#x3D; 0)\n\t \t\tbreak;\n\t &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> <strong>实例5基本操作执行最好<code>N</code>次，最坏执行了<code>N*(N+1)/2</code>次，通过推导大<code>O</code>阶方法<code>+</code>时间复杂度一般看最<br>坏，时间复杂度为 <code>O(N^2)</code></strong></p></blockquote>\n<p><font color=red>实例6</font>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 计算BinarySearch的时间复杂度？\nint BinarySearch(int* a, int n, int x)\n&#123;\n\t assert(a);\n\t int begin &#x3D; 0;\n\t int end &#x3D; n-1;\n\t &#x2F;&#x2F; [begin, end]：begin和end是左闭右闭区间，因此有&#x3D;号\n\t while (begin &lt;&#x3D; end)\n\t &#123;\n\t \tint mid &#x3D; begin + ((end-begin)&gt;&gt;1);\n\t \tif (a[mid] &lt; x)\n\t \t\tbegin &#x3D; mid+1;\n\t \telse if (a[mid] &gt; x)\n\t \t\tend &#x3D; mid-1;\n\t \telse\n\t \t\treturn mid;\n\t &#125;\n\t return -1;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> <strong>该例子基本操作执行最好<code>1</code>次，最坏<code>O(logN)</code>次，时间复杂度为 <code>O(logN)</code></strong><br>  **&#x3D;&#x3D;注意：&#x3D;&#x3D; logN在算法分析中表示是底数为<code>2</code>，对数为<code>N</code>。有些地方会写成<code>lgN</code>**。（建议通过折纸查找的方式讲解logN是怎么计算出来的）</p></blockquote>\n<p>**此算法为二分查找：通过与目标数的大小的比较，每次将搜索范围<code>除以2</code>，这种算法时间效率非常的高，但前提是，查找的数组是要有序的。也因此该算法很少被用到，因为要将一个数组排序，一般最低的时间效率为<code>O(N*logN)</code>**。</p>\n<p><font color=red>实例7</font>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;计算一个数的阶乘递归写法\nint Fac(size_t N)\n&#123;\n\t if(0 &#x3D;&#x3D; N)\n\t \treturn 1;\n\t \n\t return Fac(N-1)*N;\n&#125;</code></pre>\n\n\n<p><img src=\"https://img-blog.csdnimg.cn/4b45463ce74848e691f86bdc5b7072b3.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red>实例8</font>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 计算斐波那契递归Fib的时间复杂度？\nint Fib(size_t N)\n&#123;\n \tif(N &lt; 3)\n \t\treturn 1;\n \n \treturn Fib(N-1) + Fib(N-2);\n&#125;</code></pre>\n\n\n<p><img src=\"https://img-blog.csdnimg.cn/bbebe9890ac5433e824673b0bfd6da37.png\" alt=\"在这里插入图片描述\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>该例子通过计算分析发现基本操作递归了<code>2^N</code>次，时间复杂度为<code>O(2^N)</code>。</strong></p></blockquote>\n<h2 id=\"2-4-常见时间复杂度\"><a href=\"#2-4-常见时间复杂度\" class=\"headerlink\" title=\"2.4.常见时间复杂度\"></a>2.4.常见时间复杂度</h2><p><img src=\"https://img-blog.csdnimg.cn/546985fc3ca948d8babc6dcf058bef9f.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7c386be71da247cb87650474b21ef7d1.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"3-空间复杂度\"><a href=\"#3-空间复杂度\" class=\"headerlink\" title=\"3.空间复杂度\"></a>3.空间复杂度</h1><ul>\n<li><strong>空间复杂度也是一个数学表达式，是对一个算法在运行过程中<font color=red size=4>临时</font>占用存储空间大小的量度。</strong></li>\n<li><strong>空间复杂度不是程序占用了多少<code>bytes</code>的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟实践复杂度类似，也使用<font color=red size=4>大O渐进表示法</font>。</strong></li>\n</ul>\n<p><font color=red size=4>注意</font>：函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的<font color=red size=4>额外空间</font>来确定。</p>\n<p><font color=red size=4>示例1：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 计算BubbleSort的空间复杂度？\nvoid BubbleSort(int* a, int n)\n&#123;\n\t assert(a);\n\t for (size_t end &#x3D; n; end &gt; 0; --end)\n\t &#123;\n\t \tint exchange &#x3D; 0;\n\t \tfor (size_t i &#x3D; 1; i &lt; end; ++i)\n\t \t&#123;\n\t \t\tif (a[i-1] &gt; a[i])\n\t \t\t&#123;\n\t \t\t\tSwap(&amp;a[i-1], &amp;a[i]);\n\t \t\t\texchange &#x3D; 1;\n\t \t\t&#125;\n\t \t&#125;\n\t \tif (exchange &#x3D;&#x3D; 0)\n\t \t\tbreak;\n\t &#125;\n&#125;</code></pre>\n\n\n<p><img src=\"https://img-blog.csdnimg.cn/721ad9b7731c4091b7a175f7881ae27d.png\" alt=\"在这里插入图片描述\"></p>\n<p><font color=red size=4>示例2：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 计算Fibonacci的空间复杂度？\n&#x2F;&#x2F; 返回斐波那契数列的前n项\nlong long* Fibonacci(size_t n)\n&#123;\n\t if(n&#x3D;&#x3D;0)\n\t \treturn NULL;\n\t \n\t &#x2F;&#x2F; 这里开辟了n + 1个空间\n\t long long * fibArray &#x3D; (long long *)malloc((n+1) * sizeof(long long));\n\t fibArray[0] &#x3D; 0;\n\t fibArray[1] &#x3D; 1;\n\t for (int i &#x3D; 2; i &lt;&#x3D; n ; ++i)\n\t &#123;\n\t \tfibArray[i] &#x3D; fibArray[i - 1] + fibArray [i - 2];\n\t &#125;\n\t return fibArray;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 该示例动态开辟了<code>N + 1</code>个空间，空间复杂度为 <code>O(N)</code></p></blockquote>\n<p><font color=red size=4>示例3：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 计算阶乘递归Fac的空间复杂度？\nint Fac(size_t N)\n&#123;\n\t if(N &#x3D;&#x3D; 0)\n\t \treturn 1;\n\t \n\t return Fac(N-1)*N;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>该示例递归调用了<code>N</code>次，开辟了<code>N</code>个栈帧，每个栈帧使用了常数个空间。空间复杂度为<code>O(N)</code></p></blockquote>\n<h1 id=\"4-复杂度oj练习\"><a href=\"#4-复杂度oj练习\" class=\"headerlink\" title=\"4.复杂度oj练习\"></a>4.复杂度oj练习</h1><h2 id=\"Practice-1-消失的数字\"><a href=\"#Practice-1-消失的数字\" class=\"headerlink\" title=\"Practice.1 消失的数字\"></a><font color=red>Practice.1</font> 消失的数字</h2><p>相关题目链接：<a href=\"https://leetcode.cn/problems/missing-number-lcci/\">Let’ s go!</a></p>\n<ul>\n<li>这道题如果是暴力解法的话，最坏是<code>O(N^2)</code>：将<code>0~n</code>中的每一个数在数组中遍历一次，如果在数组中没有找到与这个数相等的数，那这个数就是消失的数字；</li>\n<li>由于只缺失了一个数，所以这里我们可以分别对<code>数组</code>和<code>0~n</code>个数进行求和，相减既是那个消失的数。整个过程，两个<code>for</code>循环，第一个遍历数组为<code>n</code>次，第二个为<code>n + 1</code>次，因此时间复杂度为：<code>O(N)</code>， 而这里创建的变量为常数，因此空间复杂度为：<code>O(1)</code>。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int missingNumber(int* nums, int numsSize)&#123;\n    int sum1 &#x3D; 0, sum2 &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; numsSize; i++) sum1 +&#x3D; nums[i];\n    for (int i &#x3D; 0; i &lt;&#x3D; numsSize; i++) sum2 +&#x3D; i;\n    return sum2 - sum1;\n&#125;</code></pre>\n\n<ul>\n<li>由题，遍历<code>数组</code>和遍历<code>0~n</code>,其中只有那个消失的数遍历了一次，其它的数都出现了两次，因此我们可以对<code>数组</code>和<code>0~n</code>个数同时 <code>按位异或</code> （如果两个相同的数异或，结果为0， 任意一个数与0异或结果都是这个数本身）来找出那个消失的数。整个过程很容易看出时间复杂度为：<code>O(N)</code>,空间复杂度为：<code>O(1)</code>.</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int missingNumber(int* nums, int numsSize)&#123;\n    int ret &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; numsSize; i++) ret ^&#x3D; nums[i];\n    for (int i &#x3D; 1; i &lt;&#x3D; numsSize; i++) ret ^&#x3D; i;\n    return ret;\n&#125;</code></pre>\n\n\n\n<h2 id=\"Practice-2-旋转数组\"><a href=\"#Practice-2-旋转数组\" class=\"headerlink\" title=\"Practice.2 旋转数组\"></a><font color=red>Practice.2</font> 旋转数组</h2><p>相关题目链接：<a href=\"https://leetcode.cn/problems/rotate-array/\">Let’ s go!</a></p>\n<ul>\n<li><p>该题如果是依次挪动数据的话，最坏的情况是<code>k = n（数组长度）- 1</code>，此时为<code>（n - 1） * n</code>, 因此时间复杂度为<code>O(N)</code>,空间复杂度为：<code>O(1)</code>;</p>\n</li>\n<li><p>比较容易想到的提高时间效率的算法：我们可以使用额外的数组来将每个元素放至正确的位置，要挪动的数依次放入开辟的数组的前面，然后再将前面不旋转的数放置开辟的数组的后面，这样是以空间换时间，所以整体时间复杂度为：<code>O(N)</code>,空间复杂度为：<code>O(N)</code>。</p>\n</li>\n<li><p>难想到的一种算法是：先将前<code>n(为数组长度)-k</code>个数翻转，再将后<code>k</code>个数翻转，最后整体翻转。这样的话，能够将整段代码的效率升至最高，时间复杂度为：<code>O(N)</code>,空间复杂度为：<code>O(1)</code>.<br><font color=red>代码实现</font>：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void reverse(int* a, int l, int r)\n&#123;\n    assert(a);\n    while (l &lt; r)\n    &#123;\n        int tmp &#x3D; a[l];\n        a[l] &#x3D; a[r];\n        a[r] &#x3D; tmp;\n        l++;\n        r--;\n    &#125;\n&#125;\n\nvoid rotate(int* nums, int numsSize, int k)&#123;\n    k %&#x3D; numsSize;\n    reverse(nums, 0, numsSize - k - 1);\n    reverse(nums, numsSize - k, numsSize - 1);\n    reverse(nums, 0, numsSize - 1);\n&#125;</code></pre>\n\n\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对一段代码的时间复杂度和空间复杂度的分析熟练度客观上体现了你的算法水平，因此，我们在学好算法的道路上要一步一个脚印，切不可投机取巧。</p></blockquote>\n<p><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></p>\n","feature":null,"text":" 前言 关于时空复杂度的分析，是每一个程序员的必备技能，本文将带你了解什么是时空复杂度？熟知怎样去计算一个算法的时间复杂度和空间复杂度。 1.算法效率1.1.如何衡量一个算法的好坏如何衡量一个算法的好坏呢？我们先看一段代码： int Fib(int N) &#123; if(N ...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87\"><span class=\"toc-text\">1.算法效率</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F\"><span class=\"toc-text\">1.1.如何衡量一个算法的好坏</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">1.2.算法的复杂度</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">2.时间复杂度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.1.时间复杂度的概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95\"><span class=\"toc-text\">2.2.大O的渐进表示法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">2.3.常见时间复杂度计算举例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">2.4.常见时间复杂度</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">3.空间复杂度</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E5%A4%8D%E6%9D%82%E5%BA%A6oj%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">4.复杂度oj练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Practice-1-%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">Practice.1 消失的数字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Practice-2-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">Practice.2 旋转数组</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"【基础算法】关于高精度计算的问题【很高位数数据的加减乘除(相关代码用C++实现)】","uid":"48de73fbd4a7bbcd1c473c6c29503249","slug":"【基础算法】关于高精度计算的问题【很高位数数据的加减乘除-相关代码用C-实现-】","date":"2023-03-03T15:49:06.000Z","updated":"2023-03-03T15:50:14.498Z","comments":true,"path":"api/articles/【基础算法】关于高精度计算的问题【很高位数数据的加减乘除-相关代码用C-实现-】.json","keywords":null,"cover":"/photo/R-C (6).jpeg","text":"前言 当我们在利用计算机进行一些计算时，可能会遇到这类问题 ： 有些计算要求精度高，希望计算的数的位数可达几十位甚至几百位，虽然计算机的计算精度也算较高了，但因受到硬件的限制，往往达不到实际问题所要求的精度。 这时我们就可以通过程序设计来解决这类问题，例如：创建一个数组，通过数组...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"关于常引用的问题","uid":"53f3e274c7bda3bde7e9b295614179bc","slug":"关于常引用的问题-什么是权限放大？权限放小？隐式或强制转换居然还有这一步？","date":"2023-02-18T06:45:14.000Z","updated":"2023-02-18T06:54:00.841Z","comments":true,"path":"api/articles/关于常引用的问题-什么是权限放大？权限放小？隐式或强制转换居然还有这一步？.json","keywords":null,"cover":"/photo/屏幕截图_20230122_040600.png","text":"前言 引用在c++中的使用非常常见，可以说是很重要的，引用的常引用相关的问题让很多人稍不留神就出错了，这里我们就来谈谈常引用的问题。 关于权限 关于权限有权限缩小和权限放大的问题，比如一个文件，当初它只有读的权限，而现在你给它再加个写的权限，这就是权限放大；又或当初它读，写的权限...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"C++阶段相关知识点与问题的深度解析","slug":"C-阶段相关知识点与问题的深度解析","count":1,"path":"api/categories/C-阶段相关知识点与问题的深度解析.json"}],"tags":[{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}}}}