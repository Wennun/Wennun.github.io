{"title":"【数据结构】顺序表","uid":"acb938686160e729bc4dce5cef8311df","slug":"【数据结构】顺序表","date":"2023-03-03T15:53:00.000Z","updated":"2023-03-03T15:55:09.846Z","comments":true,"path":"api/articles/【数据结构】顺序表.json","keywords":null,"cover":"/photo/屏幕截图_20230122_043538.png","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><ul>\n<li><p><font color=blue size=4>顺序表作为数据结构中的小小弟，还是很好应付的</font><font size=4>。说到数据结构，顺序表是我们的向导，它让你明白数据结构到底是干啥的，为啥数据结构这么的重要。</font></p>\n</li>\n<li><p></font><font size=4>实际上，<a href=\"https://blog.csdn.net/Wennytime/article/details/129166848\">通讯录</a>的底层就是一个顺序表，里面的增添联系人，删除联系人等一系列操作，都是基于顺序表实现的，这也侧面拖出了数据结构的作用。所以，学好数据结构是必须的。</p>\n</li>\n<li><p></font><font size=4>要是能够自主实现<a href=\"https://blog.csdn.net/Wennytime/article/details/129166848\">通讯录</a>，我肯定，顺序表学起来会非常的轻松。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"初始化顺序表\"><a href=\"#初始化顺序表\" class=\"headerlink\" title=\"初始化顺序表\"></a>初始化顺序表</h1><ul>\n<li><strong>实现顺序表需要三个文件</strong>：一个是<code>.h</code>为后缀的头文件<code>SeqList.h</code>：用来放相关头文件，宏定义，结构体声明，以及函数声明。一个是<code>.c</code>为后缀的C文件<code>SeqList.c</code>：用来实现函数接口。还有一个是<code>.c</code>为后缀的C文件<code>test.c</code>：用来测试代码。<strong>我们只要在<code>SeqList.c</code>文件和<code>test.c</code>文件最上面包含一下  <code>SeqList.h</code>文件，整个程序链接就OK了。</strong></li>\n</ul>\n<p><font color=red size=4>下面是所需头文件，宏定义，以及顺序表的定义的代码：</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 防止SeqList.h被重复包含\n#pragma once\n\n&#x2F;&#x2F; 所需头文件：\n&#x2F;&#x2F; 输入输出所需头文件\n#include &lt;stdio.h&gt;\n&#x2F;&#x2F; realloc，free所需头文件\n#include &lt;stdlib.h&gt;\n&#x2F;&#x2F; 判空所需头文件\n#include &lt;stdbool.h&gt;\n&#x2F;&#x2F; assert断言所需头文件\n#include &lt;assert.h&gt;\n\n&#x2F;&#x2F; 初始化容量，每次增容也是增加这个数量\n#define INIT_CAPACITY 8\n&#x2F;&#x2F; 这个为顺序表的数据类型\ntypedef int SLDateType;\n\n&#x2F;&#x2F; 顺序表\ntypedef struct SeqList\n&#123;\n\t&#x2F;&#x2F; a指向一个在堆上的空间（就是顺序表）\n\tSLDateType* a;\n\t&#x2F;&#x2F; 顺序表数据个数\n\tint size;\n\t&#x2F;&#x2F; 顺序表容量\n\tint capacity;\n&#125;SL;  &#x2F;&#x2F; typedef将struct SeqList重新命名为SL</code></pre>\n\n\n\n<ul>\n<li>定义好主体后，首先是对顺序表初始化。可以看到，上面的结构体也就是顺序表里面的成员都是未初始化的，所以第一步就是将他们初始化，这里引出一个初始化函数接口，<strong>下面是相关功能代码实现：</strong></li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 初始化顺序表\nvoid SLInit(SL* ps)\n&#123;\n    &#x2F;&#x2F; 这里断言是防止ps为一个空指针（传个NULL直接暴打）\n\tassert(ps);\n\n\tps-&gt;a &#x3D; NULL;\n\tps-&gt;size &#x3D; 0;\n\tps-&gt;capacity &#x3D; 0;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"打印顺序表\"><a href=\"#打印顺序表\" class=\"headerlink\" title=\"打印顺序表\"></a>打印顺序表</h1><ul>\n<li><p>该接口放在前面实现是为了后面能够更好的测试：通过对顺序表的数据的一个直观的展现，我们可以及时发现某些接口的bug。</p>\n</li>\n<li><p>顺序表的结构体中定义了一个<code>size</code>，这里<code>size</code>的作用就体现出来了（当然，<code>size</code>的作用很大，不止是这里），我们可以通过<code>size</code>来对顺序表中的数据顺序打印：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 打印顺序表\nvoid SLPrint(SL* ps)\n&#123;\n\tassert(ps);\n\n\tfor (int i &#x3D; 0; i &lt; ps-&gt;size; i++) printf(&quot;%d &quot;, ps-&gt;a[i]);\n\tprintf(&quot;\\n&quot;);\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"检查容量\"><a href=\"#检查容量\" class=\"headerlink\" title=\"检查容量\"></a>检查容量</h1><ul>\n<li><p>当我们在顺序表中插入数据时，一定要检查容量够不够用，如果不够的话，再插入数据，就会出现非法访问空间的问题，此时程序会报错，因此这里要扩容。</p>\n</li>\n<li><p>由于<code>size</code>是统计数据个数的，所以，只要<code>size</code>等于<code>capacity</code>，就说明当前的容量已经满了，需要扩容。由于初始化顺序表时没有分配空间，所以当我们第一次插入数据的时候就要扩容，每次扩容增加的容量大小为<code>INIT_CAPACITY(8)</code>，而每增容一次，<code>capacity</code>就要更新一次。</p>\n</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 检查容量\nvoid SLCheckCapacity(SL* ps)\n&#123;\n\tassert(ps);\n\n\tif (ps-&gt;size &#x3D;&#x3D; ps-&gt;capacity)\n\t&#123;\n\t\tint newcapacity &#x3D; ps-&gt;capacity &#x3D;&#x3D; 0 ? INIT_CAPACITY : ps-&gt;capacity + INIT_CAPACITY;\n\t\t&#x2F;&#x2F; 开始没有空间，其功能相当于malloc\n\t\tSLDateType* tmp &#x3D; (SLDateType*)realloc(ps-&gt;a, sizeof(SLDateType) * newcapacity);\n\t\tassert(tmp);\n\t\tps-&gt;a &#x3D; tmp;\n\t\tps-&gt;capacity &#x3D; newcapacity;\n\t&#125;\n&#125;</code></pre>\n<p>这一步实现后，每次插入数据就要引用该函数检查一下容量。</p>\n<hr>\n<h1 id=\"判空\"><a href=\"#判空\" class=\"headerlink\" title=\"判空\"></a>判空</h1><ul>\n<li>判空很容易理解，这里如果通讯录为空，返回真，不为空，返回假。</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 判空\nbool SLEmpty(SL* ps)\n&#123;\n\tassert(ps);\n\treturn ps-&gt;size &#x3D;&#x3D; 0;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"顺序表数据个数\"><a href=\"#顺序表数据个数\" class=\"headerlink\" title=\"顺序表数据个数\"></a>顺序表数据个数</h1><ul>\n<li>该功能只要返回<code>size</code>就ok啦。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 顺序表数据个数\nint SLSize(SL* ps)\n&#123;\n\tassert(ps);\n\treturn ps-&gt;size;\n&#125;\n</code></pre>\n\n\n\n\n\n\n<hr>\n<h1 id=\"尾部插入\"><a href=\"#尾部插入\" class=\"headerlink\" title=\"尾部插入\"></a>尾部插入</h1><ul>\n<li>尾部插入就是在最末尾插入数据，首先当然是要检查一下容量，然后将要插入的数据插入进去，最后<code>size</code>计数一次，该函数的功能就OK啦。</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void SLPushBack(SL* ps, SLDateType x)\n&#123;\n\tassert(ps);\n\n\tSLCheckCapacity(ps);\n\n\tps-&gt;a[ps-&gt;size++] &#x3D; x;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"尾部删除\"><a href=\"#尾部删除\" class=\"headerlink\" title=\"尾部删除\"></a>尾部删除</h1><ul>\n<li><p>如果顺序表中没有数据，那还删个啥呢？直接<code>assert</code>暴打，也就是判断一下<code>size</code>是否大于<code>0</code>(判空一下)。</p>\n</li>\n<li><p>尾部删除实际上只要<code>size</code>减一就可以了，至于删除的那个数据改不改为<code>0</code>，都无所谓，因为打印不会打印到那个数据，还有就是，不能在那个位置释放空间（<code>free</code>）,这是规定不允许的，要有占着茅坑不拉屎的原则。</p>\n</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void SLPopBack(SL* ps)\n&#123;\n\tassert(ps &amp;&amp; !SLEmpty(ps));\n\n\tps-&gt;size--;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"头部插入\"><a href=\"#头部插入\" class=\"headerlink\" title=\"头部插入\"></a>头部插入</h1><ul>\n<li><p>对顺序表头部的操作相比于尾部的操作麻烦的多，主要是因为，顺序表是一段连续的空间，在头部插入或者删除需要挪动后面的数据，这样以来，整个程序的效率也会降低，但这是没办法的，该挪动还是嘚挪动，不然怎么进行操作对吧。&#x3D;&#x3D;（顺序表最明显的缺点）&#x3D;&#x3D;</p>\n</li>\n<li><p>挪动的时候，只要从后面开始依次将每一个数据向后挪动一位，直到将第一个数据挪动完停止挪动，再将要插入的数据放在头部即可，这里需要注意以下边界问题。</p>\n</li>\n<li><p>当然<code>size</code>要计数一次，可不敢忘记了。</p>\n</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void SLPushFront(SL* ps, SLDateType x)\n&#123;\n\tassert(ps);\n\n\tSLCheckCapacity(ps);\n\n\tfor (int i &#x3D; ps-&gt;size; i &gt; 0; i--) ps-&gt;a[i] &#x3D; ps-&gt;a[i - 1];\n\tps-&gt;a[0] &#x3D; x;\n\tps-&gt;size++;\n&#125;</code></pre>\n\n\n\n<hr>\n<h1 id=\"头部删除\"><a href=\"#头部删除\" class=\"headerlink\" title=\"头部删除\"></a>头部删除</h1><ul>\n<li><p>只要是删除就要<code>assert</code>判断是否要暴打。</p>\n</li>\n<li><p>有了头部插入的经验，头部删除显得游刃有余了，相反的，只要将每个数据向前挪动，也就是依次覆盖即可，最终第一个数据被覆盖的无影无踪。</p>\n</li>\n<li><p>当然<code>size</code>要减一，可不敢忘记了。</p>\n</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void SLPopFront(SL* ps)\n&#123;\n\tassert(ps &amp;&amp; !SLEmpty(ps));\n\n\tfor (int i &#x3D; 0; i &lt; ps-&gt;size - 1; i++) ps-&gt;a[i] &#x3D; ps-&gt;a[i + 1];\n\tps-&gt;size--;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"在pos位置插入数据\"><a href=\"#在pos位置插入数据\" class=\"headerlink\" title=\"在pos位置插入数据\"></a>在pos位置插入数据</h1><ul>\n<li><p>首先插入需要检查容量。</p>\n</li>\n<li><p>在<code>pos</code>位置插入数据，首先对这个<code>pos</code>理解一下：本章的<code>pos</code>不是下标，注意！他不是下标，而是规规矩矩的第几个位置，比如一串数列<code>1，2，3，4</code>，第一个位置就是只<code>1</code>所占的位置，如果要在第一个位置插入，那么<code>1</code>就会到当前的<code>2</code>的位置上去，也就是所谓的第二个位置。所以，这个<code>pos</code>，是以用户角度出发，但我们实现函数的时候要脑子清醒：我们操作的实际上是下标。</p>\n</li>\n<li><p>同样的，与头插差不多，都是要挪动数据，只不过挪动的数据范围不同，要操作的数的位置也不同，这也就更加要注意边界问题了。</p>\n</li>\n<li><p>当然，操作完成后，要记得<code>size</code>计数一次噢。</p>\n</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 在pos位置插入,pos表示在第几个位置插入，不是下标\nvoid SLInsert(SL* ps, int pos, SLDateType x)\n&#123;\n\tassert(ps);\n\t\n\tSLCheckCapacity(ps);\n\n\tfor (int i &#x3D; ps-&gt;size; i &gt; pos - 1; i--) ps-&gt;a[i] &#x3D; ps-&gt;a[i - 1];\n\tps-&gt;a[pos - 1] &#x3D; x;\n\tps-&gt;size++;\n&#125;</code></pre>\n\n<p><strong>有了该函数之后，前面的头插尾插都可以复用这个函数。</strong></p>\n<hr>\n<h1 id=\"删除pos位置的数据\"><a href=\"#删除pos位置的数据\" class=\"headerlink\" title=\"删除pos位置的数据\"></a>删除pos位置的数据</h1><ul>\n<li><p>既然是删除，首先就要来一套<code>assert</code>检查看是否要毒打。</p>\n</li>\n<li><p>删除，就是将<code>pos</code>后面的数据依次往前挪，最终<code>pos</code>这个位置上的数据会被覆盖，因为会挪动数据，依次效率也不是很高。</p>\n</li>\n<li><p>当然别忘了<code>size</code>减一噢。</p>\n</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 删除第pos个数据，pos不是下标，表示删除第几个\nvoid SLErase(SL* ps, int pos)\n&#123;\n\tassert(ps &amp;&amp; !SLEmpty(ps) &amp;&amp; pos &gt; 0 &amp;&amp; pos &lt;&#x3D; ps-&gt;size);\n\n\tfor (int i &#x3D; pos - 1; i &lt; ps-&gt;size - 1; i++) ps-&gt;a[i] &#x3D; ps-&gt;a[i + 1];\n\n\tps-&gt;size--;\n&#125;</code></pre>\n<p><strong>有了该函数后，前面的头删，尾删都可以复用这个函数。</strong></p>\n<hr>\n<h1 id=\"查找数据\"><a href=\"#查找数据\" class=\"headerlink\" title=\"查找数据\"></a>查找数据</h1><ul>\n<li>查找数据就是遍历一遍顺序表，如果找到了就返回<code>下标加一</code>，没找到就返回<code>-1</code>。</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 查找数据，返回正常对应位置，不是下标位置, 没找到返回-1\nint SLFind(SL* ps, SLDateType val)\n&#123;\n\tassert(ps);\n\n\tfor (int i &#x3D; 0; i &lt; ps-&gt;size; i++)\n\t\tif (ps-&gt;a[i] &#x3D;&#x3D; val) return i + 1;\n\treturn -1;\n&#125;</code></pre>\n\n\n\n\n\n<hr>\n<h1 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h1><ul>\n<li><p>修改数据也是根据<code>pos</code>位置来修改的，传入你想修改的位置，然后传入修改后的新数据，然后直接在<code>pos  - 1</code>(下标)位置修改，不需要遍历。</p>\n</li>\n<li><p>如果传入的<code>pos</code>不正确，直接暴打。</p>\n</li>\n<li><p>当然也可以先查找，在修改，也就是说，查找数据和修改数据两个接口函数可以一起用。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">**下面是相关功能代码实现：**\n\n\n&#96;&#96;&#96;c\n&#x2F;&#x2F; 修改数据,修改pos正常对应位置，不是下标\nvoid SLModify(SL* ps, int pos, SLDateType Mval)\n&#123;\n\tassert(ps &amp;&amp; pos &gt; 0 &amp;&amp; pos &lt;&#x3D; ps-&gt;size);\n\n\tps-&gt;a[pos - 1] &#x3D; Mval;\n&#125;</code></pre>\n\n\n<hr>\n<h1 id=\"销毁顺序表\"><a href=\"#销毁顺序表\" class=\"headerlink\" title=\"销毁顺序表\"></a>销毁顺序表</h1><ul>\n<li>由于向堆申请了空间，因此程序结束后需要将空间返还给系统，这里说的粗暴了点，销毁顺序表。</li>\n</ul>\n<p><strong>下面是相关功能代码实现：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 销毁顺序表\nvoid SLDestroy(SL* ps)\n&#123;\n\tassert(ps);\n\n\tfree(ps-&gt;a);\n\tps-&gt;capacity &#x3D; 0;\n\tps-&gt;size &#x3D; 0;\n&#125;</code></pre>\n\n\n\n<hr>\n<h1 id=\"整体代码\"><a href=\"#整体代码\" class=\"headerlink\" title=\"整体代码\"></a>整体代码</h1><p><font color=red size=5>SeqList.h</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 防止SeqList.h被重复包含\n#pragma once\n\n&#x2F;&#x2F; 所需头文件：\n&#x2F;&#x2F; 输入输出所需头文件\n#include &lt;stdio.h&gt;\n&#x2F;&#x2F; realloc，free所需头文件\n#include &lt;stdlib.h&gt;\n&#x2F;&#x2F; 判空所需头文件\n#include &lt;stdbool.h&gt;\n&#x2F;&#x2F; assert断言所需头文件\n#include &lt;assert.h&gt;\n\n&#x2F;&#x2F; 初始化容量，每次增容也是增加这个数量\n#define INIT_CAPACITY 8\n&#x2F;&#x2F; 这个为顺序表的数据类型\ntypedef int SLDateType;\n\n&#x2F;&#x2F; 顺序表\ntypedef struct SeqList\n&#123;\n\t&#x2F;&#x2F; a指向一个在堆上的空间（就是顺序表）\n\tSLDateType* a;\n\t&#x2F;&#x2F; 顺序表数据个数\n\tint size;\n\t&#x2F;&#x2F; 顺序表容量\n\tint capacity;\n&#125;SL;  &#x2F;&#x2F; typedef将struct SeqList重新命名为SL\n\n&#x2F;&#x2F; 初始化顺序表\nvoid SLInit(SL* ps);\n&#x2F;&#x2F; 打印顺序表\nvoid SLPrint(SL* ps);\n\n&#x2F;&#x2F; 检查容量\nvoid SLCheckCapacity(SL* ps);\n\n&#x2F;&#x2F; 尾插 尾删 头插 头删\nvoid SLPushBack(SL* ps, SLDateType x);\nvoid SLPopBack(SL* ps);\nvoid SLPushFront(SL* ps, SLDateType x);\nvoid SLPopFront(SL* ps);\n&#x2F;&#x2F; 在pos位置插入,pos表示在第几个位置插入，不是下标\nvoid SLInsert(SL* ps, int pos, SLDateType x);\n&#x2F;&#x2F; 删除第pos个数据，pos不是下标，表示删除第几个\nvoid SLErase(SL* ps, int pos);\n\n&#x2F;&#x2F; 查找数据，返回对应位置，不是下标位置, 没找到返回-1\nint SLFind(SL* ps, SLDateType val);\n&#x2F;&#x2F; 修改数据\nvoid SLModify(SL* ps, int pos, SLDateType Mval);\n\n&#x2F;&#x2F; 判空\nbool SLEmpty(SL* ps);\n&#x2F;&#x2F; 顺序表数据个数\nint SLSize(SL* ps);\n\n&#x2F;&#x2F; 使用了realloc，在堆上申请了空间，程序结束时要返还空间给系统\n&#x2F;&#x2F; 销毁顺序表\nvoid SLDestroy(SL* ps);\n</code></pre>\n\n\n<p><font color=red size=5>SeqList.c</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;SeqList.h&quot;\n\n&#x2F;&#x2F; 初始化顺序表\nvoid SLInit(SL* ps)\n&#123;\n\tassert(ps);\n\n\tps-&gt;a &#x3D; NULL;\n\tps-&gt;size &#x3D; 0;\n\tps-&gt;capacity &#x3D; 0;\n&#125;\n&#x2F;&#x2F; 打印顺序表\nvoid SLPrint(SL* ps)\n&#123;\n\tassert(ps);\n\n\tfor (int i &#x3D; 0; i &lt; ps-&gt;size; i++) printf(&quot;%d &quot;, ps-&gt;a[i]);\n\tprintf(&quot;\\n&quot;);\n&#125;\n\n&#x2F;&#x2F; 检查容量\nvoid SLCheckCapacity(SL* ps)\n&#123;\n\tassert(ps);\n\n\tif (ps-&gt;size &#x3D;&#x3D; ps-&gt;capacity)\n\t&#123;\n\t\tint newcapacity &#x3D; ps-&gt;capacity &#x3D;&#x3D; 0 ? INIT_CAPACITY : ps-&gt;capacity + INIT_CAPACITY;\n\t\t&#x2F;&#x2F; 开始没有空间，其功能相当于malloc\n\t\tSLDateType* tmp &#x3D; (SLDateType*)realloc(ps-&gt;a, sizeof(SLDateType) * newcapacity);\n\t\tassert(tmp);\n\t\tps-&gt;a &#x3D; tmp;\n\t\tps-&gt;capacity &#x3D; newcapacity;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 尾插 尾删 头插 头删\nvoid SLPushBack(SL* ps, SLDateType x)\n&#123;\n\t&#x2F;&#x2F;assert(ps);\n\n\t&#x2F;&#x2F;SLCheckCapacity(ps);\n\n\t&#x2F;&#x2F;ps-&gt;a[ps-&gt;size++] &#x3D; x;\n\n\tSLInsert(ps, ps-&gt;size + 1, x);\n&#125;\nvoid SLPopBack(SL* ps)\n&#123;\n\t&#x2F;&#x2F;assert(ps &amp;&amp; !SLEmpty(ps));\n\n\t&#x2F;&#x2F;ps-&gt;size--;\n\n\tSLErase(ps, ps-&gt;size);\n&#125;\nvoid SLPushFront(SL* ps, SLDateType x)\n&#123;\n\t&#x2F;&#x2F;assert(ps);\n\n\t&#x2F;&#x2F;SLCheckCapacity(ps);\n\n\t&#x2F;&#x2F;for (int i &#x3D; ps-&gt;size; i &gt; 0; i--) ps-&gt;a[i] &#x3D; ps-&gt;a[i - 1];\n\t&#x2F;&#x2F;ps-&gt;a[0] &#x3D; x;\n\t&#x2F;&#x2F;ps-&gt;size++;\n\n\tSLInsert(ps, 1, x);\n&#125;\nvoid SLPopFront(SL* ps)\n&#123;\n\t&#x2F;&#x2F;assert(ps &amp;&amp; !SLEmpty(ps));\n\n\t&#x2F;&#x2F;for (int i &#x3D; 0; i &lt; ps-&gt;size - 1; i++) ps-&gt;a[i] &#x3D; ps-&gt;a[i + 1];\n\t&#x2F;&#x2F;ps-&gt;size--;\n\n\tSLErase(ps, 1);\n&#125;\n&#x2F;&#x2F; 在pos位置插入,pos表示在第几个位置插入，不是下标\nvoid SLInsert(SL* ps, int pos, SLDateType x)\n&#123;\n\tassert(ps);\n\n\tSLCheckCapacity(ps);\n\n\tfor (int i &#x3D; ps-&gt;size; i &gt; pos - 1; i--) ps-&gt;a[i] &#x3D; ps-&gt;a[i - 1];\n\tps-&gt;a[pos - 1] &#x3D; x;\n\tps-&gt;size++;\n&#125;\n&#x2F;&#x2F; 删除第pos个数据，pos不是下标，表示删除第几个\nvoid SLErase(SL* ps, int pos)\n&#123;\n\tassert(ps &amp;&amp; !SLEmpty(ps) &amp;&amp; pos &gt; 0 &amp;&amp; pos &lt;&#x3D; ps-&gt;size);\n\n\tfor (int i &#x3D; pos - 1; i &lt; ps-&gt;size - 1; i++) ps-&gt;a[i] &#x3D; ps-&gt;a[i + 1];\n\n\tps-&gt;size--;\n&#125;\n\n&#x2F;&#x2F; 查找数据，返回正常对应位置，不是下标位置, 没找到返回-1\nint SLFind(SL* ps, SLDateType val)\n&#123;\n\tassert(ps);\n\n\tfor (int i &#x3D; 0; i &lt; ps-&gt;size; i++)\n\t\tif (ps-&gt;a[i] &#x3D;&#x3D; val) return i + 1;\n\treturn -1;\n&#125;\n&#x2F;&#x2F; 修改数据,修改pos正常对应位置，不是下标\nvoid SLModify(SL* ps, int pos, SLDateType Mval)\n&#123;\n\tassert(ps &amp;&amp; pos &gt; 0 &amp;&amp; pos &lt;&#x3D; ps-&gt;size);\n\n\tps-&gt;a[pos - 1] &#x3D; Mval;\n&#125;\n\n&#x2F;&#x2F; 判空\nbool SLEmpty(SL* ps)\n&#123;\n\tassert(ps);\n\treturn ps-&gt;size &#x3D;&#x3D; 0;\n&#125;\n&#x2F;&#x2F; 顺序表数据个数\nint SLSize(SL* ps)\n&#123;\n\tassert(ps);\n\treturn ps-&gt;size;\n&#125;\n\n&#x2F;&#x2F; 销毁顺序表\nvoid SLDestroy(SL* ps)\n&#123;\n\tassert(ps);\n\n\tfree(ps-&gt;a);\n\tps-&gt;capacity &#x3D; 0;\n\tps-&gt;size &#x3D; 0;\n&#125;</code></pre>\n\n\n<p><font color=red size=5>test.c</font></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;SeqList.h&quot;\n\nvoid test1()\n&#123;\n\tSL s;\n\tSLInit(&amp;s);\n\tSLPushBack(&amp;s, 1);\n\tSLPrint(&amp;s);\n\tSLPushBack(&amp;s, 2);\n\tSLPrint(&amp;s);\n\tSLPushBack(&amp;s, 3);\n\tSLPrint(&amp;s);\n\tSLPushBack(&amp;s, 4);\n\tSLPrint(&amp;s);\n\tSLPushBack(&amp;s, 5);\n\tSLPrint(&amp;s);\n\tSLPushBack(&amp;s, 6);\n\tSLPrint(&amp;s);\n\n\tSLDestroy(&amp;s);\n&#125;\n\nvoid test2()\n&#123;\n\tSL s;\n\tSLInit(&amp;s);\n\n\tSLPushFront(&amp;s, 1);\n\tSLPrint(&amp;s);\n\tSLPushFront(&amp;s, 2);\n\tSLPrint(&amp;s);\n\tSLPushFront(&amp;s, 3);\n\tSLPrint(&amp;s);\n\tSLPushFront(&amp;s, 4);\n\tSLPrint(&amp;s);\n\tSLPushFront(&amp;s, 5);\n\tSLPrint(&amp;s);\n\tSLPushFront(&amp;s, 6);\n\tSLPrint(&amp;s);\n\n\tSLPopFront(&amp;s);\n\tSLPrint(&amp;s);\n\tSLPopFront(&amp;s);\n\tSLPrint(&amp;s);\n\tSLPopFront(&amp;s);\n\tSLPrint(&amp;s);\n\tSLPopFront(&amp;s);\n\tSLPrint(&amp;s);\n\tSLPopFront(&amp;s);\n\tSLPrint(&amp;s);\n\tSLPopFront(&amp;s);\n\tSLPrint(&amp;s);\n\n\tSLDestroy(&amp;s);\n&#125;\n\nvoid test3()\n&#123;\n\tSL s;\n\tSLInit(&amp;s);\n\n\tSLPushBack(&amp;s, 1);\n\tSLPushBack(&amp;s, 2);\n\tSLPushBack(&amp;s, 3);\n\tSLPushBack(&amp;s, 4);\n\tSLPushBack(&amp;s, 5);\n\tSLPrint(&amp;s);\n\n\tSLInsert(&amp;s, 3, 99999);\n\tSLPrint(&amp;s);\n\tSLErase(&amp;s, 3);\n\tSLPrint(&amp;s);\n\tSLModify(&amp;s, SLFind(&amp;s, 3), 99999);\n\tSLPrint(&amp;s);\n\n\tSLDestroy(&amp;s);\n&#125;\n\nint main()\n&#123;\n\t&#x2F;&#x2F;test1();\n\t&#x2F;&#x2F;test2();\n\ttest3();\n\n\treturn 0;\n&#125;</code></pre>\n\n\n\n<hr>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>  <font color=red size=4><strong>学到这里，数据结构总算是入门了，当然数据结构后面还有很长的路要走，要继续努力！</font></strong></p></blockquote>\n<p><font color=blue size=4><strong>感谢阅读本小白的博客，错误的地方请严厉指出噢！</strong></font></p>\n","feature":null,"text":"前言 顺序表作为数据结构中的小小弟，还是很好应付的。说到数据结构，顺序表是我们的向导，它让你明白数据结构到底是干啥的，为啥数据结构这么的重要。 实际上，通讯录的底层就是一个顺序表，里面的增添联系人，删除联系人等一系列操作，都是基于顺序表实现的，这也侧面拖出了数据结构的作用。所以，...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E8%A1%A8\"><span class=\"toc-text\">初始化顺序表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8\"><span class=\"toc-text\">打印顺序表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A3%80%E6%9F%A5%E5%AE%B9%E9%87%8F\"><span class=\"toc-text\">检查容量</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%A4%E7%A9%BA\"><span class=\"toc-text\">判空</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">顺序表数据个数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">尾部插入</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%BE%E9%83%A8%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">尾部删除</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">头部插入</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%B4%E9%83%A8%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">头部删除</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">在pos位置插入数据</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">删除pos位置的数据</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">查找数据</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">修改数据</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%94%80%E6%AF%81%E9%A1%BA%E5%BA%8F%E8%A1%A8\"><span class=\"toc-text\">销毁顺序表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">整体代码</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"【数据结构】单链表","uid":"bfad240cf4f429ffe303cb01324aaae0","slug":"【数据结构】单链表","date":"2023-03-03T15:53:13.000Z","updated":"2023-03-03T15:56:22.300Z","comments":true,"path":"api/articles/【数据结构】单链表.json","keywords":null,"cover":"/photo/v2-99dff3d20928f72a1edd7aa1bebc4a21_r.jpg","text":" 前言 在学习数据结构时，单链表可谓是第一个需要跨越的台阶。 从C语言到数据结构，单链表能够真正的反映我们C语言到底学的扎不扎实，那是因为，单链表对于C语言中的指针，结构体，以及函数模块的实现有较高的要求。因此，通过本章的学习，要是能够自我实现单链表，那你的C语言功底会厚实，你的...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"21 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":6,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"带你轻松实现通讯录(C语言版)","uid":"d8d9f05eeb5cca634b8a4aa98273e85e","slug":"带你轻松实现通讯录-C语言版","date":"2023-03-03T15:50:40.000Z","updated":"2023-03-03T15:54:23.002Z","comments":true,"path":"api/articles/带你轻松实现通讯录-C语言版.json","keywords":null,"cover":"/photo/屏幕截图_20230218_121115.png","text":" 前言 学习&#x3D;&#x3D;C语言&#x3D;&#x3D;的小伙伴，相信都要经历实现通讯录这一关吧，接下来就带你手把手实现自己的通讯录！ 通讯录初始化 整个程序我们需要分三个文件，一个是头文件：Contacts.h：用来存放宏，结构体以及函数声明，还有需要用的库函数。一个...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":23,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":23,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"/photo/微信图片_20230209190414.jpg","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}}}}