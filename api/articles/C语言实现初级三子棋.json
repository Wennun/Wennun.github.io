{"title":"C语言实现初级三子棋","uid":"d5a6879e81b57b97e13538ee2b9c1dd3","slug":"C语言实现初级三子棋","date":"2023-02-17T14:07:06.000Z","updated":"2023-02-18T02:58:32.307Z","comments":true,"path":"api/articles/C语言实现初级三子棋.json","keywords":null,"cover":"/photo/p2.png","content":"<h1 id=\"一-前言\"><a href=\"#一-前言\" class=\"headerlink\" title=\"一. 前言\"></a>一. 前言</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>本章我们用C语言来实现一个初级的三子棋小游戏，三子棋想必大家都玩过，只要每一行或每一列或对角线三个棋相同，那么便获得胜利，由此我们分析下棋的步骤与获胜判断，来构建一个C语言三子棋的代码框架。</li>\n<li>游戏实现我们分装两个 .c （代码主函数与函数定义源代码）后缀的文件和一个 .h 的文件（头文件，函数声明）</li>\n<li>.h : game.h<br> .c : test.c  (主函数体文件) ||||||    game.c (函数定义文件)</li>\n</ul></blockquote>\n<ul>\n<li>以下是头文件里的库函数和函数声明：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 3\n#define COL 3\n\nvoid init_board(char board[ROW][COL], int row, int col);\n\nvoid print_board(char board[ROW][COL], int row, int col);\n\nvoid player_move(char board[ROW][COL], int row, int col);\n\nvoid computer_move(char board[ROW][COL], int row, int col);\n\nchar is_win(char board[ROW][COL], int row, int col);</code></pre>\n\n<ul>\n<li>只要我们分别在另外两个 .c 文件（一个是主函数体一个是函数定义）中引入</li>\n</ul>\n<p>#include “game.h”  那么三个文件就相互作用了。</p>\n<p><strong>这里先把主函数的调用结构放在这，以便后面读起来有迹可循：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    1.PLAY    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    0.EXIT    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar ret &#x3D; 0;\n\tchar board[ROW][COL];\n\n\tinit_board(board, ROW, COL); &#x2F;&#x2F; 初始化棋盘\n\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\n\twhile (1)\n\t&#123;\n\t\tplayer_move(board, ROW, COL); &#x2F;&#x2F; 玩家下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\tcomputer_move(board, ROW, COL); &#x2F;&#x2F; 电脑下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\tif (ret &#x3D;&#x3D; &#39;*&#39;)\n\t&#123;\n\t\tprintf(&quot;玩家获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;#&#39;)\n\t&#123;\n\t\tprintf(&quot;电脑获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;Q&#39;)\n\t&#123;\n\t\tprintf(&quot;平局！\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 玩家赢返回‘*’\n&#x2F;&#x2F; 电脑赢返回‘#’\n&#x2F;&#x2F; 平局返回 ‘Q’\n&#x2F;&#x2F; 游戏继续返回 ‘C’\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\t\t\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;您已进入三子棋游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tSleep(1000); &#x2F;&#x2F; 游戏玩完后停顿一秒\n\t\t\tsystem(&quot;cls&quot;); &#x2F;&#x2F; 清屏\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏!&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误,请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;</code></pre>\n\n\n\n\n<h1 id=\"二-游戏版面与开始游戏的构建\"><a href=\"#二-游戏版面与开始游戏的构建\" class=\"headerlink\" title=\"二. 游戏版面与开始游戏的构建\"></a>二. 游戏版面与开始游戏的构建</h1><ul>\n<li>我们首先要打印一个菜单供玩家选择&lt;输入1&gt;则进入游戏，&lt;输入0&gt;则退出游戏，&lt;输入其它的数&gt;则输入错误，然后继续输入判断。为了一开始就让用户先选择，再判断输入的值然后判断是否再次输入，这里我们采用do-while循环结构，无论如何用户先选择一次，然后do-while里头采用switch-case来判断输入的值，而菜单我们调用一个menu（）函数来打印，下面是在主函数里的代码实现：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nvoid menu()\n&#123;\n\tprintf(&quot;***************************************\\n&quot;);\n\tprintf(&quot;***************************************\\n&quot;);\n\tprintf(&quot;************    1.PLAY     ************\\n&quot;);\n\tprintf(&quot;************    0.EXIT     ************\\n&quot;);\n\tprintf(&quot;***************************************\\n&quot;);\n\tprintf(&quot;***************************************\\n&quot;);\n&#125;\n\nvoid test()\n&#123;\n\tint input &#x3D; 0;\n\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;进入三子棋游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\n\t\t\t&#x2F;&#x2F;game(); &#x2F;&#x2F;&#x2F;  游戏实现\n\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误，请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\t&#125; while (input);  &#x2F;&#x2F;&#x2F;  以输入的值来判断是否还想再来一次游戏\n&#125;\n\nint main()\n&#123;\n\ttest();  &#x2F;&#x2F;&#x2F;  整体的框架结构函数\n\n\treturn 0;\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/6aeeee50c00f43b3b1c926ba149e3e9a.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>我们可以看到， 这样简易的游戏初始菜单就制作好啦。</li>\n</ul>\n<h1 id=\"三-棋盘初始化与打印棋盘\"><a href=\"#三-棋盘初始化与打印棋盘\" class=\"headerlink\" title=\"三. 棋盘初始化与打印棋盘\"></a>三. 棋盘初始化与打印棋盘</h1><ul>\n<li>棋盘的初始化与棋盘的打印是在上面的game（）函数里实现的，我们知道，三子棋的棋盘是3×3的，这里我们不妨定义一个字符类型的二维数组（三行三列），开始我们每个元素放一个空格，这便棋盘初始化了。</li>\n</ul>\n<p>下面是初始化代码实现：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void init_board(char board[ROW][COL], int row, int col); void init_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; &#39; &#39;;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<ul>\n<li>而这里的难点在于如何将一个棋盘打印出来，首先我们来看下棋盘的样子：<br><img src=\"https://img-blog.csdnimg.cn/9aac2cff3ae64f95bae0a0cd729f68b5.png#pic_center\" alt=\"在这里插入图片描述\"></li>\n<li>可以看到，第一行的元素是 空格%c空格|空格%c空格|空格%c空格（%c为初始化的空格）（这一行打印了三次），第二行的元素为—|—|—（这一行打印了两次），为了实打实的打印棋盘，这里需要判断语句与循环语句的相互作用来实现，下面是代码实现：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void print_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)  &#x2F;&#x2F; 打印三次，每次分别打印两行内容（最后一次打印一行）\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)  &#x2F;&#x2F; 打印  ； | |  ；\n\t\t&#123;\n\t\t\tprintf(&quot; %c &quot;, board[i][j]);\n\t\t\tif (j &lt; col - 1)  &#x2F;&#x2F;  最后一个 | 不打印\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t\tif (i &lt; row - 1)  &#x2F;&#x2F; 最后一行 ---|---|---  不打印\n\t\t&#123;\n\t\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;---&quot;);\n\t\t\t\tif (j &lt; col - 1)  &#x2F;&#x2F;  最后一个 | 不打印\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"四-玩家下棋\"><a href=\"#四-玩家下棋\" class=\"headerlink\" title=\"四. 玩家下棋\"></a>四. 玩家下棋</h1><ul>\n<li>玩家下棋是输入棋盘的坐标然后将 ‘ * ’ 号放进去 ，由于玩家很大可能不是程序员，不知道数组的下标是从零开始，这里我们采用1，2，3混合坐标来输入，如果玩家输入两个值（用空格隔开）形成的坐标在1，2，3三个数字组成的成对组合范围内并且输入的那个坐标此时为 ‘  ’ ，那么玩家下棋成功，放个 ‘ * ’ 字符进去，如果玩家输入的坐标超过所形成范围或者该坐标已有棋子，那么提示玩家输入的错误，并且重新输入。下面是玩家下棋的代码实现：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void player_move(char board[ROW][COL], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\n\twhile (1)  &#x2F;&#x2F; 用户重复输入直到下棋成功为止跳出\n\t&#123;\n\t\tprintf(&quot;玩家下棋：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; 3 &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; 3)\n\t\t&#123;\n\t\t\tif (board[x - 1][y - 1] &#x3D;&#x3D; &#39; &#39;)\n\t\t\t&#123;\n\t\t\t\tboard[x - 1][y - 1] &#x3D; &#39;*&#39;;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;该位置已被占，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标错误，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"五-电脑下棋\"><a href=\"#五-电脑下棋\" class=\"headerlink\" title=\"五. 电脑下棋\"></a>五. 电脑下棋</h1><ul>\n<li><p>电脑下棋，其实就是电脑随机产生两个可控（1 - 3）数然后接受值并将值重复与玩家下棋相同道理的代码实现。<br><img src=\"https://img-blog.csdnimg.cn/b3f8ba3300504ad2ba184b7a72f16ec8.png#pic_center\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/606b89ff0583480f9dfa3fb53043473d.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>为了使产生的随机数一直在变化，由于时间是一直在变化的，所以这里我们使用时间函数：<br><img src=\"https://img-blog.csdnimg.cn/402a0034526b42bdb0c3ef71f4531c11.png#pic_center\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/334588d1523f474fbd38ccc92c341088.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>下面是电脑下棋的整个代码实现：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void computer_move(char board[ROW][COL], int row, int col)\n&#123;\n\tprintf(&quot;电脑下棋：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\twhile (1)  &#x2F;&#x2F; 电脑随机产生数判断下棋成功跳出   下面是产生随机坐标判断\n\t&#123;\n\t\tint x &#x3D; rand() % row;\n\t\tint y &#x3D; rand() % row;\n\t\tif (board[x][y] &#x3D;&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;#&#39;;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>由于电脑下棋是随机的，所以我们想赢是很简单的事啦。</li>\n<li>对了， rand使用前提需要调用srand（），它在前面的主函数代码块中显示啦。</li>\n</ul></blockquote>\n<h1 id=\"六-判断输赢\"><a href=\"#六-判断输赢\" class=\"headerlink\" title=\"六. 判断输赢\"></a>六. 判断输赢</h1><ul>\n<li>三子棋当三个棋子相同时便获胜，这里可以是三行三列两对角线，我们如何来判断输赢呢？</li>\n<li>我们在每一次玩家下棋完或者电脑下棋完后都要判断他是否获胜，这里获胜的判断我们返回一个值来进行比对，比对如下（这里只是展示一下如何判断返回值来确定是否获胜，代码不连贯不衔接，语法错误存在）：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 玩家赢返回‘*’\n&#x2F;&#x2F; 电脑赢返回‘#’\n&#x2F;&#x2F; 平局返回 ‘Q’\n&#x2F;&#x2F; 游戏继续返回 ‘C’\n\n\nret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\nif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n&#123;\n\tbreak;\n&#125;\n\n\nif (ret &#x3D;&#x3D; &#39;*&#39;)\n&#123;\n\tprintf(&quot;玩家获胜！\\n&quot;);\n&#125;\nelse if (ret &#x3D;&#x3D; &#39;#&#39;)\n&#123;\n\tprintf(&quot;电脑获胜！\\n&quot;);\n&#125;\nelse if (ret &#x3D;&#x3D; &#39;Q&#39;)\n&#123;\n\tprintf(&quot;平局！\\n&quot;);\n&#125;\n</code></pre>\n\n\n<ul>\n<li>下面是输赢本质 is_win() 函数定义的一个代码展示：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">char is_win(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)  &#x2F;&#x2F; 行判断\n\t&#123;\n\t\tif (board[i][0] &#x3D;&#x3D; board[i][1] &amp;&amp; board[i][1] &#x3D;&#x3D; board[i][2] &amp;&amp; board[i][0] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[i][0];\n\t\t&#125;\n\t&#125;\n\n\tfor (j &#x3D; 0; j &lt; col; j++)  &#x2F;&#x2F; 列判断\n\t&#123;\n\t\tif (board[0][j] &#x3D;&#x3D; board[1][j] &amp;&amp; board[1][j] &#x3D;&#x3D; board[2][j] &amp;&amp; board[0][j] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[0][j];\n\t\t&#125;\n\t&#125;\n\n\tif (board[0][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[2][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;) &#x2F;&#x2F; 对角线判断\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\tif (board[2][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[0][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;)  &#x2F;&#x2F; 对角线判断\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\treturn &#39;C&#39;;  &#x2F;&#x2F; 这里如果前面的语句都没进入，那么返回 ‘C’ ，游戏继续\n&#125;</code></pre>\n\n<h1 id=\"七-整体的代码展示\"><a href=\"#七-整体的代码展示\" class=\"headerlink\" title=\"七. 整体的代码展示\"></a>七. 整体的代码展示</h1><ul>\n<li>game.h</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;windows.h&gt;\n\n#define ROW 3\n#define COL 3\n\nvoid init_board(char board[ROW][COL], int row, int col);\n\nvoid print_board(char board[ROW][COL], int row, int col);\n\nvoid player_move(char board[ROW][COL], int row, int col);\n\nvoid computer_move(char board[ROW][COL], int row, int col);\n\nchar is_win(char board[ROW][COL], int row, int col);\n\n</code></pre>\n<ul>\n<li>test.c (主函数模块)：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;game.h&quot;\n\nvoid menu()\n&#123;\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    1.PLAY    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;***********&gt;&gt;&gt;    0.EXIT    &lt;&lt;&lt;***********\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n\tprintf(&quot;******************************************\\n&quot;);\n&#125;\n\nvoid game()\n&#123;\n\tchar ret &#x3D; 0;\n\tchar board[ROW][COL];\n\n\tinit_board(board, ROW, COL); &#x2F;&#x2F; 初始化棋盘\n\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\n\twhile (1)\n\t&#123;\n\t\tplayer_move(board, ROW, COL); &#x2F;&#x2F; 玩家下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\tcomputer_move(board, ROW, COL); &#x2F;&#x2F; 电脑下棋\n\t\tprint_board(board, ROW, COL); &#x2F;&#x2F; 打印棋盘\n\t\tret &#x3D; is_win(board, ROW, COL); &#x2F;&#x2F; 判断输赢\n\t\tif (ret !&#x3D; &#39;C&#39;) &#x2F;&#x2F; 用返回值ret来判断输赢\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\tif (ret &#x3D;&#x3D; &#39;*&#39;)\n\t&#123;\n\t\tprintf(&quot;玩家获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;#&#39;)\n\t&#123;\n\t\tprintf(&quot;电脑获胜！\\n&quot;);\n\t&#125;\n\telse if (ret &#x3D;&#x3D; &#39;Q&#39;)\n\t&#123;\n\t\tprintf(&quot;平局！\\n&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 玩家赢返回‘*’\n&#x2F;&#x2F; 电脑赢返回‘#’\n&#x2F;&#x2F; 平局返回 ‘Q’\n&#x2F;&#x2F; 游戏继续返回 ‘C’\n\nvoid test()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();\n\t\tprintf(&quot;请选择：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d&quot;, &amp;input);\n\t\t\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tprintf(&quot;您已进入三子棋游戏：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tgame();\n\t\t\tSleep(1000); &#x2F;&#x2F; 游戏玩完后停顿一秒\n\t\t\tsystem(&quot;cls&quot;); &#x2F;&#x2F; 清屏\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(&quot;退出游戏!&quot;);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误,请重新选择：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\tbreak;\n\t\t&#125;\n\n\t&#125; while (input);\n&#125;\n\nint main()\n&#123;\n\ttest();\n\n\treturn 0;\n&#125;</code></pre>\n\n\n<ul>\n<li>game.c (函数实现文件)</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &quot;game.h&quot;\n\nvoid init_board(char board[ROW][COL], int row, int col); void init_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; &#39; &#39;;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nvoid print_board(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot; %c &quot;, board[i][j]);\n\t\t\tif (j &lt; col - 1)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t\tif (i &lt; row - 1)\n\t\t&#123;\n\t\t\tfor (j &#x3D; 0; j &lt; col; j++)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;---&quot;);\n\t\t\t\tif (j &lt; col - 1)\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;|&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nvoid player_move(char board[ROW][COL], int row, int col)\n&#123;\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\n\twhile (1)\n\t&#123;\n\t\tprintf(&quot;玩家下棋：&gt;&gt;&gt;&gt;&gt;&gt; &quot;);\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; 3 &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; 3)\n\t\t&#123;\n\t\t\tif (board[x - 1][y - 1] &#x3D;&#x3D; &#39; &#39;)\n\t\t\t&#123;\n\t\t\t\tboard[x - 1][y - 1] &#x3D; &#39;*&#39;;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;该位置已被占，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;输入坐标错误，请重新输入：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid computer_move(char board[ROW][COL], int row, int col)\n&#123;\n\tprintf(&quot;电脑下棋：&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);\n\twhile (1)\n\t&#123;\n\t\tint x &#x3D; rand() % row;\n\t\tint y &#x3D; rand() % row;\n\t\tif (board[x][y] &#x3D;&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\tboard[x][y] &#x3D; &#39;#&#39;;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\nchar is_win(char board[ROW][COL], int row, int col)\n&#123;\n\tint i &#x3D; 0;\n\tint j &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; row; i++)\n\t&#123;\n\t\tif (board[i][0] &#x3D;&#x3D; board[i][1] &amp;&amp; board[i][1] &#x3D;&#x3D; board[i][2] &amp;&amp; board[i][0] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[i][0];\n\t\t&#125;\n\t&#125;\n\n\tfor (j &#x3D; 0; j &lt; col; j++)\n\t&#123;\n\t\tif (board[0][j] &#x3D;&#x3D; board[1][j] &amp;&amp; board[1][j] &#x3D;&#x3D; board[2][j] &amp;&amp; board[0][j] !&#x3D; &#39; &#39;)\n\t\t&#123;\n\t\t\treturn board[0][j];\n\t\t&#125;\n\t&#125;\n\n\tif (board[0][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[2][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;)\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\tif (board[2][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] &#x3D;&#x3D; board[0][2] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;)\n\t&#123;\n\t\treturn board[1][1];\n\t&#125;\n\n\treturn &#39;C&#39;;\n&#125;</code></pre>\n\n<h1 id=\"八-总结\"><a href=\"#八-总结\" class=\"headerlink\" title=\"八. 总结\"></a>八. 总结</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>三子棋对我们综合使用分支，循环，函数有很好的训练效果，只有我们不断的去写代码，去掌握语法之间的逻辑，才能更细致的打出优质程序。</p></blockquote>\n","text":"一. 前言 本章我们用C语言来实现一个初级的三子棋小游戏，三子棋想必大家都玩过，只要每一行或每一列或对角线三个棋相同，那么便获得胜利，由此我们分析下棋的步骤与获胜判断，来构建一个C语言三子棋的代码框架。 游戏实现我们分装两个 .c （代码主函数与函数定义源代码）后缀的文件和一个 ...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":22,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":22,"path":"api/tags/C语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">一. 前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E6%B8%B8%E6%88%8F%E7%89%88%E9%9D%A2%E4%B8%8E%E5%BC%80%E5%A7%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E6%9E%84%E5%BB%BA\"><span class=\"toc-text\">二. 游戏版面与开始游戏的构建</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89-%E6%A3%8B%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%89%93%E5%8D%B0%E6%A3%8B%E7%9B%98\"><span class=\"toc-text\">三. 棋盘初始化与打印棋盘</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E7%8E%A9%E5%AE%B6%E4%B8%8B%E6%A3%8B\"><span class=\"toc-text\">四. 玩家下棋</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94-%E7%94%B5%E8%84%91%E4%B8%8B%E6%A3%8B\"><span class=\"toc-text\">五. 电脑下棋</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AD-%E5%88%A4%E6%96%AD%E8%BE%93%E8%B5%A2\"><span class=\"toc-text\">六. 判断输赢</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%83-%E6%95%B4%E4%BD%93%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA\"><span class=\"toc-text\">七. 整体的代码展示</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AB-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">八. 总结</span></a></li></ol>","author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C语言的分支与循环#熟练使用，出手就有#","uid":"e0b663ff8593ec90044339189f2bc842","slug":"C语言的分支与循环-熟练使用，出手就有","date":"2023-02-17T14:08:48.000Z","updated":"2023-02-18T02:58:41.363Z","comments":true,"path":"api/articles/C语言的分支与循环-熟练使用，出手就有.json","keywords":null,"cover":[],"text":"一. 前言 分支和循环在C语言中几乎无处不在，作为重要的一部分，精确掌握其语法和运用逻辑，是继续向下学习的“地基”。 二. 分支语句1. if 分支语句if 就是如果，如果怎么怎么样就干嘛干嘛，在C语言中，其表达效果也是如此。 if (表达式) &#x2F;&#x2F; 表达式为...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"C语言相关知识的深度解析","slug":"C语言相关知识的深度解析","count":22,"path":"api/categories/C语言相关知识的深度解析.json"}],"tags":[{"name":"C语言","slug":"C语言","count":22,"path":"api/tags/C语言.json"}],"author":{"name":"坏 幸 运","slug":"blog-author","avatar":"https://ts1.cn.mm.bing.net/th/id/R-C.0bab160015bf9e56450d5fded33bd448?rik=VFMstq3mAZG1pg&riu=http%3a%2f%2fwww.qzqn8.com%2fwp-content%2fuploads%2f2020%2f02%2f3-9.jpg&ehk=pnkhUlGCDYmxisEuCwYL4zXW92froAxt%2f0B5i9AYAkY%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","link":"/","description":"Believe in yourself, you can do it --- <Learn from each other> WX-xmdx99999999","socials":{"github":"https://github.com/Wennun/Wennun.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Wennytime","juejin":"","customs":{}}}},"next_post":{}}